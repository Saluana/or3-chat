This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: README.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
auth/
  models-service.md
  openrouter-auth.md
  openrouter-build.md
  useOpenrouter.md
  useUserApiKey.md
composables/
  useActivePrompt.md
  useAiSettings.md
  useChat.md
  useChatInputBridge.md
  useComposerActions.md
  useDashboardPlugins.md
  useDefaultPrompt.md
  useDocumentHistoryActions.md
  useDocumentsList.md
  useDocumentsStore.md
  useEditorNodes.md
  useEditorToolbar.md
  useHeaderActions.md
  useHookEffect.md
  useMessageActions.md
  useMessageEditing.md
  useModelStore.md
  useMultiPane.md
  usePaneDocuments.md
  usePanePrompt.md
  usePreviewCache.md
  useProjectsCrud.md
  useProjectTreeActions.md
  useSidebarSearch.md
  useSidebarSections.md
  useStreamAccumulator.md
  useThreadHistoryActions.md
  useThreadSearch.md
  useWorkspaceBackup.md
database/
  attachments.md
  branching.md
  client.md
  dbTry.md
  documents.md
  files-select.md
  files-util.md
  files.md
  index.md
  kv.md
  message-files.md
  messages.md
  posts.md
  projects.md
  prompts.md
  schema.md
  threads.md
  util.md
hooks/
  hook-catalog.md
  hook-keys.md
  hook-types.md
  hooks.md
  typed-hooks.md
  useHooks.md
types/
  composables.md
  database.md
  hooks.md
docmap.json
llms.xml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="auth/models-service.md">
# modelsService

Service for fetching, caching, and filtering OpenRouter's model catalog. Provides utilities to query available models by text, modalities, context length, parameters, and pricing tier.

Think of `modelsService` as your model marketplace — it keeps an up-to-date catalog of 200+ OpenRouter models with powerful filtering to find exactly what you need.

---

## What does it do?

`modelsService` manages the OpenRouter model catalog by:

- Fetching the latest model list from OpenRouter API
- Caching models locally (1 hour TTL by default)
- Filtering by text search, modalities, context, parameters, and price
- Resolving default model based on settings and availability

---

## Basic Example

```ts
import { modelsService } from '~/core/auth/models-service';

// Fetch all models
const models = await modelsService.fetchModels();

// Filter by text
const gpts = modelsService.filterByText(models, 'gpt');

// Find vision models
const vision = modelsService.filterByModalities(models, {
  input: ['image'],
  output: ['text']
});

// Find cheap models
const cheap = modelsService.filterByPriceBucket(models, 'free');
```

---

## How to use it

### 1. Fetch models

```ts
// Get all available models
const models = await modelsService.fetchModels();

// Force refresh (ignore cache)
const fresh = await modelsService.fetchModels({ force: true });

// Custom TTL (2 hours)
const models = await modelsService.fetchModels({ ttlMs: 2 * 60 * 60 * 1000 });
```

### 2. Search by text

```ts
const query = 'claude';
const claudes = modelsService.filterByText(models, query);
// Searches: id, name, description
```

### 3. Filter by modalities

```ts
// Vision models (image input)
const vision = modelsService.filterByModalities(models, {
  input: ['image']
});

// Models that can generate images
const imageGen = modelsService.filterByModalities(models, {
  output: ['image']
});

// Text-to-image models
const txt2img = modelsService.filterByModalities(models, {
  input: ['text'],
  output: ['image']
});
```

### 4. Filter by context length

```ts
// Models with at least 100K context
const longContext = modelsService.filterByContextLength(models, 100000);
```

### 5. Filter by supported parameters

```ts
// Models supporting reasoning
const reasoning = modelsService.filterByParameters(models, ['reasoning']);

// Models supporting temperature and top_p
const flexible = modelsService.filterByParameters(models, [
  'temperature',
  'top_p'
]);
```

### 6. Filter by price

```ts
// Free models
const free = modelsService.filterByPriceBucket(models, 'free');

// Low-cost models (< $0.000002 per token)
const budget = modelsService.filterByPriceBucket(models, 'low');

// Medium cost
const medium = modelsService.filterByPriceBucket(models, 'medium');

// All models
const any = modelsService.filterByPriceBucket(models, 'any');
```

### 7. Resolve default model

```ts
import { resolveDefaultModel } from '~/core/auth/models-service';

const selected = resolveDefaultModel(
  {
    defaultModelMode: 'fixed',
    fixedModelId: 'anthropic/claude-3-sonnet'
  },
  {
    isAvailable: (id) => models.some(m => m.id === id),
    lastSelectedModelId: () => localStorage.getItem('last_model'),
    recommendedDefault: () => 'openai/gpt-oss-120b'
  }
);

// Result: { id: 'anthropic/claude-3-sonnet', reason: 'fixed' }
```

---

## Model Format

Each model object has:

```ts
interface OpenRouterModel {
  id: string;                          // e.g. 'anthropic/claude-3-sonnet'
  name: string;
  description?: string;
  created?: number;                    // Unix timestamp
  architecture?: {
    input_modalities?: string[];       // ['text', 'image']
    output_modalities?: string[];      // ['text']
    tokenizer?: string;
    instruct_type?: string;
  };
  top_provider?: {
    is_moderated?: boolean;
    context_length?: number;           // Max input tokens
    max_completion_tokens?: number;    // Max output tokens
  };
  pricing?: {
    prompt?: string;                   // USD per 1M input tokens
    completion?: string;               // USD per 1M output tokens
    image?: string;
    request?: string;
    web_search?: string;
    internal_reasoning?: string;
    input_cache_read?: string;
    input_cache_write?: string;
  };
  canonical_slug?: string;
  context_length?: number;             // Alternative field
  hugging_face_id?: string;
  supported_parameters?: string[];     // ['temperature', 'top_p', 'reasoning']
}
```

---

## Caching Strategy

### Default cache

- **Key**: `'openrouter_model_catalog_v1'` in localStorage
- **TTL**: 1 hour
- **Size**: ~50KB (all models JSON)

### Cache invalidation

```ts
// Force refresh
await modelsService.fetchModels({ force: true });

// Manual clear
localStorage.removeItem('openrouter_model_catalog_v1');
```

### Fallback

If fetch fails, returns last cached data if available.

---

## Common patterns

### Multi-filter query

```ts
let results = models;

// Start with all models
results = modelsService.filterByText(results, 'claude');
results = modelsService.filterByModalities(results, { input: ['image'] });
results = modelsService.filterByContextLength(results, 100000);
results = modelsService.filterByPriceBucket(results, 'low');

console.log(`Found ${results.length} models`);
```

### Vision model selector

```ts
async function getVisionModels() {
  const models = await modelsService.fetchModels();
  return modelsService.filterByModalities(models, {
    input: ['image'],
    output: ['text']
  }).sort((a, b) => {
    // Sort by price (cheapest first)
    const aPrice = toNumber(a.pricing?.prompt) ?? Infinity;
    const bPrice = toNumber(b.pricing?.prompt) ?? Infinity;
    return aPrice - bPrice;
  });
}
```

### Model availability check

```ts
async function isModelAvailable(modelId: string) {
  const models = await modelsService.fetchModels();
  return models.some(m => m.id === modelId);
}
```

### Find best for task

```ts
async function findBestModel(task: 'vision' | 'reasoning' | 'text') {
  let models = await modelsService.fetchModels();
  
  switch (task) {
    case 'vision':
      models = modelsService.filterByModalities(models, { input: ['image'] });
      break;
    case 'reasoning':
      models = modelsService.filterByParameters(models, ['reasoning']);
      break;
  }
  
  // Sort by price
  models = modelsService.filterByPriceBucket(models, 'low');
  
  return models[0] || null;
}
```

---

## Important notes

### Authentication

- Without API key: Sees all models
- With API key: Sees additional info (pricing, context limits)
- Never expose key in requests; use server-side if needed

### Price format

Prices are **stringified decimals**:
- `"0.00001"` = $0.00001 per token
- `"0"` = Free
- Can be converted with `Number(string)`

Price buckets are heuristic:
- **free**: $0
- **low**: > $0 and ≤ $0.000002
- **medium**: > $0.000002 and ≤ $0.00001

### Context length

- **Input context**: Maximum tokens for prompt history
- **Max completion**: Maximum tokens model can generate
- Some models return both, some only one

### Modalities

Common modalities:
- **input**: `'text'`, `'image'`, `'audio'`
- **output**: `'text'`, `'image'`, `'audio'`

Check model docs for exact support.

### Rate limits

- No explicit rate limits for model listing
- Queries cached locally for 1 hour
- Multiple rapid fetches use same cache

---

## Filtering chaining

All filters return a new array, safe to chain:

```ts
const result = modelsService.filterByText(
  modelsService.filterByModalities(
    modelsService.filterByPriceBucket(models, 'low'),
    { input: ['text'] }
  ),
  'claude'
);
```

---

## Default model resolution

Helper to pick default model based on settings:

```ts
interface AiSettingsForModel {
  defaultModelMode: 'lastSelected' | 'fixed';
  fixedModelId: string | null;
}

interface ModelResolverDeps {
  isAvailable: (id: string) => boolean;
  lastSelectedModelId: () => string | null;
  recommendedDefault: () => string;
}

function resolveDefaultModel(
  set: AiSettingsForModel,
  deps: ModelResolverDeps
): { id: string; reason: 'fixed' | 'lastSelected' | 'recommended' }
```

Priority:
1. **Fixed**: Use configured fixed model if available
2. **Last selected**: Use previously selected model if available
3. **Recommended**: Fall back to recommended default

---

## Related

- `useChat` — uses models for API calls
- `useModelStore` — wraps this service in composable
- `useAiSettings` — stores default model preference
- OpenRouter API docs — model catalog endpoint

---

## TypeScript

```ts
export interface OpenRouterModel {
  id: string;
  name: string;
  description?: string;
  // ... (see Model Format section)
}

export interface ModelCatalogCache {
  data: OpenRouterModel[];
  fetchedAt: number;
}

export interface AiSettingsForModel {
  defaultModelMode: 'lastSelected' | 'fixed';
  fixedModelId: string | null;
}

export interface ModelResolverDeps {
  isAvailable: (id: string) => boolean;
  lastSelectedModelId: () => string | null;
  recommendedDefault: () => string;
}

export type PriceBucket = 'free' | 'low' | 'medium' | 'any';

export async function fetchModels(opts?: {
  force?: boolean;
  ttlMs?: number;
}): Promise<OpenRouterModel[]>;

export function filterByText(
  models: OpenRouterModel[],
  q: string
): OpenRouterModel[];

export function filterByModalities(
  models: OpenRouterModel[],
  opts?: { input?: string[]; output?: string[] }
): OpenRouterModel[];

export function filterByContextLength(
  models: OpenRouterModel[],
  minCtx: number
): OpenRouterModel[];

export function filterByParameters(
  models: OpenRouterModel[],
  params: string[]
): OpenRouterModel[];

export function filterByPriceBucket(
  models: OpenRouterModel[],
  bucket: PriceBucket
): OpenRouterModel[];

export function resolveDefaultModel(
  set: AiSettingsForModel,
  deps: ModelResolverDeps
): { id: string; reason: 'fixed' | 'lastSelected' | 'recommended' };

export const modelsService: {
  fetchModels: typeof fetchModels;
  filterByText: typeof filterByText;
  filterByModalities: typeof filterByModalities;
  filterByContextLength: typeof filterByContextLength;
  filterByParameters: typeof filterByParameters;
  filterByPriceBucket: typeof filterByPriceBucket;
};
```

---

Document generated from `app/core/auth/models-service.ts` implementation.
</file>

<file path="auth/openrouter-auth.md">
# exchangeOpenRouterCode

Server-safe function that exchanges an OpenRouter authorization code for an API key. Handles PKCE code verification and retrieves the user's API key after successful authentication.

Think of `exchangeOpenRouterCode` as the backend handshake — after OpenRouter redirects you back, this function verifies your code and gets your key.

---

## What does it do?

`exchangeOpenRouterCode` completes the OAuth flow by:

- Sending the authorization code to OpenRouter
- Verifying the PKCE code verifier
- Retrieving the user's API key
- Handling network and API errors gracefully

---

## Basic Example

```ts
import { exchangeOpenRouterCode } from '~/core/auth/openrouter-auth';

// After being redirected from OpenRouter
const result = await exchangeOpenRouterCode({
  code: 'auth_code_from_openrouter',
  verifier: 'code_verifier_from_session_storage',
  codeMethod: 'S256'
});

if (result.ok) {
  console.log('Got key:', result.userKey);
  // Store key in state/DB
} else {
  console.error('Exchange failed:', result.reason);
}
```

---

## How to use it

### 1. Call after redirect

```ts
import { exchangeOpenRouterCode, type ExchangeParams } from '~/core/auth/openrouter-auth';

const params: ExchangeParams = {
  code: getUrlParam('code'),
  verifier: sessionStorage.getItem('openrouter_code_verifier') || '',
  codeMethod: sessionStorage.getItem('openrouter_code_method') || 'plain'
};

const result = await exchangeOpenRouterCode(params);
```

### 2. Handle success

```ts
if (result.ok) {
  const apiKey = result.userKey;
  const status = result.status;
  
  // Store the key
  await db.kv.set({ name: 'openrouter_api_key', value: apiKey });
}
```

### 3. Handle failure

```ts
if (!result.ok) {
  switch (result.reason) {
    case 'network':
      console.error('Network error - check connection');
      break;
    case 'bad-response':
      console.error('OpenRouter returned error:', result.status);
      break;
    case 'no-key':
      console.error('No key in response');
      break;
  }
}
```

### 4. Custom fetch (for testing)

```ts
const result = await exchangeOpenRouterCode({
  code: 'test_code',
  verifier: 'test_verifier',
  codeMethod: 'plain',
  fetchImpl: customFetch, // Use your own fetch
  attempt: 1 // Retry attempt number
});
```

---

## What you get back

### Success Response

```ts
interface ExchangeResultSuccess {
  ok: true;
  userKey: string;      // The API key
  status: number;       // HTTP 200 etc
}
```

### Failure Response

```ts
interface ExchangeResultFail {
  ok: false;
  status: number;
  reason: 'network' | 'bad-response' | 'no-key';
}
```

### Failure Reasons

| Reason | Meaning | Retryable |
|--------|---------|-----------|
| `'network'` | Fetch failed (no internet, CORS, timeout) | Yes |
| `'bad-response'` | Response wasn't OK or couldn't parse JSON | Yes |
| `'no-key'` | Response OK but no `key` or `access_token` | No |

---

## Parameters

```ts
interface ExchangeParams {
  code: string;                    // Authorization code from OpenRouter
  verifier: string;                // Original PKCE code verifier
  codeMethod: string;              // 'S256' or 'plain'
  fetchImpl?: typeof fetch;         // Optional custom fetch implementation
  attempt?: number;                // Retry count for error logging
}
```

---

## How it works (under the hood)

Here's what happens:

1. **POST request**: Sends code + verifier to `https://openrouter.ai/api/v1/auth/keys`
2. **Request body**:
   ```json
   {
     "code": "<auth_code>",
     "code_verifier": "<code_verifier>",
     "code_challenge_method": "<method>"
   }
   ```
3. **Fetch**: Uses provided fetch or global `fetch`
4. **Parse response**: JSON decode the response
5. **Check key**: Look for `json.key` or `json.access_token`
6. **Return**: Success with key, or failure with reason
7. **Error logging**: Reports to error system with tags and context

---

## Error Handling

All errors are caught and reported:

- **Network errors**: `reportError` with `'network'` tag and `attempt`
- **Bad responses**: `reportError` with HTTP status
- **Missing key**: `reportError` with response key count

Errors include context tags:
- `domain: 'auth'`
- `stage: 'exchange'`
- `status: <http_status>`
- `attempt: <retry_number>`

---

## Common patterns

### In callback page

```ts
// pages/openrouter-callback.vue
const { $router, $route } = useNuxtApp();

onMounted(async () => {
  const code = $route.query.code as string;
  const verifier = sessionStorage.getItem('openrouter_code_verifier');
  const method = sessionStorage.getItem('openrouter_code_method');

  const result = await exchangeOpenRouterCode({
    code,
    verifier: verifier || '',
    codeMethod: method || 'plain'
  });

  if (result.ok) {
    // Dispatch event
    window.dispatchEvent(new CustomEvent('openrouter:connected'));
    // Redirect to home
    $router.push('/');
  } else {
    console.error('Auth failed:', result.reason);
  }
});
```

### With retry logic

```ts
async function exchangeWithRetry(params: ExchangeParams) {
  const maxAttempts = 3;
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    const result = await exchangeOpenRouterCode({
      ...params,
      attempt
    });
    
    if (result.ok) return result;
    
    if (result.reason === 'network' && attempt < maxAttempts) {
      await new Promise(r => setTimeout(r, 1000 * attempt));
    } else {
      return result;
    }
  }
}
```

---

## Important notes

### PKCE verification

OpenRouter verifies:
1. Hash of verifier matches code challenge
2. Code is not expired
3. Code was issued to your callback URL

If verification fails, response is 400/401 with error message.

### Key format

Keys start with `sk_` or similar prefix. Always treat as sensitive:
- Never log the full key
- Store only in secure storage (KV table)
- Use in Authorization headers only

### Network timeout

No explicit timeout on request, but browsers typically timeout after 30-60 seconds.

For sensitive operations, wrap in your own timeout:

```ts
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 10000);

try {
  const result = await exchangeOpenRouterCode({
    code,
    verifier,
    codeMethod: 'S256',
    // Note: exchangeOpenRouterCode doesn't accept signal yet
  });
} finally {
  clearTimeout(timeoutId);
}
```

### Session cleanup

After exchange (success or failure), clear session storage:

```ts
sessionStorage.removeItem('openrouter_code_verifier');
sessionStorage.removeItem('openrouter_code_method');
sessionStorage.removeItem('openrouter_state');
```

---

## Related

- `useOpenRouterAuth` — initiates the login flow
- `useUserApiKey` — stores the key after exchange
- `openrouter-callback.vue` — calls this on redirect
- `~/core/auth/useOpenrouter.ts` — PKCE setup

---

## TypeScript

```ts
export type ExchangeResult = ExchangeResultSuccess | ExchangeResultFail;

interface ExchangeResultSuccess {
  ok: true;
  userKey: string;
  status: number;
}

interface ExchangeResultFail {
  ok: false;
  status: number;
  reason: 'network' | 'bad-response' | 'no-key';
}

interface ExchangeParams {
  code: string;
  verifier: string;
  codeMethod: string;
  fetchImpl?: typeof fetch;
  attempt?: number;
}

export async function exchangeOpenRouterCode(
  p: ExchangeParams
): Promise<ExchangeResult>;
```

---

Document generated from `app/core/auth/openrouter-auth.ts` implementation.
</file>

<file path="auth/openrouter-build.md">
# buildOpenRouterMessages

Utility for building OpenAI-compatible message arrays with hydrated images and files. Converts internal message format to OpenRouter API format with support for image deduplication, limits, and historical image inclusion policies.

Think of `buildOpenRouterMessages` as your message translator — it takes your chat messages and converts them into the exact format OpenRouter expects, handling all the tricky image and file stuff.

---

## What does it do?

`buildOpenRouterMessages` prepares messages for the OpenRouter API by:

- Converting internal format to OpenAI-compatible content arrays
- Hydrating file hashes into data URLs
- Deduplicating and limiting images
- Applying inclusion policies (all vs recent vs role-based)
- Handling PDFs, images, and other files

---

## Basic Example

```ts
import { buildOpenRouterMessages } from '~/core/auth/openrouter-build';

const messages = [
  { role: 'user', content: 'Analyze this image', file_hashes: 'hash123' },
  { role: 'assistant', content: 'I see...' }
];

const orMessages = await buildOpenRouterMessages(messages, {
  maxImageInputs: 8,
  dedupeImages: true
});

// Send to OpenRouter API
const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
  method: 'POST',
  body: JSON.stringify({ messages: orMessages })
});
```

---

## How to use it

### 1. Prepare your messages

```ts
interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string | any[];  // string or parts array
  file_hashes?: string;     // space-separated hashes
}

const messages: ChatMessage[] = [
  { role: 'system', content: 'You are helpful' },
  { role: 'user', content: 'Hi', file_hashes: 'hash1 hash2' },
  { role: 'assistant', content: 'Hello!' }
];
```

### 2. Build with options

```ts
const orMessages = await buildOpenRouterMessages(messages, {
  maxImageInputs: 8,           // Total images across history
  dedupeImages: true,          // Skip duplicate hashes
  imageInclusionPolicy: 'all', // 'all' | 'recent' | 'recent-user' | 'recent-assistant'
  recentWindow: 12,            // Last N messages when using recent policy
  debug: false
});
```

### 3. Result format

```ts
interface ORMessage {
  role: 'user' | 'assistant' | 'system';
  content: ORContentPart[];
}

interface ORContentPart {
  type: 'text' | 'image_url' | 'file';
  text?: string;
  image_url?: { url: string };
  file?: { filename: string; file_data: string };
}
```

---

## Image Inclusion Policies

### 'all' (default)

Include images from all messages, up to `maxImageInputs`.

```ts
// Message 1: [img1]
// Message 2: [img2]
// Message 3: [img3]
// Result: [img1, img2, img3] (or limited to maxImageInputs)
```

### 'recent'

Only include images from the last `recentWindow` messages.

```ts
await buildOpenRouterMessages(messages, {
  imageInclusionPolicy: 'recent',
  recentWindow: 12  // Last 12 messages
});
```

### 'recent-user'

Only images from recent user messages.

```ts
await buildOpenRouterMessages(messages, {
  imageInclusionPolicy: 'recent-user',
  recentWindow: 5  // Last 5 user messages
});
```

### 'recent-assistant'

Only images from recent assistant messages.

```ts
await buildOpenRouterMessages(messages, {
  imageInclusionPolicy: 'recent-assistant',
  recentWindow: 3
});
```

---

## What you get back

```ts
interface ORMessage {
  role: 'user' | 'assistant' | 'system';
  content: ORContentPart[];
}

// ORContentPart can be:

interface ORContentPartText {
  type: 'text';
  text: string;
}

interface ORContentPartImageUrl {
  type: 'image_url';
  image_url: { url: string };
}

interface ORContentPartFile {
  type: 'file';
  file: { filename: string; file_data: string };
}
```

---

## How it works (under the hood)

Here's the flow:

1. **Parse policies**: Determine which messages to inspect for images
2. **Collect candidates**: Find all image/file hashes in candidate messages
3. **External filter**: Optional hook to filter/veto specific images
4. **Dedupe & limit**: Remove duplicates, enforce max count
5. **Group by message**: Organize images back to their original messages
6. **Build content parts**: 
   - Extract text content
   - Hydrate files to data URLs
   - Hydrate hashes to base64 data URLs
   - Add files/images to content array
7. **Return**: OpenRouter-compatible message array

---

## File Hydration

Files are converted to data URLs for API transmission:

### Local hash → data URL

```ts
// Hash from Dexie
hash = 'abc123def456'
→ getFileBlob(hash)
→ blobToDataUrl(blob)
→ 'data:image/png;base64,...'
```

### Remote URL → data URL

```ts
url = 'https://example.com/image.png'
→ fetch(url)
→ blob
→ blobToDataUrl(blob)
→ 'data:image/png;base64,...'
```

### Blob URL → (not sent)

Blob URLs (`blob:`) can't be accessed server-side, so they're skipped.

---

## Caching

Images are cached in memory to avoid repeated conversions:

```ts
// Global caches (persistent in window)
window.__or3ImageDataUrlCache    // Maps ref → data URL
window.__or3ImageHydrateInflight // In-flight promises
```

**Benefits:**
- Fast repeated builds
- No duplicate network requests
- Automatic deduplication

**Lifetime:**
- Cleared on page reload
- Persists across multiple API calls

---

## Common patterns

### Limit to recent images only

```ts
const orMessages = await buildOpenRouterMessages(messages, {
  imageInclusionPolicy: 'recent',
  recentWindow: 5,
  maxImageInputs: 3
});
```

### Vision-only mode (user images only)

```ts
const orMessages = await buildOpenRouterMessages(messages, {
  imageInclusionPolicy: 'recent-user',
  recentWindow: 10,
  maxImageInputs: 5
});
```

### No images (text only)

```ts
const orMessages = await buildOpenRouterMessages(messages, {
  maxImageInputs: 0  // Disables all images
});
```

### Custom filter

```ts
const orMessages = await buildOpenRouterMessages(messages, {
  filterIncludeImages: async (candidates) => {
    // Only include images from user messages
    return candidates.filter(c => c.role === 'user');
  }
});
```

### Debug output

```ts
const orMessages = await buildOpenRouterMessages(messages, {
  debug: true
});
// Logs candidate count, selected count, hydration status
```

---

## Important notes

### Memory limits

- Max 5MB per file (enforced during hydration)
- Large images truncated silently
- Base64 encoding increases size ~33%

### Image types supported

- **Input**: PNG, JPG, GIF, WebP, AVIF
- **Detection**: Via MIME type or file extension
- **Inline formats**: data URLs, https URLs, local hashes, blob URLs

### PDF handling

PDFs are sent as files, not images:

```ts
content: [
  { type: 'text', text: 'Analyze this' },
  { type: 'file', file: { filename: 'doc.pdf', file_data: 'data:application/pdf;base64,...' } }
]
```

### Dedupe strategy

Hashes are compared for exact matches. If same image appears twice:
- First occurrence kept
- Second and later deduplicated (removed)

### Errors on hydration

If any hydration fails:
- Image is skipped silently
- Debug logging shows why
- Rest of message unaffected

---

## Decide modalities

Helper to determine if response should include images:

```ts
import { decideModalities } from '~/core/auth/openrouter-build';

const modalities = decideModalities(orMessages, 'gpt-4-vision');
// Returns: ['text'] or ['text', 'image']
```

Checks:
- If any input images exist
- If prompt mentions "generate/create image"
- Requested model capability

---

## Related

- `useChat` — uses this to build API requests
- `modelsService` — check model capabilities
- `~/db/files` — file storage and retrieval
- OpenRouter API docs — message format reference

---

## TypeScript

```ts
export interface BuildImageCandidate {
  hash: string;
  role: 'user' | 'assistant';
  messageIndex: number;
}

export interface BuildOptions {
  maxImageInputs?: number;
  dedupeImages?: boolean;
  imageInclusionPolicy?: 'all' | 'recent' | 'recent-user' | 'recent-assistant';
  recentWindow?: number;
  filterIncludeImages?: (candidates: BuildImageCandidate[]) => Promise<BuildImageCandidate[]> | BuildImageCandidate[];
  debug?: boolean;
}

export async function buildOpenRouterMessages(
  messages: ChatMessageLike[],
  opts?: BuildOptions
): Promise<ORMessage[]>;

export function decideModalities(
  orMessages: ORMessage[],
  requestedModel?: string
): string[];
```

---

Document generated from `app/core/auth/openrouter-build.ts` implementation.
</file>

<file path="auth/useOpenrouter.md">
# useOpenRouterAuth

Authentication composable for OpenRouter PKCE login flow. Manages the OAuth-like authentication process with OpenRouter, including code verification, session storage, and API key management.

Think of `useOpenRouterAuth` as your authentication gateway to OpenRouter — it handles the secure PKCE flow, manages the redirect dance, and stores your API key safely.

---

## What does it do?

`useOpenRouterAuth` provides the authentication machinery for OR3. When you want to:

- Start the OpenRouter login flow
- Handle PKCE code challenge/verifier generation
- Redirect to OpenRouter with proper security parameters
- Logout and clear authentication

...this composable manages all of that for you.

---

## Basic Example

```vue
<script setup>
import { useOpenRouterAuth } from '~/core/auth/useOpenrouter';

const { startLogin, logoutOpenRouter, isLoggingIn } = useOpenRouterAuth();

async function handleLogin() {
  await startLogin();
}

async function handleLogout() {
  await logoutOpenRouter();
}
</script>

<template>
  <div>
    <button :disabled="isLoggingIn">
      {{ isLoggingIn ? 'Logging in...' : 'Connect OpenRouter' }}
    </button>
  </div>
</template>
```

---

## How to use it

### 1. Create an auth instance

```ts
import { useOpenRouterAuth } from '~/core/auth/useOpenrouter';
const auth = useOpenRouterAuth();
```

### 2. Start the login flow

```ts
await auth.startLogin();
// User is redirected to OpenRouter
```

### 3. Handle logout

```ts
await auth.logoutOpenRouter();
// Clears all auth data
```

### 4. Monitor login state

```ts
if (auth.isLoggingIn.value) {
  console.log('Login in progress...');
}
```

---

## What you get back

When you call `useOpenRouterAuth()`, you get:

| Property | Type | Description |
|----------|------|-------------|
| `startLogin` | `function` | Begin PKCE OAuth flow |
| `logoutOpenRouter` | `function` | Clear auth and logout |
| `isLoggingIn` | `Ref<boolean>` | True while redirect is happening |

---

## How it works (under the hood)

Here's what happens when you call `startLogin()`:

1. **Generate verifier**: Creates 64 random bytes encoded as hex string
2. **Create challenge**: SHA-256 hash of verifier (S256 method), or plain fallback for iOS Safari
3. **Store session data**: Code verifier, method, and state in `sessionStorage`
4. **Build auth URL**: With callback URL, code challenge, and state
5. **Redirect**: User sent to OpenRouter auth page
6. **User logs in**: Authenticates at OpenRouter
7. **Redirect back**: OpenRouter sends code to callback page

The callback page receives the code and exchanges it for an API key.

---

## PKCE Security

**What is PKCE?** Proof Key for Code Exchange — a security layer for OAuth 2.0 that prevents code interception.

**Why use it?** SPAs can't keep secrets, so PKCE verifies you're the same client by:
1. Generating random `code_verifier`
2. Hashing it to `code_challenge` (SHA-256)
3. Exchanging authorization code + original verifier
4. Server confirms hash matches

**S256 vs Plain:** S256 is secure. Plain is fallback for iOS Safari on HTTP.

---

## Configuration

Set via Nuxt runtime config:

```ts
export default defineNuxtConfig({
  runtimeConfig: {
    public: {
      openRouterAuthUrl: 'https://openrouter.ai/auth',
      openRouterRedirectUri: 'https://yourdomain.com/openrouter-callback',
      openRouterClientId: 'your-app-id'
    }
  }
})
```

---

## Common patterns

### Check if connected

```ts
const { apiKey } = useUserApiKey();
if (apiKey.value) {
  console.log('Already connected');
}
```

### Logout with confirmation

```ts
async function confirmLogout() {
  if (confirm('Disconnect?')) {
    await auth.logoutOpenRouter();
  }
}
```

### Listen for auth changes

```ts
window.addEventListener('openrouter:connected', () => {
  console.log('Auth state changed');
});
```

---

## Important notes

### Session storage only

- Code verifier stored in `sessionStorage` (cleared on tab close)
- Never persisted to `localStorage`
- Not accessible from other tabs

### HTTPS requirement

PKCE S256 requires HTTPS (or localhost for dev). Falls back to plain method on iOS Safari for HTTP.

### Logout behavior

`logoutOpenRouter()`:
1. Removes `openrouter_api_key` from localStorage
2. Clears KV database entry
3. Dispatches `openrouter:connected` event

---

## Related

- `useUserApiKey` — access stored API key
- `exchangeOpenRouterCode` — swap auth code for API key
- `openrouter-callback.vue` — handles redirect
- `useChat` — uses API key for messages

---

## TypeScript

```ts
function useOpenRouterAuth(): {
  startLogin: () => Promise<void>;
  logoutOpenRouter: () => Promise<void>;
  isLoggingIn: Ref<boolean>;
}
```

---

Document generated from `app/core/auth/useOpenrouter.ts` implementation.
</file>

<file path="auth/useUserApiKey.md">
# useUserApiKey

Composable for managing the OpenRouter API key in shared application state. Provides reactive access to the stored API key with sync between global state and Dexie database.

Think of `useUserApiKey` as your API key vault — it securely stores and retrieves your OpenRouter credentials while keeping everything in sync.

---

## What does it do?

`useUserApiKey` manages API key storage and retrieval. When you want to:

- Check if an API key is stored
- Get the current API key as a reactive ref
- Update the API key in state
- Clear the API key

...this composable handles all of that for you.

---

## Basic Example

```vue
<script setup>
import { useUserApiKey } from '~/core/auth/useUserApiKey';

const { apiKey, setKey, clearKey } = useUserApiKey();

function storeKey(newKey: string) {
  setKey(newKey);
}

function removeKey() {
  clearKey();
}
</script>

<template>
  <div>
    <!-- Check if connected -->
    <div v-if="apiKey.value">
      ✓ API Key stored ({{ apiKey.value.substring(0, 5) }}...)
      <button @click="removeKey">Clear</button>
    </div>
    
    <!-- Disconnected state -->
    <div v-else>
      No API key. Connect to OpenRouter first.
    </div>
  </div>
</template>
```

---

## How to use it

### 1. Create a key manager instance

```ts
import { useUserApiKey } from '~/core/auth/useUserApiKey';
const { apiKey, setKey, clearKey } = useUserApiKey();
```

### 2. Read the API key

```ts
// Reactive ref - updates when key changes
if (apiKey.value) {
  console.log('Key exists:', apiKey.value.length, 'characters');
}

// Watch for changes
watch(apiKey, (newKey) => {
  if (newKey) console.log('Key updated');
  else console.log('Key cleared');
});
```

### 3. Set a new key

```ts
const newKey = 'sk_...';
setKey(newKey);

// Key is immediately available
console.log(apiKey.value); // 'sk_...'
```

### 4. Clear the key

```ts
clearKey();

// Key is now null
console.log(apiKey.value); // null
```

---

## What you get back

When you call `useUserApiKey()`, you get:

| Property | Type | Description |
|----------|------|-------------|
| `apiKey` | `Ref<string \| null>` | Current API key or null |
| `setKey` | `(key: string) => void` | Store a new key |
| `clearKey` | `() => void` | Clear the key |

---

## How it works (under the hood)

Here's the flow:

1. **Initialization**: On client mount, fetches key from Dexie `kv` table
2. **Async load**: Key loads asynchronously without blocking composable
3. **State sync**: Key stored in shared `state.value.openrouterKey`
4. **Reactive ref**: Computed ref wraps state for reactivity
5. **Updates**: `setKey/clearKey` immediately update state
6. **Persistence**: Typically called from auth flow (`exchangeOpenRouterCode`)

The key is stored in Dexie's KV table with name `'openrouter_api_key'`.

---

## Common patterns

### Guard against missing key

```ts
function useChatIfReady() {
  const { apiKey } = useUserApiKey();
  
  return {
    canChat: computed(() => !!apiKey.value),
    requiresAuth: computed(() => !apiKey.value)
  };
}
```

### Sync with auth state

```ts
const { apiKey } = useUserApiKey();
const { startLogin } = useOpenRouterAuth();

async function ensureAuth() {
  if (!apiKey.value) {
    await startLogin();
  }
}
```

### Mask key for display

```ts
const { apiKey } = useUserApiKey();

const maskedKey = computed(() => {
  if (!apiKey.value) return '';
  return apiKey.value.substring(0, 5) + '...' + apiKey.value.substring(-5);
});
```

### Auto-clear on error

```ts
const { apiKey, clearKey } = useUserApiKey();

async function validateKey() {
  try {
    const resp = await fetch('https://openrouter.ai/api/v1/models', {
      headers: { 'Authorization': `Bearer ${apiKey.value}` }
    });
    if (resp.status === 401) {
      clearKey(); // Unauthorized - clear it
    }
  } catch {}
}
```

---

## Important notes

### Client-only

- `useUserApiKey` only works on client (checks `import.meta.client`)
- Server-side calls return null
- Composable is safe to call from SSR components (no error)

### Async initialization

Key loads asynchronously from Dexie:
- Composable returns immediately with `apiKey.value` possibly null
- Key updates reactively when database fetch completes
- No `await` needed — just watch `apiKey` ref

### Security

- Key is never logged
- Key stored in Dexie (IndexedDB) — per-domain storage
- Key in state is memory-only (cleared on tab close if not persisted)
- Logout clears it from both localStorage and KV table

### State vs Storage

- **`state.value.openrouterKey`**: In-memory, fast access, cleared on refresh
- **Dexie KV table**: Persistent, cross-component, slower to read
- **Sync**: `useUserApiKey` loads from KV on mount

---

## Related

- `useOpenRouterAuth` — get a key via PKCE login
- `exchangeOpenRouterCode` — calls `setKey` after successful auth
- `useChat` — uses key for API requests
- `~/db/kv` — underlying KV storage

---

## TypeScript

```ts
function useUserApiKey(): {
  apiKey: Ref<string | null>;
  setKey: (key: string) => void;
  clearKey: () => void;
}
```

---

Document generated from `app/core/auth/useUserApiKey.ts` implementation.
</file>

<file path="composables/useActivePrompt.md">
# useActivePrompt

Reactive composable that manages the currently selected system prompt for chat conversations.

This composable provides a module-singleton selection state (id + content) so multiple components
and composables can read the active system prompt consistently without creating duplicate refs.

It integrates with the local prompt database (`~/db/prompts`) to load prompt content and emits a
hook event after a prompt is selected so other subsystems can react.

---

## Features

-   Shared, readonly reactive `activePromptId` and `activePromptContent` that are visible across
    all consumers in the same Vite/SSR process (module-singleton pattern).
-   `setActivePrompt(id)` loads the prompt from the DB and updates the shared state.
-   Calls the hooks engine: `chat.systemPrompt.select:action:after` with the selected id/content.
-   `clearActivePrompt()` resets the selection to `null`.

---

## Installation

No installation required — the composable is part of the app and can be imported directly:

```ts
import { useActivePrompt } from '~/composables/chat/useActivePrompt';
```

---

## Usage

Basic usage in a component:

```vue
<script setup lang="ts">
import { watch } from 'vue';
import { useActivePrompt } from '~/composables/chat/useActivePrompt';

const {
    activePromptId,
    activePromptContent,
    setActivePrompt,
    clearActivePrompt,
} = useActivePrompt();

// react to changes
watch(activePromptId, (id) => {
    console.log('Active prompt id changed:', id);
});

// select a prompt by id (async)
async function select(id: string) {
    await setActivePrompt(id);
}

// clear selection
function clear() {
    clearActivePrompt();
}
</script>
```

### Example: use in a send-flow

When sending a message you can include the active system prompt like this:

```ts
const { getActivePromptContent } = useActivePrompt();
const systemPrompt = getActivePromptContent();
// attach systemPrompt to the outgoing message payload if present
```

Note: `getActivePromptContent()` returns the raw content value (or `null`) and is synchronous.

---

## API

-   activePromptId: Readonly<Ref<string | null>> — readonly reactive id of the selected prompt.
-   activePromptContent: Readonly<Ref<any | null>> — readonly reactive prompt content loaded from DB.
-   setActivePrompt(id: string | null): Promise<void> — set selection. Passing `null` clears. If the
    id is not found the selection will be cleared.
-   clearActivePrompt(): void — convenience that clears the selection (calls `setActivePrompt(null)`).
-   getActivePromptContent(): any | null — synchronous getter returning the raw content value.

---

## Types

The composable exposes the following TypeScript shape (approx):

```ts
export interface ActivePromptState {
    activePromptId: string | null;
    activePromptContent: any | null;
}

function useActivePrompt(): {
    activePromptId: Readonly<Ref<string | null>>;
    activePromptContent: Readonly<Ref<any | null>>;
    setActivePrompt(id: string | null): Promise<void>;
    clearActivePrompt(): void;
    getActivePromptContent(): any | null;
};
```

---

## Internals & Notes

-   Module-singleton: the composable uses module-scoped `ref`s so every import/consumer shares the
    same state. This is intentional to keep selection consistent across UI components.
-   `setActivePrompt` is asynchronous and will call `getPrompt(id)` from `~/db/prompts`.
-   After a successful selection the composable dispatches a hook action using the app hooks
    engine: `hooks.doAction('chat.systemPrompt.select:action:after', { id, content })`.
-   If the requested prompt id does not exist the composable clears the active selection.
-   Concurrency: callers should await `setActivePrompt` if they depend on the state being updated
    immediately; multiple concurrent calls may race and the last-resolved call wins.
-   Do not mutate `activePromptContent` or `activePromptId` directly — use the provided methods.

### SSR / Client considerations

-   The composable relies on the DB helper `getPrompt` which is typically a client-side data source
    (Dexie/IndexedDB). Avoid calling `setActivePrompt` during server-side rendering. Reading the
    readonly refs is safe but may initially be `null` on the server.

---

## Related

-   `~/db/prompts` — prompt storage and retrieval used by `setActivePrompt`
-   hooks engine — event emitted: `chat.systemPrompt.select:action:after`

---

## Example (full)

```vue
<template>
    <div>
        <div v-if="activePromptContent">Active: {{ activePromptId }}</div>
        <button @click="select('builtin:short_instruct')">
            Select built-in
        </button>
        <button @click="clear">Clear</button>
    </div>
</template>

<script setup lang="ts">
import { useActivePrompt } from '~/composables/chat/useActivePrompt';

const {
    activePromptId,
    activePromptContent,
    setActivePrompt,
    clearActivePrompt,
} = useActivePrompt();

function select(id: string) {
    setActivePrompt(id);
}
function clear() {
    clearActivePrompt();
}

// exported to template
const activePrompt = { activePromptId, activePromptContent, select, clear };
</script>
```

---

Document generated from `app/composables/chat/useActivePrompt.ts` implementation.
</file>

<file path="composables/useAiSettings.md">
# useAiSettings

Persistence layer for AI preference knobs. Keeps the chat experience consistent by storing master prompts and model defaults in browser storage, while exposing a clean interface for UI controls or automated scripts.

---

## What it covers

`useAiSettings` gives you a reactive settings object and helper methods to read, update, and reset AI chat preferences. It sanitises input, survives hot-module reloads, and only touches storage in the browser.

-   Tracks the current settings in a single global store (HMR-safe)
-   Loads initial values from `localStorage` once per session
-   Persists updates automatically
-   Normalises user input to avoid bad types or unknown keys

---

## Quick start

```ts
import { useAiSettings } from '~/composables/chat/useAiSettings';

const { settings, set } = useAiSettings();

watchEffect(() => {
    console.log('Current default mode:', settings.value.defaultModelMode);
});

set({ defaultModelMode: 'fixed', fixedModelId: 'anthropic/claude-3-sonnet' });
```

---

## API

| Property     | Type                                     | Purpose                                                                      |
| ------------ | ---------------------------------------- | ---------------------------------------------------------------------------- |
| `settings`   | `ComputedRef<AiSettingsV1>`              | Reactive snapshot of the current settings.                                   |
| `set(patch)` | `(patch: Partial<AiSettingsV1>) => void` | Merge in new values, sanitise them, persist to storage.                      |
| `reset()`    | `() => void`                             | Restore defaults and persist them.                                           |
| `load()`     | `() => AiSettingsV1`                     | Re-read from storage, update the reactive store, and return the fresh value. |

### `AiSettingsV1`

```ts
interface AiSettingsV1 {
    version: 1;
    masterSystemPrompt: string;
    defaultModelMode: 'lastSelected' | 'fixed';
    fixedModelId: string | null;
}
```

Defaults:

```ts
const DEFAULT_AI_SETTINGS: AiSettingsV1 = {
    version: 1,
    masterSystemPrompt: '',
    defaultModelMode: 'lastSelected',
    fixedModelId: null,
};
```

---

## How to use it

### Drive a settings form

```vue
<template>
    <form class="space-y-4" @submit.prevent="save">
        <label class="block">
            <span>Master system prompt</span>
            <textarea v-model="prompt" class="retro-input" rows="3" />
        </label>

        <label class="block">
            <span>Default model mode</span>
            <select v-model="mode" class="retro-input">
                <option value="lastSelected">Remember last model</option>
                <option value="fixed">Always use a specific model</option>
            </select>
        </label>

        <label v-if="mode === 'fixed'" class="block">
            <span>Model ID</span>
            <input v-model="modelId" class="retro-input" />
        </label>

        <button type="submit" class="retro-btn">Save</button>
    </form>
</template>

<script setup lang="ts">
import { computed, ref, watch } from 'vue';
import { useAiSettings } from '~/composables/chat/useAiSettings';

const { settings, set } = useAiSettings();

const prompt = ref(settings.value.masterSystemPrompt);
const mode = ref(settings.value.defaultModelMode);
const modelId = ref(settings.value.fixedModelId ?? '');

watch(settings, (next) => {
    prompt.value = next.masterSystemPrompt;
    mode.value = next.defaultModelMode;
    modelId.value = next.fixedModelId ?? '';
});

function save() {
    set({
        masterSystemPrompt: prompt.value,
        defaultModelMode: mode.value,
        fixedModelId: mode.value === 'fixed' ? modelId.value || null : null,
    });
}
</script>
```

### Reset to defaults

```ts
const { reset } = useAiSettings();

reset();
```

### Hard refresh from storage

```ts
const { load } = useAiSettings();

const latest = load();
console.log('Reloaded settings', latest);
```

---

## Internal mechanics

1. **Singleton store**: A global object placed on `globalThis` survives HMR and ensures only one reactive store. The store holds `{ settings: Ref<AiSettingsV1>, loaded: boolean }`.
2. **Lazy hydration**: On first call in the browser, `loadFromStorage()` runs. Server contexts keep defaults because `window`/`document` are missing.
3. **Sanitisation**: `sanitizeAiSettings()` strips unknown keys, forces `defaultModelMode` to the allowed union, and normalises `fixedModelId`.
4. **Persistence**: `set` immediately writes to storage. A deep `watch` also saves direct mutations made outside of `set` for compatibility.
5. **Safety**: All storage access is wrapped in try/catch with console warnings in dev mode to avoid breaking the app when storage is unavailable.

---

## Edge cases & tips

-   **SSR**: Guarded by `isBrowser()` so storage isn’t touched during server rendering.
-   **Storage quota**: Failures fall back to logging a warning; settings stay in memory for the session.
-   **HMR**: Because the store lives on `globalThis`, you can tweak the composable without losing user-configured settings while the dev server is running.
-   **Direct mutations**: Prefer `set`, but the deep watch ensures manual changes like `settings.value.masterSystemPrompt = '...'` still persist.

---

## Related references

-   `useChat` — respects the defaults defined here.
-   `useAiSettingsPanel` (if present) — typical consumer for user-facing UI.
-   `AI_SETTINGS_STORAGE_KEY` — storage key constant if you need to inspect it manually.
</file>

<file path="composables/useChat.md">
# useChat

The main composable for managing AI chat conversations in OR3. Handles sending messages, streaming responses, retrying failed messages, and managing conversation state.

Think of `useChat` as your chat conversation manager — it keeps track of all messages, talks to the AI, and handles everything from loading states to error recovery.

---

## What does it do?

`useChat` is the heart of every chat conversation. When you want to:

- Send a message to an AI model
- Display a conversation with streaming responses
- Retry a failed message
- Show loading states while the AI is thinking
- Cancel an ongoing AI response

...this composable handles all of that for you.

---

## Basic Example

Here's the simplest way to use it:

```vue
<script setup>
import { useChat } from '~/composables/chat/useAi';

// Create a new chat
const chat = useChat();

// Send a message
async function ask() {
  await chat.sendMessage('Hello, how are you?');
}
</script>

<template>
  <div>
    <!-- Show all messages -->
    <div v-for="msg in chat.messages.value" :key="msg.id">
      <strong>{{ msg.role }}:</strong> {{ msg.text }}
    </div>

    <!-- Show loading state -->
    <div v-if="chat.loading.value">AI is thinking...</div>

    <!-- Send button -->
    <button @click="ask" :disabled="chat.loading.value">
      Send Message
    </button>
  </div>
</template>
```

---

## How to use it

### 1. Create a chat instance

```ts
// Start a new conversation
const chat = useChat();

// Or continue an existing thread
const chat = useChat(existingMessages, 'thread-id-123');

// Or with a pending system prompt
const chat = useChat([], undefined, 'prompt-id-456');
```

### 2. Send messages

```ts
// Simple text message
await chat.sendMessage('What is the weather like?');

// Message with images/files
await chat.sendMessage('Describe this image', {
  files: [{ type: 'image/png', url: 'https://...' }],
  model: 'openai/gpt-4-vision',
  online: false
});

// Message with file attachments (by hash)
await chat.sendMessage('Analyze these files', {
  file_hashes: ['abc123', 'def456'],
  model: 'anthropic/claude-3-sonnet'
});
```

### 3. Handle the response

The AI response appears in two places:

- **During streaming**: `chat.tailAssistant.value` shows the message being written
- **After complete**: The message moves to `chat.messages.value`

```vue
<template>
  <!-- Show completed messages -->
  <div v-for="msg in chat.messages.value" :key="msg.id">
    {{ msg.text }}
  </div>

  <!-- Show streaming message (being written right now) -->
  <div v-if="chat.tailAssistant.value" class="streaming">
    {{ chat.tailAssistant.value.text }}
    <span v-if="chat.tailAssistant.value.pending">▋</span>
  </div>
</template>
```

### 4. Retry failed messages

If a message fails, you can retry it:

```ts
// Retry with the same model
await chat.retryMessage(failedMessageId);

// Retry with a different model
await chat.retryMessage(failedMessageId, 'anthropic/claude-3-opus');
```

### 5. Cancel ongoing responses

```ts
// Stop the AI mid-response
chat.abort();
```

### 6. Clear everything

```ts
// Remove all messages and reset state
chat.clear();
```

---

## What you get back

When you call `useChat()`, you get an object with:

| Property | Type | Description |
|----------|------|-------------|
| `messages` | `Ref<UiChatMessage[]>` | All finalized messages in the conversation |
| `loading` | `Ref<boolean>` | `true` while waiting for AI response |
| `threadId` | `Ref<string \| undefined>` | The database thread ID for this conversation |
| `streamId` | `Ref<string \| undefined>` | Current streaming message ID |
| `streamState` | `object` | Stream status: `{ active, finalized, error, aborted }` |
| `tailAssistant` | `Ref<UiChatMessage \| null>` | The AI message currently being streamed (not in `messages` yet) |
| `sendMessage` | `function` | Send a new user message |
| `retryMessage` | `function` | Retry a failed message |
| `abort` | `function` | Cancel the current AI response |
| `clear` | `function` | Clear all messages |
| `resetStream` | `function` | Reset stream state (usually automatic) |
| `flushTailAssistant` | `function` | Move `tailAssistant` into `messages` (usually automatic) |

---

## Message format

### UiChatMessage

This is what you see in `messages.value` and `tailAssistant.value`:

```ts
interface UiChatMessage {
  id: string;                    // unique message ID
  role: 'user' | 'assistant' | 'system';
  text: string;                  // the actual message text
  file_hashes?: string[];        // attached file references
  reasoning_text?: string;       // AI's reasoning (if model supports it)
  stream_id?: string;            // for tracking streaming messages
  pending?: boolean;             // true while streaming
}
```

### SendMessageParams

Optional parameters when sending a message:

```ts
interface SendMessageParams {
  files?: { type: string; url: string }[];  // images or files to attach
  model?: string;                           // AI model to use (e.g., 'openai/gpt-4')
  file_hashes?: string[];                   // reference existing files by hash
  extraTextParts?: string[];                // additional text segments
  online: boolean;                          // enable web search (adds ':online' suffix)
}
```

---

## How it works (under the hood)

Here's what happens when you send a message:

1. **Check API key**: Won't send without OpenRouter API key
2. **Apply filters**: Runs `ui.chat.message:filter:outgoing` hook (can block message)
3. **Create thread**: If this is the first message, creates a new thread in the database
4. **Load system prompt**: Fetches the active system prompt for context
5. **Add user message**: Saves your message to the database and updates `messages.value`
6. **Prepare AI request**: 
   - Builds conversation history
   - Removes empty assistant messages (API requirement)
   - Converts to OpenRouter format
   - Applies image limit (5 images max to avoid rate limits)
7. **Start streaming**: Opens a stream to OpenRouter API
8. **Process chunks**: As AI responds:
   - Text chunks update `tailAssistant.value.text`
   - Generated images get saved and attached
   - Reasoning text (if supported) goes into `reasoning_text`
   - Progress saved to DB every 500ms
9. **Apply incoming filter**: Runs `ui.chat.message:filter:incoming` hook
10. **Finalize**: Saves complete message to DB and emits completion hooks

If anything fails, the error is caught and you can retry.

---

## Common patterns

### Check if chat is ready

```ts
if (chat.loading.value) {
  console.log('Please wait, AI is responding...');
}
```

### Show streaming indicator

```vue
<div v-if="chat.tailAssistant.value?.pending">
  AI is typing<span class="dots">...</span>
</div>
```

### Handle retry button

```vue
<button 
  v-if="message.error" 
  @click="chat.retryMessage(message.id)"
>
  Retry
</button>
```

### Cancel long responses

```vue
<button 
  v-if="chat.loading.value" 
  @click="chat.abort"
  class="danger"
>
  Stop Generating
</button>
```

### Multi-model support

```ts
// Let user pick model
const selectedModel = ref('anthropic/claude-3-sonnet');

await chat.sendMessage(userInput, {
  model: selectedModel.value,
  online: false
});
```

### Attach images

```ts
// From file input
const fileUrl = URL.createObjectURL(file);
await chat.sendMessage('What is this?', {
  files: [{ type: file.type, url: fileUrl }],
  model: 'openai/gpt-4-vision'
});
```

---

## Important notes

### Memory management

- `messages.value` contains finalized messages only
- `tailAssistant.value` holds the message currently being streamed
- When you send a new message, `tailAssistant` automatically moves to `messages`
- Call `clear()` to free memory if the conversation gets very long

### Thread creation

If you don't provide a `threadId`, the first `sendMessage` creates one automatically:
- Title: first 6 words of your message
- System prompt: uses pending prompt or default
- Timestamp: set to now

### Retry behavior

When you retry a message:
1. Finds the user message and its assistant response
2. Deletes both from database and memory
3. Re-sends with original text and attachments
4. Creates new message IDs

### Hooks integration

The composable emits several hook events you can listen to:

- `ui.chat.message:filter:outgoing` — before sending (can veto)
- `ui.chat.message:filter:incoming` — after receiving (can transform)
- `ai.chat.model:filter:select` — choose/override model
- `ai.chat.messages:filter:input` — modify conversation history
- `ai.chat.send:action:before` — before AI call
- `ai.chat.send:action:after` — after completion/abort
- `ai.chat.stream:action:complete` — stream finished
- `ai.chat.stream:action:error` — stream error
- `ai.chat.retry:action:before` — before retry
- `ai.chat.retry:action:after` — after retry
- `ui.pane.msg:action:sent` — multi-pane message sent
- `ui.pane.msg:action:received` — multi-pane message received

### Image handling

- User images: displayed in attachments gallery (not embedded in text)
- AI-generated images: embedded as markdown `![image](url)` in message text
- Image limit: Max 5 images per request (automatically trimmed)
- Previous assistant images are carried forward in conversation

### Model selection

If you don't specify a model, it uses:
1. Last selected model (from localStorage)
2. Fixed model (from settings)
3. Fallback: `openai/gpt-oss-120b`

### Online mode

Add `:online` suffix to enable web search:
```ts
await chat.sendMessage('Latest news?', {
  model: 'anthropic/claude-3-sonnet',
  online: true  // becomes 'anthropic/claude-3-sonnet:online'
});
```

---

## Troubleshooting

### "Message blocked"
Your message was filtered by an outgoing hook. Check hook extensions.

### Empty responses
Check if API key is valid and model is available.

### Stream errors
Usually network issues or invalid API responses. Retry should work.

### Memory issues with long conversations
Call `clear()` or create a new chat instance for fresh conversation.

### Images not showing
- User images: Check `file_hashes` are valid
- AI images: Must use vision-capable model

---

## Related

- `useActivePrompt` — manage system prompts
- `useUserApiKey` — OpenRouter API key management
- `useAiSettings` — model preferences and master system prompt
- `useModelStore` — available models catalog
- `~/db/messages` — direct database access
- `~/db/threads` — thread management

---

## TypeScript

Full type signature:

```ts
function useChat(
  msgs?: ChatMessage[],
  initialThreadId?: string,
  pendingPromptId?: string
): {
  messages: Ref<UiChatMessage[]>;
  loading: Ref<boolean>;
  threadId: Ref<string | undefined>;
  streamId: Ref<string | undefined>;
  streamState: {
    active: Ref<boolean>;
    finalized: Ref<boolean>;
    error: Ref<Error | null>;
    aborted: Ref<boolean>;
  };
  tailAssistant: Ref<UiChatMessage | null>;
  sendMessage: (content: string, params?: SendMessageParams) => Promise<void>;
  retryMessage: (messageId: string, modelOverride?: string) => Promise<void>;
  abort: () => void;
  clear: () => void;
  resetStream: () => void;
  flushTailAssistant: () => void;
}
```

---

## Example: Full chat component

```vue
<template>
  <div class="chat-container">
    <!-- Message list -->
    <div class="messages">
      <div 
        v-for="msg in chat.messages.value" 
        :key="msg.id"
        :class="`message message-${msg.role}`"
      >
        <div class="role">{{ msg.role }}</div>
        <div class="text">{{ msg.text }}</div>
        <button 
          v-if="msg.role === 'assistant'" 
          @click="retry(msg.id)"
          class="retry-btn"
        >
          ↻ Retry
        </button>
      </div>

      <!-- Streaming message -->
      <div 
        v-if="chat.tailAssistant.value" 
        class="message message-assistant streaming"
      >
        <div class="role">assistant</div>
        <div class="text">
          {{ chat.tailAssistant.value.text }}
          <span v-if="chat.tailAssistant.value.pending" class="cursor">▋</span>
        </div>
      </div>
    </div>

    <!-- Input area -->
    <div class="input-area">
      <textarea 
        v-model="input" 
        @keydown.enter.meta="send"
        :disabled="chat.loading.value"
        placeholder="Type your message..."
      />
      <button 
        v-if="!chat.loading.value"
        @click="send"
        :disabled="!input.trim()"
      >
        Send
      </button>
      <button 
        v-else
        @click="chat.abort()"
        class="stop-btn"
      >
        Stop
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { useChat } from '~/composables/chat/useAi';

const chat = useChat();
const input = ref('');

async function send() {
  if (!input.value.trim()) return;
  const text = input.value;
  input.value = '';
  await chat.sendMessage(text);
}

async function retry(messageId: string) {
  await chat.retryMessage(messageId);
}
</script>

<style scoped>
.chat-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

.messages {
  flex: 1;
  overflow-y: auto;
  padding: 1rem;
}

.message {
  margin-bottom: 1rem;
  padding: 0.5rem;
  border-radius: 4px;
}

.message-user {
  background: #e3f2fd;
  margin-left: 20%;
}

.message-assistant {
  background: #f5f5f5;
  margin-right: 20%;
}

.streaming .cursor {
  animation: blink 1s infinite;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

.input-area {
  display: flex;
  gap: 0.5rem;
  padding: 1rem;
  border-top: 1px solid #ddd;
}

textarea {
  flex: 1;
  padding: 0.5rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  resize: none;
  font-family: inherit;
}

button {
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 4px;
  background: #2196f3;
  color: white;
  cursor: pointer;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.stop-btn {
  background: #f44336;
}

.retry-btn {
  margin-top: 0.5rem;
  font-size: 0.875rem;
  background: #757575;
}
</style>
```

---

Document generated from `app/composables/chat/useAi.ts` implementation.
</file>

<file path="composables/useChatInputBridge.md">
# useChatInputBridge

Lightweight registry that lets external features (pane plugins, slash commands, automation) inject chat messages into an existing chat input without duplicating business logic.

---

## Why it exists

`useChatInputBridge` exposes a tiny, reactive directory of chat inputs keyed by `paneId`. Chat containers register their imperative API and the bridge forwards programmatic sends through the same UI pipeline a user click would trigger.

-   Keeps message handling inside `ChatInputDropper`
-   Avoids rehydrating chat state or bypassing hooks
-   Supports multiple panes/windows
-   Safe in dev (HMR-resilient)

---

## Surface area

| Function              | Signature                                               | Purpose                                                                                                    |
| --------------------- | ------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| `registerPaneInput`   | `(paneId: string, api: ChatInputImperativeApi) => void` | Register or update the imperative API for a pane. Called by the chat input component on mount/HMR.         |
| `unregisterPaneInput` | `(paneId: string) => void`                              | Remove the pane entry on unmount.                                                                          |
| `programmaticSend`    | `(paneId: string, text: string) => boolean`             | Push text into the pane input and trigger its native send handler. Returns `false` if the pane is missing. |
| `hasPane`             | `(paneId: string) => boolean`                           | Test whether a pane is currently registered.                                                               |

### `ChatInputImperativeApi`

```ts
interface ChatInputImperativeApi {
    setText(t: string): void;
    triggerSend(): void;
}
```

---

## Typical usage

### Registering inside a chat pane

```ts
import { onMounted, onUnmounted } from 'vue';
import {
    registerPaneInput,
    unregisterPaneInput,
} from '~/composables/chat/useChatInputBridge';

const paneId = usePaneId();

onMounted(() => {
    registerPaneInput(paneId, {
        setText: (value) => (messageInput.value = value),
        triggerSend: () => sendMessage(),
    });
});

onUnmounted(() => {
    unregisterPaneInput(paneId);
});
```

### Sending from an external plugin

```ts
import { programmaticSend } from '~/composables/chat/useChatInputBridge';

const success = programmaticSend(activePaneId, '/imagine neon city at dusk');

if (!success) {
    console.warn('Pane not ready yet');
}
```

---

## Implementation notes

1. **Registry** — Maintains a `Ref<RegisteredPaneInput[]>`. Lookup happens through the helper `find(paneId)` to keep the public API concise.
2. **Updates** — Re-registering the same pane ID replaces the stored API so HMR or re-renders don’t stack duplicates.
3. **Error handling** — `programmaticSend` wraps calls in `try/catch`; errors log in dev mode and return `false` so callers can retry or surface UI feedback.
4. **Debug hook** — In dev, the registry is exposed on `globalThis.__or3ChatInputBridge` for console inspection.
5. **No storage** — Everything lives in memory; it only coordinates runtime components.

---

## Tips & gotchas

-   Always call `unregisterPaneInput` on unmount to keep the registry clean.
-   `programmaticSend` does nothing server-side; ensure it runs in the client.
-   Avoid invoking it before the pane finishes mounting—`hasPane` lets you guard against that.
-   Keep `paneId` stable per chat instance so automations target the right recipient.

---

## Related modules

-   `ChatInputDropper.vue` — actual UI input exposing the imperative API.
-   `pane-plugin-api` — typical consumer needing programmatic sends.
-   `useChat` — eventual destination for messages triggered through the bridge.
</file>

<file path="composables/useComposerActions.md">
# useComposerActions

Composer action registry powering the quick-action buttons beneath the chat composer. Lets plugins add buttons that hook into the active editor, thread, or pane context with visibility and disabled logic.

---

## What does it do?

`useComposerActions` manages a global list of composer actions:

-   `registerComposerAction()` adds or replaces an action definition.
-   `useComposerActions(contextFn)` returns a computed list of actions + disabled state derived from the current pane.
-   `unregisterComposerAction()` cleans up during teardown/HMR.
-   `listRegisteredComposerActionIds()` helps debug what’s registered.

Actions can check editor state, streaming status, thread IDs, etc., and render with retro-friendly icons and colors.

---

## Basic Example

```ts
import {
    registerComposerAction,
    unregisterComposerAction,
    useComposerActions,
} from '~/composables/sidebar/useComposerActions';

registerComposerAction({
    id: 'custom:clear-editor',
    icon: 'i-ph-broom',
    label: 'Clear',
    color: 'warning',
    order: 180,
    handler: ({ editor }) => editor?.commands.clearContent(),
    disabled: ({ editor }) => !editor || editor.isEmpty,
});

const actions = useComposerActions(() => ({ editor: editorRef.value }));

onScopeDispose(() => unregisterComposerAction('custom:clear-editor'));
```

---

## How to use it

### 1. Register actions during setup

Call `registerComposerAction()` in a plugin or component. Namespace IDs (`your-plugin:action`) to avoid collisions. The composable freezes your payload to prevent accidental mutation.

### 2. Provide context to consumers

`useComposerActions(contextFn)` accepts a function returning the latest `ComposerActionContext` (editor ref, thread ID, streaming flag, etc.). When context values change, the computed array updates automatically.

### 3. Control visibility and disabled state

-   `visible(ctx)` hides the button when it returns `false`.
-   `disabled(ctx)` grays it out while keeping it in the layout.

Both callbacks run every render, so keep logic fast and side-effect free.

### 4. Handle clicks

`handler(ctx)` executes when the button is clicked. You can return a promise to perform async work (e.g., API calls). The UI doesn’t await by default—manage loading state externally if needed.

### 5. Clean up on unmount/HMR

Always call `unregisterComposerAction()` (or use `useHookEffect`) to avoid duplicate buttons when modules reload.

---

## What you get back

`useComposerActions(contextFn)` returns a `ComputedRef<ComposerActionEntry[]>`. Each entry includes the original `action` plus a `disabled` flag evaluated against the latest context.

| Property   | Type                                  | Description                                |
| ---------- | ------------------------------------- | ------------------------------------------ | --------------- |
| `id`       | `string`                              | Unique identifier.                         |
| `icon`     | `string`                              | Iconify name rendered in the composer bar. |
| `tooltip`  | `string \| undefined`                 | Optional hover text.                       |
| `label`    | `string \| undefined`                 | Optional button label.                     |
| `order`    | `number \| undefined`                 | Sorting hint (defaults to 200).            |
| `color`    | `ChromeActionColor \| undefined`      | Nuxt UI color token for button styling.    |
| `handler`  | `(ctx: ComposerActionContext) => void | Promise<void>`                             | Click callback. |
| `visible`  | `(ctx) => boolean`                    | Optional visibility predicate.             |
| `disabled` | `(ctx) => boolean`                    | Optional disabled predicate.               |

---

## API

```ts
registerComposerAction(action: ComposerAction): void;
unregisterComposerAction(id: string): void;
useComposerActions(context?: () => ComposerActionContext): ComputedRef<ComposerActionEntry[]>;
listRegisteredComposerActionIds(): string[];
```

---

## Under the hood

1. **Global registry** – Stores actions on `globalThis.__or3ComposerActionsRegistry`, ensuring a single source of truth across imports.
2. **Reactive list** – Mirrors the map with a Vue `reactive` wrapper so computed consumers react to updates.
3. **Sorting** – Ensures deterministic order via `order ?? 200` ascending.
4. **Immutability** – Actions are `Object.freeze`d to prevent accidental runtime mutation after registration.

---

## Edge cases & tips

-   **Duplicate IDs**: Later registrations overwrite earlier ones; dev mode logs a warning.
-   **Missing context**: All predicates receive an empty object if you omit `contextFn`—guard for undefined fields.
-   **Async errors**: Handlers should catch their own errors and show toasts; the registry doesn’t intercept failures.
-   **Streaming state**: Use `isStreaming` to disable actions while the AI is responding.

---

## Related

-   `useHeaderActions` — similar registry for the sidebar header buttons.
-   `useSidebarSections` — adds custom panels and footer actions to the chrome.
-   `~/app/components/chat` — consumes composer actions to render the button row.

---

## TypeScript

```ts
interface ComposerActionContext {
    editor?: Editor | null;
    threadId?: string | null;
    paneId?: string | null;
    isStreaming?: boolean;
}

interface ComposerAction {
    id: string;
    icon: string;
    tooltip?: string;
    label?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: ComposerActionContext) => void | Promise<void>;
    visible?: (ctx: ComposerActionContext) => boolean;
    disabled?: (ctx: ComposerActionContext) => boolean;
}
```
</file>

<file path="composables/useDashboardPlugins.md">
# useDashboardPlugins

Dashboard extension hub that lets first- and third-party features register launcher tiles, lazy-loaded pages, and capability flags for the retro dashboard. It centralises plugin discovery, page resolution, and in-app navigation state.

---

## What does it do?

`useDashboardPlugins` and its sibling utilities give you a full plugin registry:

-   `registerDashboardPlugin` / `unregisterDashboardPlugin` keep a global map of tiles, their icons, handlers, and optional inline pages.
-   `registerDashboardPluginPage` normalises page definitions, marks components as raw, and handles lazy factories + caches.
-   `useDashboardPlugins()` exposes a sorted, reactive list for rendering the dashboard grid.
-   `useDashboardNavigation()` orchestrates the dashboard → plugin → page flow, resolving components on demand and surfacing errors.
-   Capability helpers (`hasCapability`, `hasAllCapabilities`, etc.) enforce optional permission checks per plugin.

The registry survives HMR and SSR hydration thanks to `globalThis` caching and careful cloning/marking of reactive components.

---

## Basic Example

```ts
import {
    registerDashboardPlugin,
    registerDashboardPluginPage,
    useDashboardNavigation,
} from '~/composables/dashboard/useDashboardPlugins';

registerDashboardPlugin({
    id: 'notes',
    icon: 'i-ph-note-pencil',
    label: 'Notes',
    order: 120,
    capabilities: ['canWriteDocs'],
});

registerDashboardPluginPage('notes', {
    id: 'compose',
    title: 'Compose note',
    component: () => import('~/components/dashboard/NotesCompose.vue'),
});

const { dashboardItems, openPlugin, landingPages, openPage } =
    useDashboardNavigation();

await openPlugin('notes');
await openPage('notes', 'compose');
```

---

## How to use it

### 1. Register plugins early

Call `registerDashboardPlugin()` in a client entry (plugin, layout setup) so the dashboard grid has items on first render. Inline `pages` are optional but handy for declarative registration.

### 2. Define pages (optional)

Use `registerDashboardPluginPage(pluginId, page)` for additional routes or lazy modules. Page components can be direct Vue components or async factories; the registry caches the resolved component per plugin/page pair.

### 3. Drive the UI with `useDashboardNavigation`

The navigation composable merges built-in base items with registered plugins. It exposes:

-   `dashboardItems` — sorted tiles, ready for rendering.
-   `openPlugin(id)` — opens a plugin tile; routes to sole page automatically.
-   `openPage(pluginId, pageId)` — resolves and mounts a page component, tracking loading state and errors.
-   `goBack()` / `reset()` — return to the dashboard view.

Use `resolvedPageComponent` to mount the current page inside a `<component>`.

### 4. Enforce capabilities when needed

`hasCapability`, `hasAnyCapability`, and `hasAllCapabilities` read declarations from the registered plugin. Wire these into guards, button states, or context menus.

---

## API

### Plugin registry

```ts
registerDashboardPlugin(plugin: DashboardPlugin): void;
unregisterDashboardPlugin(id: string): void;
useDashboardPlugins(): ComputedRef<DashboardPlugin[]>;
listRegisteredDashboardPluginIds(): string[];
```

### Page registry

```ts
registerDashboardPluginPage(pluginId: string, page: DashboardPluginPage): void;
unregisterDashboardPluginPage(pluginId: string, pageId?: string): void;
useDashboardPluginPages(getId: () => string | undefined): ComputedRef<DashboardPluginPage[]>;
listDashboardPluginPages(pluginId: string): DashboardPluginPage[];
getDashboardPluginPage(pluginId: string, pageId: string): DashboardPluginPage | undefined;
resolveDashboardPluginPageComponent(pluginId: string, pageId: string): Promise<Component | undefined>;
```

### Navigation runtime

```ts
useDashboardNavigation(options?: { baseItems?: DashboardPlugin[] }): {
    state: Readonly<DashboardNavigationState>;
    resolvedPageComponent: Readonly<ShallowRef<Component | null>>;
    dashboardItems: ComputedRef<DashboardPlugin[]>;
    landingPages: ComputedRef<DashboardPluginPage[]>;
    headerPluginLabel: ComputedRef<string>;
    activePageTitle: ComputedRef<string>;
    openPlugin(pluginId: string): Promise<DashboardNavigationResult>;
    openPage(pluginId: string, pageId: string): Promise<DashboardNavigationResult>;
    goBack(): void;
    reset(): void;
};
```

### Capability helpers

```ts
hasCapability(pluginId: string, capability: string): boolean;
getPluginCapabilities(pluginId: string): string[];
hasAllCapabilities(pluginId: string, capabilities: string[]): boolean;
hasAnyCapability(pluginId: string, capabilities: string[]): boolean;
```

---

## Under the hood

1. **Global registries** — Uses `globalThis` slots so plugins survive HMR and SSR boundary crossings without duplicate registration.
2. **Reactive projections** — Keeps `reactiveList` and `reactivePages` mirrors for Vue consumers, ensuring computed getters remain responsive.
3. **Ordering** — Applies `DEFAULT_ORDER` (200) when no explicit order is set, making plugin placement predictable.
4. **Component caching** — Memoises resolved page components, clears caches on unregister, and marks resolved objects with `markRaw` to preserve Vue perf.
5. **Navigation state** — A singleton runtime tracks view mode, active plugin/page ids, loading state, and errors while exposing read-only refs to the UI.

---

## Edge cases & tips

-   **Duplicate IDs**: In dev, re-registering a plugin logs a warning but still replaces it—handy during HMR but avoid in production.
-   **Lazy pages**: If an async page loader returns a non-component, dev mode warns and the nav surfaces a `resolve-error` result.
-   **Single-page plugins**: `openPlugin()` auto-opens the lone page, simplifying button handlers.
-   **Error handling**: `openPlugin`/`openPage` return `{ ok: false, error }` with codes (`missing-plugin`, `missing-page`, `handler-error`, `resolve-error`) for structured UI reactions.
-   **Capability checks**: All capability helpers safely return `false` when the plugin is absent or declarations are missing—no need for extra guards.

---

## Related

-   `~/composables/dashboard` — home for dashboard-specific extensions.
-   `~/core/hooks` — hook system often used by plugins during registration.
-   `~/app/components/dashboard` — grid and page host components that consume `useDashboardNavigation`.
</file>

<file path="composables/useDefaultPrompt.md">
# useDefaultPrompt

Central helper for tracking the default system prompt across chat panes. It wraps the `kv` table, keeps a singleton ref of the active prompt ID, and fires hooks when the default changes so other modules can react.

---

## Overview

`useDefaultPrompt` gives you a reactive `defaultPromptId` alongside helpers to set or clear it. Behind the scenes it reads from Dexie on first use, stores the value in `kv` under `default_system_prompt_id`, and triggers a hook so panes refresh their copy.

-   Loads once per session (client-side) and caches the id in a shared ref
-   Keeps mutations synced to IndexedDB + in-memory state
-   Exposes `clearDefaultPrompt()` and `ensureLoaded()` helpers
-   Provides a `getDefaultPromptId()` utility for low-level access

---

## Quick start

```ts
import { useDefaultPrompt } from '~/composables/chat/useDefaultPrompt';

const { defaultPromptId, setDefaultPrompt, clearDefaultPrompt } =
    useDefaultPrompt();

watch(defaultPromptId, (id) => {
    console.log('Default prompt is now', id ?? 'not set');
});

await setDefaultPrompt('prompt-123');
// ... later
await clearDefaultPrompt();
```

---

## API

| Member                 | Type                                    | Description                                                           |
| ---------------------- | --------------------------------------- | --------------------------------------------------------------------- |
| `defaultPromptId`      | `ReadonlyRef<string \| null>`           | Reactive id for the default system prompt (or `null`).                |
| `setDefaultPrompt(id)` | `(id: string \| null) => Promise<void>` | Persist a new default prompt id (or `null`) and broadcast hook event. |
| `clearDefaultPrompt()` | `() => Promise<void>`                   | Convenience alias for `setDefaultPrompt(null)`.                       |
| `ensureLoaded()`       | `() => Promise<void>`                   | Force-load the cached value (useful during SSR guards).               |

### Standalone helper

| Function               | Description                                                                                                   |
| ---------------------- | ------------------------------------------------------------------------------------------------------------- |
| `getDefaultPromptId()` | Async function that reads directly from Dexie and returns the stored id without touching the singleton store. |

---

## How it works

1. **Singleton state** — The ref `_defaultPromptId` lives at module scope, so every caller shares the same reactive value.
2. **Lazy load** — `loadOnce()` reads `kv` only the first time a browser caller uses the composable. On SSR it no-ops because Dexie isn’t available.
3. **Updates** — `setDefaultPrompt()` updates the ref, persists via `setKvByName`, then fires `chat.systemPrompt.default:action:update` with the new id so listeners refresh.
4. **Clearing** — `clearDefaultPrompt()` simply calls `setDefaultPrompt(null)`.
5. **Direct access** — `getDefaultPromptId()` is exported for non-reactive flows (e.g. server actions) that just need the value once.

---

## Usage patterns

### Create a settings toggle

```ts
const { defaultPromptId, setDefaultPrompt } = useDefaultPrompt();

async function applyPrompt(promptId: string) {
    await setDefaultPrompt(promptId);
}
```

### Guard before loading prompt content

```ts
const { ensureLoaded, defaultPromptId } = useDefaultPrompt();

await ensureLoaded();
if (defaultPromptId.value) {
    await loadPrompt(defaultPromptId.value);
}
```

### Server-side lookup

```ts
import { getDefaultPromptId } from '~/composables/chat/useDefaultPrompt';

const promptId = await getDefaultPromptId();
if (promptId) {
    // fetch prompt details from db
}
```

---

## Edge cases & notes

-   **Client-only loading** — The composable guards on `import.meta.client`; SSR imports will see `defaultPromptId` remain `null` until the client hydrates.
-   **Missing record** — If the key isn’t present, the ref is set to `null` and no errors bubble up.
-   **Hook listeners** — Consumers can subscribe with `useHooks().addAction('chat.systemPrompt.default:action:update', handler)` to respond whenever the default changes.
-   **Error handling** — Storage read/write operations are wrapped in try/catch; failures simply keep the ref at `null`.

---

## Related references

-   `useActivePrompt` — to manage prompt details once you have the id.
-   `~/db/kv` — utility wrapping Dexie’s key-value store.
-   `chat.systemPrompt.default:action:update` — hook dispatched after every update.
</file>

<file path="composables/useDocumentHistoryActions.md">
# useDocumentHistoryActions

Registry composable that lets plugins inject extra actions into the document history sidebar menu. Keeps a global list of action buttons, sorts them, and survives HMR so dashboard add-ons can extend the UI safely.

---

## What does it do?

`useDocumentHistoryActions` powers the dropdown on each document history item:

-   `registerDocumentHistoryAction()` adds or replaces an action definition.
-   `useDocumentHistoryActions()` returns a sorted, reactive array of actions for rendering.
-   `unregisterDocumentHistoryAction()` removes actions during cleanup to avoid duplicates.
-   `listRegisteredDocumentHistoryActionIds()` helps authors inspect what’s already registered.

Because the registry lives on `globalThis`, the set of actions persists across hot reloads and SSR hydration.

---

## Basic Example

```ts
import {
    registerDocumentHistoryAction,
    unregisterDocumentHistoryAction,
    useDocumentHistoryActions,
} from '~/composables/documents/useDocumentHistoryActions';

registerDocumentHistoryAction({
    id: 'export-pdf',
    icon: 'i-ph-file-pdf',
    label: 'Export as PDF',
    order: 210,
    async handler({ document }) {
        await exportDocumentToPdf(document.id);
    },
});

const actions = useDocumentHistoryActions();

onScopeDispose(() => {
    unregisterDocumentHistoryAction('export-pdf');
});
```

---

## How to use it

### 1. Register on startup or inside a hook

Call `registerDocumentHistoryAction()` when your plugin initialises. Use `useHookEffect()` if you need automatic cleanup on HMR/unmount.

### 2. Provide a unique ID and icon

-   Prefix IDs with your namespace (`my-plugin:download`) to avoid conflicts.
-   Supply an Iconify name that fits the retro UI.

### 3. Handle the click

The handler receives `{ document }` where `document` is the Dexie `Post` record. Perform async work freely; the dropdown stays responsive.

### 4. Render the actions

Components like the document sidebar call `useDocumentHistoryActions()` to read the current list. You can do the same to inject actions into custom UIs or tests.

---

## What you get back

`useDocumentHistoryActions()` returns a computed ref sorted by `order` (default 200), so lower numbers appear first.

| Property  | Type                                                 | Description                        |
| --------- | ---------------------------------------------------- | ---------------------------------- |
| `id`      | `string`                                             | Unique identifier for the action.  |
| `icon`    | `string`                                             | Iconify name rendered in the menu. |
| `label`   | `string`                                             | Button text shown in the dropdown. |
| `order`   | `number \| undefined`                                | Placement hint (defaults to 200).  |
| `handler` | `(ctx: { document: Post }) => void \| Promise<void>` | Click callback.                    |

---

## API

```ts
registerDocumentHistoryAction(action: DocumentHistoryAction): void;
unregisterDocumentHistoryAction(id: string): void;
useDocumentHistoryActions(): ComputedRef<DocumentHistoryAction[]>;
listRegisteredDocumentHistoryActionIds(): string[];
```

---

## Under the hood

1. **Global map** – Stores actions on `globalThis.__or3DocumentHistoryActionsRegistry` to persist across reloads.
2. **Reactive mirror** – Maintains `reactiveList.items` so Vue can track changes without making the map reactive.
3. **Sorting** – Consumers sort by `order` on every read, ensuring deterministic menus.
4. **HMR-safe** – Re-registering an existing ID simply replaces the entry; dev mode can warn upstream.

---

## Edge cases & tips

-   **Duplicate IDs**: Later registrations replace earlier ones. If that’s unintentional, inspect `listRegisteredDocumentHistoryActionIds()`.
-   **Order gaps**: You don’t need consecutive numbers—stick to buckets (100 built-ins, 200 extensions, etc.).
-   **Cleanup**: Always unregister on scope dispose to avoid stale actions when HMR tears down modules.
-   **Error handling**: Wrap handler logic in try/catch and surface toast notifications yourself; the registry doesn’t swallow errors.

---

## Related

-   `useHookEffect` — ideal for registering/unregistering actions inside plugin lifecycles.
-   `~/app/components/sidebar/DocumentHistory.vue` — renders the menu that consumes this registry.
-   `~/db/posts` — source type for the `document` payload.

---

## TypeScript

```ts
interface DocumentHistoryAction {
    id: string;
    icon: string;
    label: string;
    order?: number;
    handler: (ctx: { document: Post }) => void | Promise<void>;
}
```
</file>

<file path="composables/useDocumentsList.md">
# useDocumentsList

Lightweight fetch-and-refresh composable for the documents sidebar. Loads recent Dexie `documents` entries, trims heavy fields, and keeps the list fresh when database hooks fire.

---

## What does it do?

`useDocumentsList(limit?)` gives you:

-   A `docs` ref with up to `limit` lightweight document summaries.
-   A `loading` flag optimised for SSR → client hydration.
-   An `error` ref populated when Dexie calls fail.
-   A `refresh()` function to reload on demand.
-   Automatic refresh when `db.documents.*` hook events fire on the client.

By trimming `content`, the sidebar avoids storing huge TipTap JSON strings in memory.

---

## Basic Example

```ts
import { useDocumentsList } from '~/composables/documents/useDocumentsList';

const { docs, loading, error, refresh } = useDocumentsList(100);

onMounted(() => {
    if (!loading.value && !docs.value.length) refresh();
});
```

---

## How to use it

### 1. Call the composable in setup

Optionally pass a `limit` (default `200`) to cap results. The first run sets `loading` to `true` so SSR and client HTML match.

### 2. Render the list

`docs.value` contains objects with metadata (`id`, `title`, `postType`, timestamps, `deleted`, `meta`). Bind them into your sidebar or dashboards.

### 3. Handle loading & errors

-   Show spinners while `loading.value` is `true`.
-   Read `error.value` when a fetch fails; a toast is already fired with "Document: list failed".

### 4. Refresh when needed

Call `refresh()` after bulk operations or when server-triggered changes need to propagate. On the client, the composable already listens for:

-   `db.documents.create:action:after`
-   `db.documents.update:action:after`
-   `db.documents.delete:action:*:after`

Those hooks come from the central `$hooks` engine via `useHookEffect` and ensure the list stays current.

---

## What you get back

| Property  | Type                  | Description                                       |
| --------- | --------------------- | ------------------------------------------------- |
| `docs`    | `Ref<Document[]>`     | Array of trimmed document records (no `content`). |
| `loading` | `Ref<boolean>`        | `true` while fetching from Dexie.                 |
| `error`   | `Ref<unknown>`        | Error value if the last fetch failed.             |
| `refresh` | `() => Promise<void>` | Reload the list manually.                         |

The returned `Document` objects keep `content: ''` to satisfy the type while staying lightweight.

---

## Under the hood

1. **Dexie fetch** – Uses `listDocuments(limit)` to query the `documents` store.
2. **Field pruning** – Maps results to a slimmer object before storing in the ref.
3. **Error handling** – Catches failures, stamps `error.value`, and raises a toast.
4. **Hook subscriptions** – Registers `useHookEffect` listeners on the client to refresh after create/update/delete actions.
5. **SSR friendly** – Leaves `loading` true during SSR so hydration sees the same markup.

---

## Edge cases & tips

-   **Server-only usage**: On the server, the hook listeners don’t run. Call `refresh()` manually if you render on the server and stream updates.
-   **Limit tuning**: Adjust `limit` depending on sidebar performance; the query already caps the results client-side.
-   **Custom toasts**: If you need custom messaging, catch `error.value` in your component and display additional context.
-   **Deleted docs**: Entries include a `deleted` flag so you can filter out soft-deleted documents if desired.

---

## Related

-   `~/db/documents` — Dexie helpers used under the hood.
-   `useDocumentsStore` — full document state with content + autosave.
-   `usePaneDocuments` — orchestrates pane-specific document selection.

---

## TypeScript

```ts
function useDocumentsList(limit?: number): {
    docs: Ref<Document[]>;
    loading: Ref<boolean>;
    error: Ref<unknown>;
    refresh: () => Promise<void>;
};
```
</file>

<file path="composables/useDocumentsStore.md">
# useDocumentsStore

Stateful document manager that loads Dexie records, stages edits, debounces autosaves, and coordinates pane-level hooks. It is the backbone for rich text documents in OR3’s multi-pane UI.

---

## What does it do?

`useDocumentsStore` exposes a suite of helpers around a shared `documentsMap` cache:

-   Loads documents via `loadDocument()` and caches them per ID.
-   Tracks pending title/content changes and auto-flushes after 750 ms of inactivity.
-   Sends toast notifications when create/load/save actions fail.
-   Emits `$hooks` events (`ui.pane.doc:action:saved`, `:changed`, etc.) so panes stay in sync.
-   Provides low-level helpers like `releaseDocument()` to drop heavy TipTap JSON from memory.

The map lives in module scope, so every component shares the same live state.

---

## Basic Example

```ts
import {
    newDocument,
    loadDocument,
    setDocumentTitle,
    setDocumentContent,
    useDocumentState,
} from '~/composables/documents/useDocumentsStore';

const doc = await newDocument({ title: 'Untitled doc' });

await loadDocument(doc.id);

setDocumentTitle(doc.id, 'My Notes');
setDocumentContent(doc.id, editorStateJSON);

const state = useDocumentState(doc.id);
watch(
    () => state.status,
    (status) => {
        if (status === 'saved') console.log('Document persisted');
    }
);
```

---

## How to use it

### 1. Create or load records

-   Use `newDocument(initial?)` to create a Dexie record and seed the store.
-   Call `loadDocument(id)` to fetch an existing record into memory. The function resolves to the record (or `null` if missing) and surfaces toasts for not-found errors.

### 2. Stage edits

-   `setDocumentTitle(id, title)` and `setDocumentContent(id, content)` mark changes as pending and schedule a save.
-   Saves batch after 750 ms (configurable via `scheduleSave`’s default).

### 3. Flush explicitly when needed

-   Invoke `flush(id)` to force an immediate save, e.g., before navigation.
-   Pass `{ flush: false }` into `releaseDocument()` if you’ve already flushed.

### 4. Observe status

-   `useDocumentState(id)` returns the shared `DocState` (record, status, pending fields, last error).
-   Status cycles through `'loading' → 'idle' → 'saving' → 'saved'` (or `'error'`).

### 5. Release heavy content

Call `releaseDocument(id, { flush?: boolean, deleteEntry?: boolean })` when you leave a pane to reclaim memory. This clears timers, optional flushes, and drops the record reference so the GC can free the TipTap payload.

---

## What you get back

| Helper                            | Description                                                          |
| --------------------------------- | -------------------------------------------------------------------- |
| `newDocument(initial?)`           | Creates a document and primes the store; emits toast on failure.     |
| `loadDocument(id)`                | Fetches from Dexie, updates cache, and returns the record or `null`. |
| `setDocumentTitle(id, title)`     | Marks a new title and schedules a save.                              |
| `setDocumentContent(id, content)` | Stages TipTap JSON and schedules a save.                             |
| `flush(id)`                       | Persists pending fields immediately.                                 |
| `releaseDocument(id, opts?)`      | Clears timers, optionally flushes, and removes cached state.         |
| `useDocumentState(id)`            | Returns the `DocState` entry for reactive inspection.                |
| `useAllDocumentsState()`          | Gives you the reactive map (for debugging tooling).                  |
| `__hasPendingDocumentChanges(id)` | Internal helper to check for staged edits.                           |
| `__peekDocumentStatus(id)`        | Internal helper to read status without touching reactivity.          |

`DocState` looks like:

```ts
interface DocState {
    record: Document | null;
    status: 'idle' | 'saving' | 'saved' | 'error' | 'loading';
    lastError?: any;
    pendingTitle?: string;
    pendingContent?: any;
    timer?: any;
}
```

---

## Under the hood

1. **Shared map** – `documentsMap` (reactive `Map<string, DocState>`) ensures every component edits the same instance.
2. **Debounced saves** – `scheduleSave()` coalesces rapid edits into a single `flush()` invocation.
3. **Dexie helpers** – Uses `createDocument`, `updateDocument`, and `getDocument` from `~/db/documents`.
4. **Toast feedback** – Failures call `useToast().add()` with consistent retro styling.
5. **Pane events** – After `flush()`, the store locates open document panes via the global multi-pane API and triggers `ui.pane.doc:action:saved` events through `$hooks`.
6. **Memory hygiene** – `releaseDocument()` clears timers, removes `content`, and optionally deletes the map entry.

---

## Edge cases & tips

-   **Missing record**: `loadDocument()` returns `null` and shows a toast; callers should handle the `null` case.
-   **Autosave race**: Multiple rapid edits reset the same timer, so only the final state flushes.
-   **Manual flush before unload**: Call `await flush(id)` in route guards/modals to guarantee persistence.
-   **Pane hooks**: Tests or integrations can call `__hasPendingDocumentChanges()` to decide whether to force a save before closing a pane.
-   **Deleting entries**: After releasing with `{ deleteEntry: true }`, calling `useDocumentState(id)` recreates a fresh placeholder.

---

## Related

-   `usePaneDocuments` — orchestrates pane switching on top of this store.
-   `~/composables/core/useMultiPane` — pane runtime referenced when emitting hook actions.
-   `~/db/documents` — Dexie CRUD implementation backing all operations.

---

## TypeScript

```ts
function useDocumentState(id: string): DocState;
function useAllDocumentsState(): Map<string, DocState>;
async function loadDocument(id: string): Promise<Document | null>;
async function newDocument(initial?: {
    title?: string;
    content?: any;
}): Promise<Document>;
function setDocumentTitle(id: string, title: string): void;
function setDocumentContent(id: string, content: any): void;
async function flush(id: string): Promise<void>;
async function releaseDocument(
    id: string,
    opts?: { flush?: boolean; deleteEntry?: boolean }
): Promise<void>;
```
</file>

<file path="composables/useEditorNodes.md">
# useEditorNodes

Registry trio that lets plugins add TipTap nodes, marks, and extensions to the OR3 editor without patching the core component. Maintains global maps, keeps ordering stable, and plays nicely with HMR.

---

## What does it do?

`useEditorNodes` exports helpers that manage three registries:

-   `registerEditorNode` / `listEditorNodes` for TipTap `Node` extensions.
-   `registerEditorMark` / `listEditorMarks` for TipTap `Mark` extensions.
-   `registerEditorExtension` / `listEditorExtensions` for generic TipTap extensions.

Each registry sorts entries by `order` (default 200) and stores them on `globalThis` so reloads don’t duplicate items.

---

## Basic Example

```ts
import BulletList from '@tiptap/extension-bullet-list';
import Italic from '@tiptap/extension-italic';
import CharacterCount from '@tiptap/extension-character-count';
import {
    registerEditorNode,
    registerEditorMark,
    registerEditorExtension,
    unregisterEditorNode,
} from '~/composables/editor/useEditorNodes';

registerEditorNode({
    id: 'custom:bullet-list',
    extension: BulletList,
    order: 180,
});

registerEditorMark({
    id: 'custom:italic',
    extension: Italic,
});

registerEditorExtension({
    id: 'custom:char-count',
    extension: CharacterCount.configure({ limit: 2000 }),
});

onScopeDispose(() => {
    unregisterEditorNode('custom:bullet-list');
});
```

---

## How to use it

### 1. Pick the right registry

-   Use `registerEditorNode()` for block/inline nodes (paragraphs, lists, embeds).
-   Use `registerEditorMark()` for text marks (bold, italic, highlights).
-   Use `registerEditorExtension()` for plugins that don’t fit either bucket (history, collaboration, etc.).

### 2. Provide a unique ID

Namespace IDs (e.g., `your-plugin:node`) so duplicate registrations override intentionally.

### 3. Set ordering if needed

-   Built-ins typically occupy the <200 range. Lower values appear earlier when the editor component iterates.
-   Leave `order` undefined to slot your extension after core ones.

### 4. Clean up on dispose

Call the matching `unregister*` helper during HMR or component teardown to prevent stale entries.

### 5. Consume from the editor shell

`listEditorNodes()`, `listEditorMarks()`, and `listEditorExtensions()` return sorted arrays—`DocumentEditor.vue` reads them to build the TipTap instance.

---

## API

```ts
registerEditorNode(node: EditorNode): void;
unregisterEditorNode(id: string): void;
listEditorNodes(): EditorNode[];
listRegisteredEditorNodeIds(): string[];

registerEditorMark(mark: EditorMark): void;
unregisterEditorMark(id: string): void;
listEditorMarks(): EditorMark[];
listRegisteredEditorMarkIds(): string[];

registerEditorExtension(ext: EditorExtension): void;
unregisterEditorExtension(id: string): void;
listEditorExtensions(): EditorExtension[];
listRegisteredEditorExtensionIds(): string[];
```

---

## Under the hood

1. **Global maps** – Registries live on `globalThis.__or3Editor*Registry`, so multiple imports share the same data and HMR doesn’t double-register.
2. **Reactive mirrors** – `reactiveList` objects mirror each map so Vue can track changes when lists are recomputed.
3. **Stable sorting** – Items sort by `order` with a secondary `id` tie-breaker for deterministic output.
4. **Dev warnings** – In dev mode, double registration logs a warning to help catch collisions early.

---

## Edge cases & tips

-   **Duplicate IDs**: Later registrations replace earlier ones. Use this intentionally for overrides, otherwise rename your extension.
-   **Mark vs extension**: Some TipTap packages export both mark + helper. Register whichever type your editor setup expects.
-   **SSR safety**: Registries initialise lazily and don’t touch browser-only APIs, so they’re safe during server rendering.
-   **Cleanup**: Forgetting to unregister during HMR can leave stale marks that break tests; wrap registrations in `useHookEffect` to automate cleanup.

---

## Related

-   `useEditorToolbar` — complementary registry for toolbar buttons.
-   `~/app/components/editor/DocumentEditor.vue` — consumes these lists when building the TipTap instance.
-   `~/utils/editor/` — shared helpers for configuring extensions.

---

## TypeScript

```ts
interface EditorNode {
    id: string;
    extension: Node;
    order?: number;
}

interface EditorMark {
    id: string;
    extension: Mark;
    order?: number;
}

interface EditorExtension {
    id: string;
    extension: Extension;
    order?: number;
}
```
</file>

<file path="composables/useEditorToolbar.md">
# useEditorToolbar

Toolbar registry for the TipTap editor. Lets plugins add buttons, toggles, or dropdowns to the retro editor header while keeping the UI reactive and order-aware.

---

## What does it do?

`useEditorToolbar` exposes helpers to manage toolbar buttons:

-   `registerEditorToolbarButton()` adds or replaces a button definition.
-   `useEditorToolbarButtons(editorRef)` returns a computed, filtered, and sorted array of buttons ready to render.
-   `unregisterEditorToolbarButton()` cleans up during teardown/HMR.
-   `listRegisteredEditorToolbarButtonIds()` lets authors inspect the registry.

Buttons can customise visibility, active state, icons, ordering, and click behaviour.

---

## Basic Example

```ts
import Bold from '@tiptap/extension-bold';
import {
    registerEditorToolbarButton,
    unregisterEditorToolbarButton,
    useEditorToolbarButtons,
} from '~/composables/editor/useEditorToolbar';
import { registerEditorMark } from '~/composables/editor/useEditorNodes';

registerEditorMark({ id: 'custom:bold', extension: Bold });

registerEditorToolbarButton({
    id: 'custom:bold-toggle',
    icon: 'i-ph-text-b',
    tooltip: 'Bold (⌘B)',
    order: 150,
    isActive: (editor) => editor.isActive('bold'),
    onClick: (editor) => editor.chain().focus().toggleBold().run(),
});

const buttons = useEditorToolbarButtons(editorRef);

onScopeDispose(() => {
    unregisterEditorToolbarButton('custom:bold-toggle');
});
```

---

## How to use it

### 1. Register buttons during setup

Call `registerEditorToolbarButton()` inside a plugin or component. Namespace IDs to avoid clashes (`my-plugin:bold`).

### 2. Implement handlers

-   `onClick` receives the live TipTap editor instance—chain commands, toggle marks, etc.
-   `isActive` marks buttons as pressed (useful for toggles).
-   `visible` hides buttons conditionally (e.g., based on editor capabilities).

Wrap logic in try/catch if the command could fail; errors bubble to the console in dev but won’t break rendering.

### 3. Consume in the toolbar component

Pass a ref to the current `Editor` instance into `useEditorToolbarButtons()`. The computed result auto-updates when visibility changes (e.g., selection context).

### 4. Order buttons

-   Built-ins generally occupy <200 slots.
-   Set `order` to insert before/after core controls; ties fall back to `id` alphabetical order.

### 5. Clean up for HMR

Call `unregisterEditorToolbarButton()` during teardown to avoid duplicates when modules hot reload.

---

## What you get back

`useEditorToolbarButtons(editorRef)` returns a `ComputedRef<EditorToolbarButton[]>`. Each button contains:

| Property   | Type                          | Description                                          |
| ---------- | ----------------------------- | ---------------------------------------------------- | ------------------------------------ |
| `id`       | `string`                      | Unique identifier.                                   |
| `icon`     | `string`                      | Iconify name shown in the retro toolbar.             |
| `tooltip`  | `string \| undefined`         | Hover hint.                                          |
| `order`    | `number \| undefined`         | Controls placement (default 200).                    |
| `isActive` | `(editor: Editor) => boolean` | Optional active state tester.                        |
| `onClick`  | `(editor: Editor) => void     | Promise<void>`                                       | Executes when the button is clicked. |
| `visible`  | `(editor: Editor) => boolean` | Optional visibility predicate; hidden on exceptions. |

---

## API

```ts
registerEditorToolbarButton(button: EditorToolbarButton): void;
unregisterEditorToolbarButton(id: string): void;
useEditorToolbarButtons(editorRef: Ref<Editor | null>): ComputedRef<EditorToolbarButton[]>;
listRegisteredEditorToolbarButtonIds(): string[];
```

---

## Under the hood

1. **Global map** – Buttons live on `globalThis.__or3EditorToolbarRegistry`, preventing duplicate registrations across imports/HMR.
2. **Reactive mirror** – A reactive list mirrors the map so Vue recomputes consumer arrays automatically.
3. **Visibility guard** – `useEditorToolbarButtons` filters buttons through their `visible` callback inside a try/catch; errors default to hiding the button.
4. **Stable sort** – Buttons sort by `order` with a secondary `id` tie-breaker for deterministic output.

---

## Edge cases & tips

-   **No editor yet**: When `editorRef.value` is `null`, the computed array is empty—render guards should handle this gracefully.
-   **Async handlers**: Returning a promise is supported; UI code can await if needed (e.g., to show loading states).
-   **Keyboard shortcuts**: Pair buttons with TipTap commands bound via `editor.registerPlugin` or external shortcut handlers.
-   **Testing**: In Vitest, provide a mocked editor object with the minimal API (`chain`, `isActive`) to test your buttons.

---

## Related

-   `useEditorNodes` — register complementary nodes/marks.
-   `~/app/components/editor/DocumentEditorToolbar.vue` — consumes the toolbar registry.
-   `@tiptap/vue-3` — TipTap editor integration referenced by button handlers.

---

## TypeScript

```ts
interface EditorToolbarButton {
    id: string;
    icon: string;
    tooltip?: string;
    order?: number;
    isActive?: (editor: Editor) => boolean;
    onClick: (editor: Editor) => void | Promise<void>;
    visible?: (editor: Editor) => boolean;
}
```
</file>

<file path="composables/useHeaderActions.md">
# useHeaderActions

Sidebar header action registry that powers the icon buttons in the chrome header (new thread, toggle layout, etc.). Lets plugins contribute actions that react to route, breakpoint, or custom context.

---

## What does it do?

`useHeaderActions` wraps the shared registry factory to provide:

-   `registerHeaderAction()` / `unregisterHeaderAction()` for lifecycle management.
-   `useHeaderActions(contextFn)` to compute filtered, ordered buttons with disabled state applied.
-   `listRegisteredHeaderActionIds()` for debugging.

Actions can adjust styling via `color`, display tooltips, and opt into mobile-only/desktop-only modes.

---

## Basic Example

```ts
import {
    registerHeaderAction,
    unregisterHeaderAction,
    useHeaderActions,
} from '~/composables/sidebar/useHeaderActions';

registerHeaderAction({
    id: 'custom:toggle-projects',
    icon: 'i-ph-folders',
    tooltip: 'Toggle projects',
    order: 160,
    visible: ({ isMobile }) => !isMobile,
    handler: () => emitToggleProjects(),
});

const actions = useHeaderActions(() => ({ route: useRoute(), isMobile }));

onScopeDispose(() => unregisterHeaderAction('custom:toggle-projects'));
```

---

## How to use it

### 1. Register actions on startup

-   Namespace IDs to avoid clobbering built-ins.
-   Provide `icon`, optional `tooltip`, `label`, `color`, and `order`.

### 2. Feed context into `useHeaderActions`

`contextFn` should return whatever inputs your predicates need (e.g., current `route`, `isMobile` flag from `useBreakpoints`). The computed list recalculates whenever the returned values change.

### 3. Control visibility and disabled state

-   `visible(ctx)` returns `false` to hide the button entirely.
-   `disabled(ctx)` greys out the button but keeps tooltip + layout.

### 4. Handle clicks

`handler(ctx)` can perform sync or async work. Manage your own loading indicators—you can combine with `disabled` toggles if necessary.

### 5. Cleanup during teardown

Call `unregisterHeaderAction()` (or use `useHookEffect`) to avoid duplicates under HMR.

---

## What you get back

`useHeaderActions(contextFn)` returns a `ComputedRef<HeaderActionEntry[]>` where each entry includes the original action plus evaluated `disabled` state.

| Property   | Type                                | Description                                  |
| ---------- | ----------------------------------- | -------------------------------------------- | -------------- |
| `id`       | `string`                            | Unique identifier.                           |
| `icon`     | `string`                            | Iconify name for the header button.          |
| `tooltip`  | `string \| undefined`               | Hover/focus hint.                            |
| `label`    | `string \| undefined`               | Optional text label beside the icon.         |
| `order`    | `number \| undefined`               | Sort order (default 200).                    |
| `color`    | `ChromeActionColor \| undefined`    | Styling hint passed to the button component. |
| `handler`  | `(ctx: HeaderActionContext) => void | Promise<void>`                               | Click handler. |
| `visible`  | `(ctx) => boolean`                  | Optional visibility predicate.               |
| `disabled` | `(ctx) => boolean`                  | Optional disabled predicate.                 |

---

## API

```ts
registerHeaderAction(action: HeaderAction): void;
unregisterHeaderAction(id: string): void;
useHeaderActions(context?: () => HeaderActionContext): ComputedRef<HeaderActionEntry[]>;
listRegisteredHeaderActionIds(): string[];
```

---

## Under the hood

1. **Registry factory** – Uses `createRegistry('__or3HeaderActionsRegistry')` which already handles dedupe, sorting, and reactivity.
2. **Default ordering** – Applies `order ?? 200` so plugin buttons usually land after built-ins unless you specify otherwise.
3. **Context-driven filtering** – Runs `visible`/`disabled` functions for every render; errors aren’t caught here, so write defensive code if predicates touch optional fields.
4. **Shared list** – All imports share the same global registry, making it safe to register from multiple modules.

---

## Edge cases & tips

-   **Mobile-only actions**: Pair `visible` with your responsive breakpoints to hide controls on smaller layouts.
-   **Route-dependent actions**: Use `route.name` or `route.path` inside predicates to only show actions on relevant pages.
-   **Async state**: If a handler triggers network work, consider disabling the button until the promise resolves.
-   **Testing**: Mock `createRegistry` or inject a fake registry when writing unit tests to keep them deterministic.

---

## Related

-   `useComposerActions` — handles composer button row.
-   `useSidebarSections` — adds custom sidebar panels and footer actions.
-   `~/composables/_registry` — shared factory powering these registries.

---

## TypeScript

```ts
interface HeaderActionContext {
    route?: RouteLocationNormalizedLoaded | null;
    isMobile?: boolean;
}

interface HeaderAction extends RegistryItem {
    id: string;
    icon: string;
    tooltip?: string;
    label?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: HeaderActionContext) => void | Promise<void>;
    visible?: (ctx: HeaderActionContext) => boolean;
    disabled?: (ctx: HeaderActionContext) => boolean;
}
```
</file>

<file path="composables/useHookEffect.md">
# useHookEffect

Typed helper for subscribing to the internal hook bus. It registers a callback, cleans up automatically on component unmount and during hot-module reload, and returns a disposer if you need manual control.

---

## What does it do?

`useHookEffect` wraps the hook engine (`useHooks()`) with lifecycle-aware registration. Whenever a component mounts, it attaches your callback to a named hook and guarantees cleanup so you never leak listeners.

-   Supports every hook name with full TypeScript inference
-   Lets you override hook kind (`action` / `filter`) and priority
-   Auto-detaches on `onBeforeUnmount`
-   Handles Vite/Nuxt HMR disposal for local development

---

## Basic Example

```ts
import { useHookEffect } from '~/composables/core/useHookEffect';

useHookEffect('ui.chat.message:filter:outgoing', async (message) => {
    if (message.content.includes('restricted')) {
        return false; // veto send
    }
    return message;
});
```

---

## How to use it

### 1. Import and register

Call `useHookEffect(name, callback)` in `setup()`. The callback signature is inferred from the hook name, so TypeScript will keep you honest.

### 2. Optionally tweak behavior

Pass an `opts` object to set a specific hook kind or priority:

```ts
useHookEffect('ui.pane.switch:action', handler, {
    kind: 'action',
    priority: 50,
});
```

### 3. Manually dispose if needed

The function returns a disposer. You rarely need it, but it can be helpful when toggling listeners in response to reactive state.

```ts
const dispose = useHookEffect('ai.chat.send:action:after', onComplete);

watch(enabled, (next) => {
    if (!next) dispose();
});
```

---

## API

```ts
function useHookEffect<K extends HookName>(
    name: K,
    fn: InferHookCallback<K>,
    opts?: {
        kind?: HookKind;
        priority?: number;
    }
): () => void;
```

| Parameter       | Type                               | Description                                                                 |
| --------------- | ---------------------------------- | --------------------------------------------------------------------------- |
| `name`          | `HookName`                         | The hook identifier (strongly typed to known strings).                      |
| `fn`            | `InferHookCallback<K>`             | Listener invoked when the hook fires.                                       |
| `opts.kind`     | `'action' \| 'filter' \| HookKind` | Override the resolved kind when the name is ambiguous.                      |
| `opts.priority` | `number`                           | Smaller numbers run first; defaults to the hook engine’s standard priority. |

Returns the disposer you can call to unregister immediately.

---

## Under the hood

1. Fetches the shared hook engine with `useHooks()`.
2. Registers the callback with `hooks.on`, capturing the disposer.
3. Subscribes to `onBeforeUnmount` to `hooks.off(disposer)`.
4. During HMR, listens for `import.meta.hot.dispose` and calls the disposer.

Because of that lifecycle tie-in, you can safely register listeners in any component without worrying about stale callbacks.

---

## Edge cases & tips

-   **SSR**: Safe to import; hooks execute client-side where the engine lives.
-   **Multiple registrations**: Each call returns its own disposer—store them if you plan to toggle listeners dynamically.
-   **Kind inference**: If a hook name ends with `:filter:*`, the kind defaults to `filter`; same for `:action:*`. Override `opts.kind` only when absolutely necessary.
-   **Priorities**: Use lower numbers to ensure your filter runs before default ones (e.g., set to `25` to beat default `50`).

---

## Related

-   `useHooks()` — exposes the raw hook API if you need advanced control.
-   `docs/core-hook-map.md` — catalog of built-in hook names.
-   `useChat` / `useMultiPane` — major composables that emit the hooks you’ll most often tap into.
</file>

<file path="composables/useMessageActions.md">
# useMessageActions

Extensible action registry for chat messages. Lets core UI and plugins add contextual buttons (copy, retry, favorite, etc.) in a consistent order with minimal wiring.

---

## What it does

`useMessageActions` maintains a global list of action descriptors keyed by an id. Components register their actions once, and when rendering an individual message you can pull the filtered, sorted list for that message’s role.

-   Stores actions in a singleton Map (survives HMR)
-   Exposes helpers to register/unregister actions
-   Provides a computed list scoped to user or assistant messages
-   Supports ordering via an optional `order` property (default 200)

---

## Registering an action

```ts
import { registerMessageAction } from '~/composables/chat/useMessageActions';

registerMessageAction({
    id: 'copy-text',
    icon: 'i-heroicons-clipboard-document',
    tooltip: 'Copy to clipboard',
    showOn: 'assistant',
    order: 150,
    async handler({ message }) {
        await navigator.clipboard.writeText(message.text);
    },
});
```

Built-in actions from core components typically use orders below 200. Plugins can pick `order >= 200` to appear after defaults unless they intentionally override.

---

## API

| Export                             | Type                                                                             | Description                                                           |
| ---------------------------------- | -------------------------------------------------------------------------------- | --------------------------------------------------------------------- |
| `registerMessageAction(action)`    | `(action: ChatMessageAction) => void`                                            | Add or replace an action descriptor in the registry.                  |
| `unregisterMessageAction(id)`      | `(id: string) => void`                                                           | Remove an action by id (optional cleanup).                            |
| `useMessageActions(message)`       | `(message: { role: 'user' \| 'assistant' }) => ComputedRef<ChatMessageAction[]>` | Get a computed, role-filtered, ordered list for a specific message.   |
| `listRegisteredMessageActionIds()` | `() => string[]`                                                                 | Return all registered ids (useful for debugging or collision checks). |

### `ChatMessageAction`

```ts
interface ChatMessageAction {
    id: string;
    icon: string;
    tooltip: string;
    showOn: 'user' | 'assistant' | 'both';
    order?: number; // defaults to 200
    handler: (ctx: { message: any; threadId?: string }) => void | Promise<void>;
}
```

---

## Using in a component

```vue
<template>
    <div class="message-actions">
        <UButton
            v-for="action in actions"
            :key="action.id"
            :icon="action.icon"
            variant="ghost"
            size="xs"
            :aria-label="action.tooltip"
            @click="action.handler({ message, threadId })"
        />
    </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useMessageActions } from '~/composables/chat/useMessageActions';

const props = defineProps<{
    message: { role: 'user' | 'assistant'; id: string };
}>();
const threadId = useCurrentThreadId();

const actionsComputed = useMessageActions(props.message);
const actions = computed(() => actionsComputed.value);
</script>
```

---

## Internals

1. **Registry Map** — Stored on `globalThis` so repeated imports share data even with HMR.
2. **Reactive mirror** — A `reactiveList` array mirrors the Map contents so Vue can track changes. Every register/unregister call re-syncs the array.
3. **Computed filtering** — `useMessageActions` filters `reactiveList.items` based on `showOn` and sorts by `order ?? 200`.
4. **Cleanup** — `unregisterMessageAction` helps modules remove actions when disabled or disposed.

---

## Tips & edge cases

-   **ID collisions**: registering with an existing `id` overwrites the previous action; use `listRegisteredMessageActionIds()` to audit.
-   **Async handlers**: You can return promises; the caller decides whether to await or fire-and-forget.
-   **Context object**: `handler` receives `{ message, threadId }`; extend as needed but keep the shape consistent for plugin compatibility.
-   **Role filtering**: Use `showOn: 'both'` for universal actions (e.g., “pin”), otherwise scope to `user` or `assistant`.

---

## Related modules

-   `ChatMessage.vue` — built-in consumer that renders the buttons.
-   `useMessageEditing` — often paired to expose “Edit message” action.
-   `pane plugin API` — natural spot to add custom actions when a plugin activates.
</file>

<file path="composables/useMessageEditing.md">
# useMessageEditing

Encapsulates the UI + persistence flow for editing a chat message. Handles toggling edit mode, keeping a draft buffer, and writing the updated content back to Dexie.

---

## What it handles

`useMessageEditing` wraps all state required for an inline message editor:

-   Tracks whether the message is currently being edited
-   Keeps a draft copy of the text with undo (cancel) support
-   Persists the change to the `messages` table via `upsert`
-   Works with plain objects or `Ref`-wrapped messages (streaming tail vs finalized)

---

## Quick example

```ts
import { useMessageEditing } from '~/composables/chat/useMessageEditing';

const props = defineProps<{ message: UiChatMessage }>();
const editing = useMessageEditing(props.message);

function onSave() {
    editing.saveEdit();
}
```

In a template you can wire the state like this:

```vue
<template>
    <div v-if="editing.editing.value" class="message-editor">
        <textarea v-model="editing.draft.value" rows="3" class="retro-input" />
        <div class="flex gap-2 mt-2">
            <button
                class="retro-btn"
                :disabled="editing.saving.value"
                @click="editing.saveEdit"
            >
                Save
            </button>
            <button
                class="retro-btn"
                :disabled="editing.saving.value"
                @click="editing.cancelEdit"
            >
                Cancel
            </button>
        </div>
    </div>
    <div v-else>
        {{ props.message.text }}
        <button class="retro-btn" @click="editing.beginEdit">Edit</button>
    </div>
</template>
```

---

## API

| Property / Method | Type                  | Description                                                             |
| ----------------- | --------------------- | ----------------------------------------------------------------------- |
| `editing`         | `Ref<boolean>`        | `true` while the UI is in edit mode.                                    |
| `draft`           | `Ref<string>`         | Draft text bound to the editor input.                                   |
| `original`        | `Ref<string>`         | Snapshot of the message content before editing (used for cancel).       |
| `saving`          | `Ref<boolean>`        | `true` while the composable is persisting the update.                   |
| `beginEdit()`     | `() => void`          | Initialise draft/original values and switch to edit mode.               |
| `cancelEdit()`    | `() => void`          | Exit edit mode without saving, resetting buffers.                       |
| `saveEdit()`      | `() => Promise<void>` | Persist trimmed draft text to Dexie and update the live message object. |

### Message input contract

The `message` argument can be:

-   A `UiChatMessage` object with `text` and/or `content`
-   A `Ref` wrapping such an object (useful when the message swaps underneath, e.g., streaming tail to stored message)

`saveEdit()` writes the new text to both `content` and `text` if present so renderers stay in sync.

---

## Under the hood

1. **Message accessor** — `getMessage()` unwraps refs and returns the latest object before each action.
2. **Draft prep** — `beginEdit()` pulls the existing content from `message.content` or falls back to `message.text`.
3. **Persistence** — `saveEdit()` fetches the stored record via `db.messages.get(id)` and calls `upsert.message(...)` with the updated text and `updated_at` timestamp.
4. **State updates** — After persistence, it updates the in-memory message object so the UI reflects the new content immediately.
5. **Guard rails** — Empty drafts short-circuit to `cancelEdit()`. Missing IDs abort silently.

---

## Tips & edge cases

-   **Streaming messages**: Because it accepts refs, you can start editing a message that transitions from “tail” to finalized without losing the editor state.
-   **Concurrent edits**: `saving` prevents duplicate writes; external overrides should listen for `saving.value` before issuing new edits.
-   **No-op on blank**: Saving trims whitespace; if the result is empty it cancels instead of writing an empty record.
-   **Error handling**: Errors during persistence are caught by the `try/finally` block—state resets `saving` back to `false`, but you might want to wrap `saveEdit()` in a try/catch to display UI feedback.

---

## Related composables

-   `useMessageActions` — expose an “Edit” action that toggles this composable.
-   `useChat` — source of `UiChatMessage` records this composable edits.
-   `~/db/upsert` — the Dexie helper invoked during `saveEdit()`.
</file>

<file path="composables/useModelStore.md">
# useModelStore

Shared catalog + favorites manager for OpenRouter models. Centralises fetching, caching, and filtering so every pane sees the same list without repeated network hits.

---

## Responsibilities

`useModelStore` exposes reactive state for the model catalog, favorites, search query, and filters. It layers three cache tiers (memory → Dexie → network) and dedupes concurrent fetches. Consumers can refresh, invalidate, or persist favorites with a single call.

-   Hydrates catalog from memory, Dexie (`kv` table), or network
-   Persists the catalog in Dexie for 48 hours by default
-   Dedupes in-flight fetches across callers
-   Manages favorites with persistence to `kv`
-   Exposes helper refs for search/filter UI

---

## Quick start

```ts
import { useModelStore } from '~/composables/chat/useModelStore';

const {
    catalog,
    favoriteModels,
    fetchModels,
    addFavoriteModel,
    removeFavoriteModel,
    searchQuery,
    filters,
} = useModelStore();

await fetchModels();
searchQuery.value = 'claude';
await addFavoriteModel(catalog.value[0]);
```

---

## API

| Export                       | Type                                                                                                             | Description                                                       |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `catalog`                    | `Ref<OpenRouterModel[]>`                                                                                         | Reactive catalog of models.                                       |
| `favoriteModels`             | `Ref<OpenRouterModel[]>`                                                                                         | Models the user has favorited (persisted).                        |
| `searchQuery`                | `Ref<string>`                                                                                                    | Shared search string for UI components.                           |
| `filters`                    | `Ref<{ input?: string[]; output?: string[]; minContext?: number; parameters?: string[]; price?: PriceBucket; }>` | Reactive filter state.                                            |
| `lastLoadedAt`               | `Ref<number \| undefined>`                                                                                       | Timestamp (ms) of the most recent catalog load.                   |
| `fetchModels(opts?)`         | `(opts?: { force?: boolean; ttlMs?: number }) => Promise<OpenRouterModel[]>`                                     | Populate catalog using cache layers; respects TTL unless `force`. |
| `refreshModels()`            | `() => Promise<OpenRouterModel[]>`                                                                               | Shortcut for `fetchModels({ force: true })`.                      |
| `invalidate()`               | `() => Promise<void>`                                                                                            | Clear memory cache and delete Dexie entry.                        |
| `getFavoriteModels()`        | `() => Promise<OpenRouterModel[]>`                                                                               | Load favorites from `kv` into memory.                             |
| `addFavoriteModel(model)`    | `(model: OpenRouterModel) => Promise<void>`                                                                      | Append to favorites (deduped) and persist.                        |
| `removeFavoriteModel(model)` | `(model: OpenRouterModel) => Promise<void>`                                                                      | Remove favorite and persist.                                      |
| `clearFavoriteModels()`      | `() => Promise<void>`                                                                                            | Remove all favorites and persist.                                 |

Constants:

```ts
MODELS_CACHE_KEY = 'MODELS_CATALOG';
MODELS_TTL_MS = 48 * 60 * 60 * 1000; // 48 hours
```

---

## Usage patterns

### Populate a model picker

```ts
const { catalog, fetchModels, searchQuery, filters } = useModelStore();

await fetchModels();

const filteredModels = computed(() => {
    return catalog.value.filter((model) => {
        if (searchQuery.value && !model.id.includes(searchQuery.value)) {
            return false;
        }
        if (
            filters.value.price &&
            model.price?.bucket !== filters.value.price
        ) {
            return false;
        }
        return true;
    });
});
```

### Sync favorites to UI

```ts
const {
    favoriteModels,
    addFavoriteModel,
    removeFavoriteModel,
    getFavoriteModels,
} = useModelStore();

await getFavoriteModels();

function toggleFavorite(model: OpenRouterModel) {
    if (favoriteModels.value.some((m) => m.id === model.id)) {
        removeFavoriteModel(model);
    } else {
        addFavoriteModel(model);
    }
}
```

### Force-refreshing the catalog

```ts
const { refreshModels } = useModelStore();

await refreshModels(); // bypasses cache and hits the network
```

---

## Internals

1. **Singleton refs** — `catalog`, `favoriteModels`, `filters`, etc. live at module scope so every caller shares the same reactive data.
2. **Cache layers** — `fetchModels` tries memory first, then Dexie (if supported), then network. TTL is configurable per call.
3. **Dexie persistence** — Catalog is stored via `kv.set(MODELS_CACHE_KEY, JSON.stringify(list))`; timestamps come from `rec.updated_at` (seconds) and are compared against the TTL.
4. **In-flight dedupe** — Network fetches share a module-level `inFlight` promise so parallel callers await the same request.
5. **Favorites persistence** — Favorites use a separate `kv` key (`favorite_models`) and are stored as JSON.
6. **Error handling** — On network failure it attempts to serve stale Dexie data; JSON parse failures purge the corrupt record.

---

## Tips & edge cases

-   **IndexedDB availability**: `canUseDexie()` guards against SSR and private modes that block IndexedDB. If Dexie is unavailable, caching falls back to memory only.
-   **TTL overrides**: Pass `fetchModels({ ttlMs: 15 * 60 * 1000 })` to tighten freshness requirements for specific views.
-   **Favorites dedupe**: `addFavoriteModel` ignores duplicates by `model.id`.
-   **Invalidation**: After calling `invalidate()`, make sure to call `fetchModels()` again to repopulate memory.
-   **Persistent filters/search**: Since refs are shared, updating `searchQuery` in one component immediately affects others (intended for synchronized UI).

---

## Related modules

-   `models-service` — underlying fetcher for OpenRouter models.
-   `kv` helpers — Dexie-backed storage used for both catalog and favorites.
-   `useAiSettings` — may use this store to pick the default model.
</file>

<file path="composables/useMultiPane.md">
# useMultiPane

State manager that powers OR3’s multi-pane chat/document workspace. It keeps the active pane list, loads messages on demand, enforces pane limits, and fires hook events so plugins can react to pane lifecycle changes.

---

## What does it do?

`useMultiPane` centralises all window management logic outside the UI layer:

-   Creates, focuses, and closes panes with automatic fallback when the last pane would disappear
-   Loads chat message history for each pane (with Dexie-backed fallback)
-   Tracks the active pane index, preventing focus bugs
-   Emits hook events for pane open/close/switch so extensions stay in sync
-   Supports a configurable pane cap, custom message loaders, and document flush callbacks

---

## Basic Example

```ts
import { useMultiPane } from '~/composables/core/useMultiPane';

const multiPane = useMultiPane({ initialThreadId: 'thread-123', maxPanes: 4 });

multiPane.addPane();
await multiPane.setPaneThread(1, 'thread-456');
multiPane.setActive(1);
```

---

## How to use it

### 1. Create the store

```ts
const multiPane = useMultiPane({
    initialThreadId: '',
    maxPanes: 3,
    onFlushDocument: async (docId) => {
        await saveDraft(docId);
    },
});
```

### 2. Bind to UI

Use `multiPane.panes` to render your pane tabs and `multiPane.activePaneIndex` to highlight the current one. Buttons can call `addPane`, `closePane(i)`, or `setActive(i)`.

### 3. Load or switch chats

Hook `setPaneThread(index, threadId)` to any thread picker.

```ts
await multiPane.setPaneThread(activeIndex.value, selectedThreadId);
```

### 4. Keyboard shortcuts

`focusPrev(current)` and `focusNext(current)` make it easy to wire ⌥← / ⌥→ navigation.

### 5. Keep at least one pane alive

Call `ensureAtLeastOne()` if you manipulate `panes` directly (rare, but handy in dev tools).

---

## API

```ts
const multiPane = useMultiPane(options?: UseMultiPaneOptions);
```

| Option            | Type                                                | Description                                                      |
| ----------------- | --------------------------------------------------- | ---------------------------------------------------------------- |
| `initialThreadId` | `string`                                            | Starting thread for the first pane (empty string for new chat).  |
| `maxPanes`        | `number`                                            | Maximum simultaneous panes (default `3`).                        |
| `onFlushDocument` | `(id: string) => void \| Promise<void>`             | Called before closing a document pane so you can persist drafts. |
| `loadMessagesFor` | `(threadId: string) => Promise<MultiPaneMessage[]>` | Override message loader (defaults to Dexie query).               |

### Returned object

| Property / Method                | Type                                                 | Purpose                                                                 |
| -------------------------------- | ---------------------------------------------------- | ----------------------------------------------------------------------- |
| `panes`                          | `Ref<PaneState[]>`                                   | Reactive list of panes in open order.                                   |
| `activePaneIndex`                | `Ref<number>`                                        | Index of the currently focused pane.                                    |
| `canAddPane`                     | `ComputedRef<boolean>`                               | `true` when below `maxPanes`.                                           |
| `newWindowTooltip`               | `ComputedRef<string>`                                | Pre-baked tooltip text for “new pane” buttons.                          |
| `addPane()`                      | `() => void`                                         | Append a blank pane and focus it.                                       |
| `closePane(index)`               | `(index: number) => Promise<void> \| void`           | Close a pane; never removes the last one.                               |
| `setActive(index)`               | `(index: number) => void`                            | Mark a pane as focused, firing switch hooks.                            |
| `focusPrev(current)`             | `(current: number) => void`                          | Focus the previous pane if available.                                   |
| `focusNext(current)`             | `(current: number) => void`                          | Focus the next pane if available.                                       |
| `setPaneThread(index, threadId)` | `(index: number, threadId: string) => Promise<void>` | Load messages for a chat and attach it to the pane. Pass `''` to clear. |
| `loadMessagesFor`                | `(threadId: string) => Promise<MultiPaneMessage[]>`  | Exposed loader (useful for tests).                                      |
| `ensureAtLeastOne()`             | `() => void`                                         | Guarantees at least one pane exists.                                    |

`PaneState` consists of:

```ts
interface PaneState {
    id: string;
    mode: 'chat' | 'doc';
    threadId: string;
    documentId?: string;
    messages: MultiPaneMessage[];
    validating: boolean;
}
```

---

## Under the hood

1. **Pane creation** — `createEmptyPane()` generates a UUID (via `crypto.randomUUID` fallback) and seeds a blank chat pane.
2. **Message loading** — The default loader queries Dexie for non-deleted messages, normalises content/reasoning text, and returns a lightweight list suited for pane previews.
3. **Hooks integration** — Every major action (`open`, `close`, `switch`, `active`, `blur`, thread changes) dispatches hook events so plugins and side panels can respond.
4. **Focus logic** — `setActive` handles focus order, blur hooks, and ensures active index stays in range when panes close.
5. **Global exposure** — Stores the API on `globalThis.__or3MultiPaneApi` so extensions or devtools can orchestrate panes externally.

---

## Edge cases & tips

-   **Thread veto**: Filters registered on `ui.pane.thread:filter:select` can return `false` to block a thread switch.
-   **Document panes**: When `mode === 'doc'` and `documentId` is set, `closePane` calls `onFlushDocument` before removing the pane—use it to save unsaved edits.
-   **Pane limit**: `addPane()` silently no-ops once `maxPanes` is reached; pair with `canAddPane` to disable UI affordances.
-   **Hot reload**: On HMR the latest instance overwrites `__or3MultiPaneApi`, so developer tooling always hits the freshest store.
-   **Testing**: Pass `loadMessagesFor` to inject fixtures without touching Dexie.

---

## Related

-   `usePanePrompt` — tracks pending system prompts per pane.
-   `useChat` — main consumer of pane message state.
-   Hooks: `ui.pane.*` actions/filters documented in `docs/core-hook-map.md`.
</file>

<file path="composables/usePaneDocuments.md">
# usePaneDocuments

Pane-aware controller that lets the dashboard create or switch documents inside the multi-pane workspace. It glues `useDocumentsStore`, pane state, and hook events into two ergonomic methods.

---

## What does it do?

`usePaneDocuments({ panes, activePaneIndex, createNewDoc, flushDocument })` returns helpers that:

-   Create a fresh document in the active pane while flushing/releasing the previous one.
-   Switch the active pane to a different document, honouring hook vetoes and autosave semantics.
-   Emit `$hooks` actions (`ui.pane.doc:action:saved`, `:changed`) so listeners react to transitions.
-   Reuse `useDocumentState` + `releaseDocument` to keep autosave + memory management consistent.

---

## Basic Example

```ts
import { usePaneDocuments } from '~/composables/documents/usePaneDocuments';
import { useMultiPane } from '~/composables/core/useMultiPane';
import { newDocument, flush } from '~/composables/documents/useDocumentsStore';

const { panes, activePaneIndex } = useMultiPane();

const { newDocumentInActive, selectDocumentInActive } = usePaneDocuments({
    panes,
    activePaneIndex,
    createNewDoc: (initial) => newDocument(initial),
    flushDocument: (id) => flush(id),
});

await newDocumentInActive({ title: 'Meeting notes' });
await selectDocumentInActive(existingDocId);
```

---

## How to use it

### 1. Supply pane + document dependencies

-   `panes` / `activePaneIndex` come from `useMultiPane`.
-   `createNewDoc` should return `{ id }` for the newly created record.
-   `flushDocument` flushes staged changes for a given ID (usually `flush()` from `useDocumentsStore`).

### 2. Create a document in the active pane

`await newDocumentInActive(initial?)`:

-   Flushes + releases the currently bound doc (if any), emitting `ui.pane.doc:action:saved` when staged changes existed.
-   Creates the new record via `createNewDoc`.
-   Runs `ui.pane.doc:filter:select` filters, allowing plugins to veto/redirect.
-   Updates the pane (`mode = 'doc'`, sets `documentId`, clears chat state) and fires `ui.pane.doc:action:changed` with `{ created: true }` metadata.

### 3. Switch the active pane to another document

`await selectDocumentInActive(id)`:

-   Applies the same select filter to allow vetoes.
-   Flushes + saves pending edits on the current doc when switching away and emits the saved action if needed.
-   Releases the previous document state to free memory.
-   Updates the pane bindings and emits `ui.pane.doc:action:changed` with `reason: 'select'`.

### 4. Respect hook vetoes

If any filter returns `false`, both helpers abort without changing the pane. Use this to block navigation when validations fail.

---

## What you get back

| Method                          | Returns                                | Description                                                                                  |
| ------------------------------- | -------------------------------------- | -------------------------------------------------------------------------------------------- |
| `newDocumentInActive(initial?)` | `Promise<{ id: string } \| undefined>` | Creates a doc in the active pane; returns the record summary or `undefined` on failure/veto. |
| `selectDocumentInActive(id)`    | `Promise<void>`                        | Switches the active pane to `id`; no-op if vetoed or invalid.                                |

Both methods run asynchronously and should be awaited to ensure flushes complete before continuing.

---

## Under the hood

1. **Pane lookup** – Reads the current pane via `panes.value[activePaneIndex.value]`.
2. **Pending change detection** – Uses `useDocumentState()` to check `pendingTitle`/`pendingContent` before emitting saved events.
3. **Hooks integration** – Utilises `useHooks()` to call `applyFilters('ui.pane.doc:filter:select', ...)` and `doAction('ui.pane.doc:action:changed' | '...:saved')`.
4. **Memory cleanup** – Calls `releaseDocument(id, { flush: false })` after switching to avoid lingering TipTap trees.
5. **Resets chat state** – Clears `threadId` and `messages` when moving panes back to document mode.

---

## Edge cases & tips

-   **Null pane**: If no pane exists at the active index, helpers exit early.
-   **Duplicate select**: Selecting the already-active doc short-circuits after reset; no extra hook events fire.
-   **Error suppression**: Internal `try { ... } catch {}` blocks ensure hook misbehaviour doesn’t crash the UX—but you should still log within your own filters/actions.
-   **Testing**: You can stub `createNewDoc` / `flushDocument` to use in Vitest without hitting Dexie.

---

## Related

-   `useDocumentsStore` — provides `flush`, `releaseDocument`, and state inspection.
-   `useMultiPane` — pane state machine consumed by this helper.
-   `~/core/hooks/useHooks` — hook engine used for filters/actions.

---

## TypeScript

```ts
interface UsePaneDocumentsOptions {
    panes: Ref<MultiPaneState[]>;
    activePaneIndex: Ref<number>;
    createNewDoc: (initial?: { title?: string }) => Promise<{ id: string }>;
    flushDocument: (id: string) => Promise<void> | void;
}

interface UsePaneDocumentsApi {
    newDocumentInActive(initial?: {
        title?: string;
    }): Promise<{ id: string } | undefined>;
    selectDocumentInActive(id: string): Promise<void>;
}
```
</file>

<file path="composables/usePanePrompt.md">
# usePanePrompt

Tiny helper that tracks a “pending system prompt” per pane. It lets the UI stage a prompt that will be applied when the user creates their next thread in that pane.

---

## What does it do?

`usePanePrompt` exposes three functions backed by a reactive map:

-   `setPanePendingPrompt(paneId, promptId)` — stage a prompt identifier
-   `getPanePendingPrompt(paneId)` — read the pending prompt (if any)
-   `clearPanePendingPrompt(paneId)` — forget the association once it’s used

Because the backing store is reactive, other consumers can watch it for UI hints, and HMR/devtools expose the map for inspection.

---

## Basic Example

```ts
import {
    setPanePendingPrompt,
    getPanePendingPrompt,
    clearPanePendingPrompt,
} from '~/composables/core/usePanePrompt';

setPanePendingPrompt('pane-1', 'prompt-active-user');

const pending = getPanePendingPrompt('pane-1');
// => 'prompt-active-user'

clearPanePendingPrompt('pane-1');
```

---

## How to use it

### 1. Stage a prompt when the user picks one

When the prompt selector changes, call `setPanePendingPrompt(paneId, promptId)` so the next thread creation uses it.

### 2. Read before creating a thread

Inside your thread creation flow, read `getPanePendingPrompt(paneId)` and pass the ID to the chat builder if it exists.

### 3. Clear after applying

Once the system prompt is attached to the thread, call `clearPanePendingPrompt(paneId)` to avoid reusing it accidentally.

---

## API

```ts
setPanePendingPrompt(paneId: string, promptId: string | null): void;
getPanePendingPrompt(paneId: string): string | null | undefined;
clearPanePendingPrompt(paneId: string): void;
```

| Function                 | Description                                                                             |
| ------------------------ | --------------------------------------------------------------------------------------- |
| `setPanePendingPrompt`   | Store the prompt ID (or `null` to explicitly clear it).                                 |
| `getPanePendingPrompt`   | Return the stored ID, `null` if explicitly cleared, or `undefined` if it was never set. |
| `clearPanePendingPrompt` | Remove the key entirely from the map.                                                   |

The underlying map lives in a `reactive({})`, so Vue watchers/computed values respond to changes.

---

## Under the hood

1. Keeps a module-level reactive object `pendingByPane` keyed by pane ID.
2. Exported helpers mutate or read that map directly.
3. In dev mode, the map is exposed on `globalThis.__or3PanePendingPrompts` for debugging.

There’s no persistence; entries reset on full reload.

---

## Edge cases & tips

-   **`null` vs `undefined`**: A stored `null` means “explicitly cleared”, while `undefined` means nothing was ever set for that pane.
-   **No SSR concerns**: The composable uses in-memory state only; safe to import anywhere.
-   **Pane lifecycle**: When a pane closes, remember to call `clearPanePendingPrompt` if you want to drop staged prompts immediately.

---

## Related

-   `useMultiPane` — orchestrates pane state and is a natural place to call these helpers.
-   `useActivePrompt` — resolves prompt details once you have the ID.
-   Hooks `ui.pane.thread:action:changed` — good trigger for clearing pending prompts.
</file>

<file path="composables/usePreviewCache.md">
# usePreviewCache

In-memory LRU-ish cache for preview assets (images, PDFs, etc.). It wraps blob URL creation, tracks byte usage, exposes metrics, and handles eviction with pinning so priority previews stick around.

---

## What does it do?

`usePreviewCache` gives you a reusable cache instance that:

-   Normalises preview options via `resolvePreviewCacheOptions`
-   Provides `ensure()` to fetch or reuse cached URLs
-   Tracks hits/misses/evictions for telemetry
-   Supports pinning entries to avoid eviction while in view
-   Offers helpers to promote, release, drop, and flush entries

An additional `useSharedPreviewCache` exposes a singleton cache shared across the app.

---

## Basic Example

```ts
import { usePreviewCache } from '~/composables/core/usePreviewCache';

const cache = usePreviewCache({ maxUrls: 50, maxBytes: 50 * 1024 * 1024 });

const url = await cache.ensure('file:123', async () => {
    const blob = await fetchPreviewBlob();
    return { url: URL.createObjectURL(blob), bytes: blob.size };
});

img.src = url;
```

---

## How to use it

### 1. Create or grab the cache

```ts
const cache = useSharedPreviewCache();
// or
const cache = usePreviewCache({ maxUrls: 100, maxBytes: 80 * 1024 * 1024 });
```

### 2. Ensure previews exist

Call `ensure(key, loader, pin?)` to fetch or reuse a preview URL.

```ts
const url = await cache.ensure(hash, () => buildPreview(hash), 1);
```

### 3. Manage lifecycle

-   `promote(key)` when a preview becomes visible
-   `release(key)` when it scrolls off-screen
-   `drop(key)` or `flushAll()` to manually clear

### 4. Monitor usage

`cache.metrics()` reports counts and total bytes; `cache.logMetrics(stage)` dumps them to the console in dev builds.

---

## API

```ts
const cache = usePreviewCache(options?: Partial<PreviewCacheOptions>);
```

| Method          | Signature                                             | Description                                                                               |
| --------------- | ----------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| `ensure`        | `(key, loader, pin?) => Promise<string \| undefined>` | Return cached URL or call `loader()` to create one. Updates LRU data and enforces limits. |
| `promote`       | `(key, pin?) => void`                                 | Bump access counter and raise pin weight.                                                 |
| `release`       | `(key) => void`                                       | Lower pin count after a preview is no longer critical.                                    |
| `drop`          | `(key) => boolean`                                    | Remove a single entry and revoke the blob URL.                                            |
| `flushAll`      | `() => string[]`                                      | Remove every entry, returning the keys dropped.                                           |
| `evictIfNeeded` | `(stage?) => string[]`                                | Enforce `maxUrls`/`maxBytes`; returns evicted keys.                                       |
| `metrics`       | `() => PreviewCacheMetrics`                           | Snapshot of cache size, bytes, hits, misses, evictions.                                   |
| `logMetrics`    | `(stage) => void`                                     | Console log (dev only).                                                                   |
| `peek`          | `(key) => string \| undefined`                        | Read URL without mutating access counters.                                                |
| `options`       | `PreviewCacheOptions`                                 | Resolved options (max counts, etc.).                                                      |

`useSharedPreviewCache(overrides?)` returns a singleton instance; overrides only apply to the first call (later overrides warn in dev). `resetSharedPreviewCache()` flushes and clears the singleton reference.

---

## Under the hood

1. **Options resolution** — Merges partial overrides with defaults via `resolvePreviewCacheOptions`.
2. **Map storage** — Maintains a `Map<key, CacheEntry>` with metadata (`bytes`, `pin`, `lastAccess`).
3. **LRU eviction** — When limits are exceeded, entries sort by pin weight then `lastAccess`; unpinned, least-recent entries fall out first.
4. **Blob revocation** — `remove()` revokes object URLs via `URL.revokeObjectURL` to avoid leaks.
5. **Metrics** — Hits/misses/evictions counters increment inside `ensure()`/`evictIfNeeded()`; `metrics()` packages them for dashboards.

---

## Edge cases & tips

-   **Pinning**: `pin` is additive—pass higher numbers to make an item harder to evict (e.g., 2 for hero previews). Remember to `release`.
-   **Loader bytes**: If the loader omits `bytes`, the cache assumes `0`. Supplying the blob size keeps eviction accurate.
-   **Shared cache overrides**: Only the first call to `useSharedPreviewCache` respects overrides; later calls log a warning when options differ.
-   **Server-side rendering**: Safe to import, but loaders should guard against browser-only APIs (e.g., `URL.createObjectURL`).
-   **Diagnostics**: Call `logMetrics('stage-name')` in dev to trace eviction behavior.

---

## Related

-   `preview-cache` config (`~/config/preview-cache.ts`) — default limits and resolver.
-   `useWorkspaceBackup` — another heavy I/O composable that benefits from previews for status screens.
-   `useSharedPreviewCache` / `resetSharedPreviewCache` — exported alongside this composable for global cache reuse.
</file>

<file path="composables/useProjectsCrud.md">
# useProjectsCrud

Project CRUD toolkit that wraps Dexie helpers with validation, timestamping, and data normalisation for OR3 project records.

---

## What does it do?

`useProjectsCrud()` returns methods to create, rename, delete, and update projects:

-   `createProject` builds a new record with generated IDs, timestamps, and trimmed input.
-   `renameProject` validates titles and upserts updates.
-   `deleteProject` supports soft and hard delete flows.
-   `updateProjectEntries` replaces the project’s `data` array with normalised entries.
-   `syncProjectEntryTitle` propagates entry title/kind updates across every project reference.

Each helper uses the shared Dexie `db` instance under the hood.

---

## Basic Example

```ts
import { useProjectsCrud } from '~/composables/projects/useProjectsCrud';

const {
    createProject,
    renameProject,
    deleteProject,
    updateProjectEntries,
    syncProjectEntryTitle,
} = useProjectsCrud();

const projectId = await createProject({
    name: 'Design Sprint',
    description: 'Week-long challenge',
});

await renameProject(projectId, 'Design Sprint Q3');

await updateProjectEntries(projectId, [
    { id: 'doc-1', name: 'Brief', kind: 'doc' },
    { id: 'chat-8', name: 'AI brainstorm', kind: 'chat' },
]);

await deleteProject(projectId, { soft: true });
```

---

## How to use it

### 1. Instantiate once per setup

Call `const api = useProjectsCrud()` in composables or components. The returned methods are stateless and can be reused across calls.

### 2. Create projects

-   `createProject({ name, description?, id? })` trims input, generates defaults, and writes via `create.project`.
-   Returns the new project ID so you can navigate or open panes immediately.

### 3. Update metadata

-   `renameProject(id, name)` trims the new name and ensures the project exists before upserting.
-   `updateProjectEntries(id, entries)` clones the array before persisting to avoid mutating callers.

### 4. Delete projects

-   Soft delete (default) marks the record via `del.soft.project`.
-   Hard delete (`{ soft: false }`) removes it entirely via `del.hard.project`.

### 5. Sync linked entry titles

`syncProjectEntryTitle(entryId, kind, title)` iterates every project, normalises `data`, and updates matching entries—useful when a document/chat is renamed elsewhere.

---

## What you get back

`useProjectsCrud()` returns:

| Method                                        | Description                                                                           |
| --------------------------------------------- | ------------------------------------------------------------------------------------- |
| `createProject(input)`                        | Creates a project; throws if name missing. Returns new ID.                            |
| `renameProject(id, name)`                     | Renames an existing project; throws if not found or name empty.                       |
| `deleteProject(id, options?)`                 | Soft or hard deletes a project.                                                       |
| `updateProjectEntries(id, entries)`           | Replaces the project’s `data` array after cloning entries.                            |
| `syncProjectEntryTitle(entryId, kind, title)` | Updates matching entry names across all projects; returns number of projects touched. |

---

## Under the hood

1. **Dexie helpers** – Calls `create.project`, `upsert.project`, `del.soft.project`, `del.hard.project`, and `db.projects.bulkPut`.
2. **Timestamps** – Uses `nowSec()` for `created_at`/`updated_at`, ensuring consistent epoch seconds throughout the app.
3. **ID generation** – Defaults to `newId()` when callers omit `id`.
4. **Normalisation** – Clones entry objects and relies on `normalizeProjectData` to accommodate legacy formats.
5. **Bulk updates** – `syncProjectEntryTitle` batches writes with `bulkPut` to minimise Dexie transactions.

---

## Edge cases & tips

-   **Empty names**: Helpers throw if the provided name is blank after trimming—handle errors in your UI.
-   **Missing project**: `renameProject` and `updateProjectEntries` throw when `db.projects.get` can’t find the ID.
-   **Concurrent edits**: `clock` isn’t mutated here; if you rely on CRDT syncs, adjust the payload before calling `upsert`.
-   **Entry kind**: `syncProjectEntryTitle` supplies `kind` when missing so downstream UIs can rely on it.
-   **Soft delete recovery**: Soft-deleted records still exist; build admin tooling to restore if required.

---

## Related

-   `useProjectTreeActions` — UI actions for projects and their entries.
-   `~/utils/projects/normalizeProjectData` — ensures project `data` arrays follow the latest schema.
-   `~/db/projects` — Dexie schema and helper exports referenced here.

---

## TypeScript

```ts
interface CreateProjectInput {
    name: string;
    description?: string | null;
    id?: string;
}

interface DeleteProjectOptions {
    soft?: boolean;
}

type ProjectEntry = {
    id: string;
    name: string;
    kind?: ProjectEntryKind;
    [key: string]: any;
};

function useProjectsCrud(): {
    createProject(input: CreateProjectInput): Promise<string>;
    renameProject(id: string, name: string): Promise<void>;
    deleteProject(id: string, options?: DeleteProjectOptions): Promise<void>;
    updateProjectEntries(id: string, entries: ProjectEntry[]): Promise<void>;
    syncProjectEntryTitle(
        entryId: string,
        kind: ProjectEntryKind,
        title: string
    ): Promise<number>;
};
```
</file>

<file path="composables/useProjectTreeActions.md">
# useProjectTreeActions

Extensible action registry for the project tree sidebar. Lets plugins add context buttons to project rows or child entries (documents, chats) with ordering and visibility controls.

---

## What does it do?

`useProjectTreeActions` builds on the generic `createRegistry` utility to provide:

-   `registerProjectTreeAction()` to add or replace project tree actions.
-   `useProjectTreeActions()` to retrieve a reactive, sorted list of actions.
-   `unregisterProjectTreeAction()` for cleanup.
-   `listRegisteredProjectTreeActionIds()` to inspect current registrations.

Actions can target project roots, all rows, or specific child kinds (`chat`, `doc`) via `showOn` filters.

---

## Basic Example

```ts
import {
    registerProjectTreeAction,
    unregisterProjectTreeAction,
    useProjectTreeActions,
} from '~/composables/projects/useProjectTreeActions';

registerProjectTreeAction({
    id: 'custom:open-in-new-pane',
    icon: 'i-ph-squares-four',
    label: 'Open in new pane',
    order: 180,
    showOn: ['doc', 'chat'],
    async handler({ treeRow }) {
        if ('parentId' in treeRow) {
            await openEntryInFreshPane(treeRow.value);
        }
    },
});

const actions = useProjectTreeActions();

onScopeDispose(() => {
    unregisterProjectTreeAction('custom:open-in-new-pane');
});
```

---

## How to use it

### 1. Register an action

Call `registerProjectTreeAction()` when your plugin starts. Provide a unique `id`, Iconify `icon`, `label`, optional `order`, `showOn`, and an async-compatible `handler`.

### 2. Target specific rows

-   Omitting `showOn` shows the action everywhere.
-   Include `['root']` to limit to project rows.
-   Use `['doc']` or `['chat']` to target children representing documents or chat threads.

### 3. Handle the click

The handler receives `{ treeRow, child, root }`:

-   `treeRow` is always present and can be root or child.
-   `child` and `root` remain for legacy shapes—prefer `treeRow` moving forward.

### 4. Consume from the UI

`useProjectTreeActions()` returns a reactive array used by components like `SidebarProjectTree.vue`. You rarely call it yourself unless you render a custom tree UI.

### 5. Clean up

Call `unregisterProjectTreeAction()` during dispose to keep the registry tidy across HMR.

---

## API

```ts
registerProjectTreeAction(action: ProjectTreeAction): void;
unregisterProjectTreeAction(id: string): void;
useProjectTreeActions(): ComputedRef<ProjectTreeAction[]>;
listRegisteredProjectTreeActionIds(): string[];
```

---

## Under the hood

1. **Registry factory** – Uses `createRegistry('__or3ProjectTreeActionsRegistry')`, which already handles sorting, deduping, and reactivity.
2. **Ordering** – `createRegistry` sorts by `order` (default 200); ties fall back to registration order.
3. **HMR safe** – The registry lives on `globalThis`, so multiple imports share the same entries.
4. **Visibility filtering** – Consumers apply `showOn` checks before rendering buttons, ensuring minimal logic in handlers.

---

## Edge cases & tips

-   **Unknown `treeRow` shape**: Some legacy callers might pass `child`/`root`; guard your handler accordingly.
-   **Async errors**: Return promises and handle errors inside the handler—UI components don’t catch them automatically.
-   **Order collisions**: Use different `order` buckets to cluster your plugin’s actions together.
-   **Testing**: In Jest/Vitest, stub `createRegistry` with a local implementation if you want to isolate actual Dexie usage.

---

## Related

-   `useProjectsCrud` — manages the underlying Dexie project records.
-   `~/app/components/sidebar/SidebarProjectTree.vue` — consumes this registry to render contextual menus.
-   `~/utils/projects/normalizeProjectData` — helps keep tree rows consistent with stored data.

---

## TypeScript

```ts
type ProjectTreeKind = 'chat' | 'doc';
type ShowOnKind = 'root' | 'all' | 'chat' | 'doc';

interface ProjectTreeChild {
    value: string;
    label: string;
    icon?: string;
    kind?: ProjectTreeKind;
    parentId?: string;
    onSelect?: (e: Event) => void;
}

interface ProjectTreeRoot {
    value: string;
    label: string;
    defaultExpanded?: boolean;
    children?: ProjectTreeChild[];
    onSelect?: (e: Event) => void;
}

interface ProjectTreeAction {
    id: string;
    icon: string;
    label: string;
    order?: number;
    showOn?: ShowOnKind[];
    handler: (ctx: ProjectTreeHandlerCtx) => void | Promise<void>;
}
```
</file>

<file path="composables/useSidebarSearch.md">
# useSidebarSearch

Unified search composable that indexes threads, projects, and documents for the sidebar search bar. Uses Orama for fast client-side search with a substring fallback to guarantee results.

---

## What does it do?

`useSidebarSearch(threads, projects, documents)` returns reactive state and helpers that:

-   Build (and rebuild) a shared Orama index when underlying data changes.
-   Debounce queries (120 ms) and return results grouped by type.
-   Provide a substring fallback if Orama throws or returns zero hits.
-   Track readiness/busy states and expose a manual `rebuild()` + `runSearch()` API.

The composable mirrors the pattern established in `useThreadSearch` but spans multiple datasets.

---

## Basic Example

```ts
import { useSidebarSearch } from '~/composables/sidebar/useSidebarSearch';

const threads = useThreads();
const projects = useProjects();
const documents = useDocuments();

const { query, threadResults, projectResults, documentResults, ready, busy } =
    useSidebarSearch(threads, projects, documents);

watch(query, (value) => console.debug('Searching for', value));
```

---

## How to use it

### 1. Pass in reactive sources

Provide `Ref<Thread[]>`, `Ref<Project[]>`, and `Ref<Post[]>`. The composable watches for changes and rebuilds the index only when counts or `updated_at` signatures change.

### 2. Bind the query input

`query` is a writable `ref<string>`. Watch or v-model it in your search input. Typing triggers a debounced search.

### 3. Render grouped results

Use `threadResults`, `projectResults`, and `documentResults` to populate search dropdowns or grouped lists.

### 4. Handle readiness/loading

-   `ready` flips to `true` after the first successful index build.
-   `busy` reports when the index rebuild is in progress.

### 5. Manual maintenance

-   Call `rebuild()` to force an index rebuild (e.g., after external imports).
-   Call `runSearch()` to re-run the query without changing `query.value`.

---

## What you get back

`useSidebarSearch` returns:

| Property          | Type                  | Description                                        |
| ----------------- | --------------------- | -------------------------------------------------- |
| `query`           | `Ref<string>`         | Current search string.                             |
| `threadResults`   | `Ref<Thread[]>`       | Matching threads.                                  |
| `projectResults`  | `Ref<Project[]>`      | Matching projects.                                 |
| `documentResults` | `Ref<Post[]>`         | Matching documents (filtered to non-deleted docs). |
| `ready`           | `Ref<boolean>`        | `true` once the Orama index is built.              |
| `busy`            | `Ref<boolean>`        | `true` while rebuilding.                           |
| `rebuild`         | `() => Promise<void>` | Forces index rebuild.                              |
| `runSearch`       | `() => Promise<void>` | Runs search against current query.                 |

---

## Under the hood

1. **Document signature** – `computeSignature()` combines dataset counts + latest `updated_at` to decide when to rebuild.
2. **Orama index** – Builds a schema with `id`, `kind`, `title`, `updated_at`, and indexes all eligible records.
3. **ID maps** – Maintains `id → entity` dictionaries per kind for quick result mapping.
4. **Search pipeline** – Runs Orama search with limit 500. If no hits or an error occurs, falls back to case-insensitive substring matching.
5. **Debounce** – Uses a `setTimeout` to delay searches by 120 ms, mirroring other search composables.

---

## Edge cases & tips

-   **Empty query**: Returns full datasets (threads, projects, docs) instead of empty results.
-   **Deleted docs**: Filters out posts with `postType !== 'doc'` or `deleted === true` in both index build and fallback.
-   **Index rebuild storms**: The signature guard prevents redundant rebuilds even when watchers fire frequently.
-   **Fallback warning**: Logs a warning once (`[useSidebarSearch] fallback substring search used`) to aid debugging.
-   **Stale searches**: Uses incremental `lastQueryToken` to discard results from outdated async calls.

---

## Related

-   `useThreadSearch` — single-domain search the pattern was based on.
-   `~/core/search/orama` — shared Orama helpers (`createDb`, `buildIndex`, `searchWithIndex`).
-   `~/composables/sidebar/useSidebarSections` — consumer of the search results to display grouped lists.

---

## TypeScript

```ts
function useSidebarSearch(
    threads: Ref<Thread[]>,
    projects: Ref<Project[]>,
    documents: Ref<Post[]>
): {
    query: Ref<string>;
    threadResults: Ref<Thread[]>;
    projectResults: Ref<Project[]>;
    documentResults: Ref<Post[]>;
    ready: Ref<boolean>;
    busy: Ref<boolean>;
    rebuild: () => Promise<void>;
    runSearch: () => Promise<void>;
};
```
</file>

<file path="composables/useSidebarSections.md">
# useSidebarSections

Sidebar chrome registry that lets plugins add new panels (top/main/bottom stacks) and footer actions to the OR3 sidebar. Provides ordering, placement, visibility, and disabled control.

---

## What does it do?

`useSidebarSections` exposes two registries via the shared `_registry` factory:

-   Section registry: `registerSidebarSection()` / `useSidebarSections()` groups components by placement (`top`, `main`, `bottom`).
-   Footer action registry: `registerSidebarFooterAction()` / `useSidebarFooterActions()` manages button-style actions rendered in the sidebar footer.

Both registries share ordering semantics and dedupe logic.

---

## Basic Example

```ts
import {
    registerSidebarSection,
    unregisterSidebarSection,
    useSidebarSections,
    registerSidebarFooterAction,
    unregisterSidebarFooterAction,
} from '~/composables/sidebar/useSidebarSections';

registerSidebarSection({
    id: 'custom:tips',
    component: () => import('~/components/sidebar/TipsPanel.vue'),
    placement: 'bottom',
    order: 210,
});

registerSidebarFooterAction({
    id: 'custom:new-project',
    icon: 'i-ph-plus-circle',
    label: 'New Project',
    color: 'primary',
    handler: () => openNewProjectModal(),
});

const sections = useSidebarSections();
const footerActions = useSidebarFooterActions(() => ({
    activeThreadId: currentThreadId.value,
}));

onScopeDispose(() => {
    unregisterSidebarSection('custom:tips');
    unregisterSidebarFooterAction('custom:new-project');
});
```

---

## How to use it

### 1. Register sections

-   Provide a unique `id`, a Vue component (sync or async factory), optional `order`, and `placement`.
-   Default placement is `'main'`, which renders inside the primary scroll stack.
-   Sections are rendered as-is, so handle loading states internally for async components.

### 2. Register footer actions

-   Define Iconify `icon`, optional `label`, `tooltip`, `color`, and `order`.
-   `visible(ctx)` and `disabled(ctx)` let you tailor actions to the active thread/document or collapsed sidebar state.

### 3. Consume registries

-   `useSidebarSections()` returns a computed object `{ top, main, bottom }`, each sorted by `order`.
-   `useSidebarFooterActions(contextFn)` returns a computed array of `{ action, disabled }` entries based on the latest context.

### 4. Clean up

Call the matching `unregister*` helpers during scope disposal/HMR to prevent duplicates.

---

## What you get back

### Sections

`useSidebarSections()` → `ComputedRef<{ top: SidebarSection[]; main: SidebarSection[]; bottom: SidebarSection[] }>`

### Footer actions

`useSidebarFooterActions(contextFn)` → `ComputedRef<SidebarFooterActionEntry[]>`

Each `SidebarFooterActionEntry` contains the original action and `disabled` boolean.

---

## Under the hood

1. **Registry factory** – Uses `createRegistry('__or3SidebarSectionsRegistry')` and `createRegistry('__or3SidebarFooterActionsRegistry')`, which handle reactivity, sorting, and deduping.
2. **Default ordering** – Applies `order ?? 200` for deterministic placement relative to built-ins.
3. **Placement split** – The `useSidebarSections()` computed buckets entries by `placement` before sorting.
4. **Context evaluation** – Footer actions evaluate `visible`/`disabled` with the provided context function each render.

---

## Edge cases & tips

-   **Async components**: When `component` is a lazy import, Nuxt handles suspense; consider showing an internal loading indicator for better UX.
-   **Collapsed sidebar**: Use the `isCollapsed` flag inside footer action predicates to hide text-heavy buttons.
-   **Multiple registrations**: Re-registering with the same `id` replaces the previous entry—handy for overrides.
-   **Testing**: Mock `createRegistry` for deterministic unit tests.

---

## Related

-   `useHeaderActions` — header button registry sharing the same pattern.
-   `useComposerActions` — controls the chat composer quick actions.
-   `~/composables/_registry` — factory implementing the registry mechanics.

---

## TypeScript

```ts
type SidebarSectionPlacement = 'top' | 'main' | 'bottom';

interface SidebarSection extends RegistryItem {
    id: string;
    component: Component | (() => Promise<any>);
    order?: number;
    placement?: SidebarSectionPlacement;
}

type ChromeActionColor =
    | 'neutral'
    | 'primary'
    | 'secondary'
    | 'success'
    | 'warning'
    | 'error'
    | 'info'
    | 'inverse-primary'
    | (string & {});

interface SidebarFooterAction extends RegistryItem {
    id: string;
    icon: string;
    label?: string;
    tooltip?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: SidebarFooterActionContext) => void | Promise<void>;
    visible?: (ctx: SidebarFooterActionContext) => boolean;
    disabled?: (ctx: SidebarFooterActionContext) => boolean;
}
```
</file>

<file path="composables/useStreamAccumulator.md">
# useStreamAccumulator

Frame-batched accumulator for AI streaming tokens. It receives partial text/reasoning deltas, buffers them, and flushes at most once per animation frame so the UI stays smooth.

---

## Purpose

`useStreamAccumulator` replaces ad-hoc refs for building assistant responses. It normalises streaming flow with a single API:

-   `append()` collects text or reasoning deltas without immediate DOM churn
-   `finalize()` seals the stream and records errors/abort state
-   `reset()` prepares for the next stream
-   `state` exposes reactive fields (`text`, `reasoningText`, `isActive`, etc.) any component can watch

The accumulator automatically batches writes via `requestAnimationFrame` when available, falling back to microtasks in environments without rAF (tests, SSR stubs).

---

## Quick example

```ts
import { useStreamAccumulator } from '~/composables/chat/useStreamAccumulator';

const stream = useStreamAccumulator();

// Stream chunks coming from OpenRouter
stream.append('Hello', { kind: 'text' });
stream.append(', world!', { kind: 'text' });
stream.append('Considering user intent...', { kind: 'reasoning' });

// When the stream completes:
stream.finalize();

console.log(stream.state.text); // "Hello, world!"
```

---

## API

| Member                   | Type                                                                | Description                                                                                            |
| ------------------------ | ------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| `state`                  | `Readonly<StreamingState>`                                          | Reactive state object (see below).                                                                     |
| `append(delta, options)` | `(delta: string, options: { kind: 'text' \| 'reasoning' }) => void` | Queue a delta chunk for batching. Empty strings are ignored.                                           |
| `finalize(opts?)`        | `(opts?: { error?: Error; aborted?: boolean }) => void`             | Flush any pending chunks, mark the stream inactive/finalized, optionally capture an error. Idempotent. |
| `reset()`                | `() => void`                                                        | Cancel pending frames, clear buffers, and return the state to its initial active state.                |

### `StreamingState`

```ts
interface StreamingState {
    text: string;
    reasoningText: string;
    isActive: boolean;
    finalized: boolean;
    error: Error | null;
    version: number; // increments each flush for lightweight watchers
}
```

The composable exports `type UnifiedStreamingState = StreamingState` for consumers migrating from legacy code.

---

## Usage patterns

### Wiring into a stream handler

```ts
const accumulator = useStreamAccumulator();

async function handleChunk(chunk: StreamChunk) {
    if (chunk.type === 'text-delta') {
        accumulator.append(chunk.text, { kind: 'text' });
    } else if (chunk.type === 'reasoning-delta') {
        accumulator.append(chunk.reasoning, { kind: 'reasoning' });
    }
}

function handleComplete(error?: Error) {
    accumulator.finalize(error ? { error } : undefined);
}
```

### Reacting to flushes

```ts
watch(
    () => accumulator.state.version,
    () => {
        latestText.value = accumulator.state.text;
    }
);
```

### Reusing for multiple responses

```ts
accumulator.reset();
// start next stream by calling append() again
```

---

## Internals

1. **Batching** — Deltas are stored in `pendingMain` / `pendingReasoning` arrays until `flush()` concatenates and appends to `state`. `flush()` runs via rAF; if unavailable, a cancelable microtask is used.
2. **Idempotent finalize** — Calls after the first are no-ops (with dev warnings). `finalize()` cancels scheduled frames, flushes remaining buffers, flips `isActive` false, marks `finalized`, and sets `error` when provided.
3. **Reset logic** — Cancels pending frames/microtasks, clears buffers, resets state values, and bumps `version` so watchers notice the reset.
4. **Empty delta guard** — Ignores empty strings and warns (up to three times in dev) to highlight upstream tokenization issues.
5. **Environment-safe** — `getRAF()` / `getCAF()` resolve lazily so tests can stub them; SSR falls back to `setTimeout`.

---

## Tips & edge cases

-   **Multiple consumers**: `state` is reactive; share it across components without additional refs.
-   **Abort semantics**: Pass `finalize({ aborted: true })` if the stream was cancelled. Downstream UI can infer this from `state.isActive === false && state.finalized === true` plus the `aborted` flag you track externally.
-   **Error path**: Provide `finalize({ error })` to surface issues; UI can render the error based on `state.error`.
-   **Reset before reuse**: Always call `reset()` before starting another stream on the same accumulator.
-   **Performance**: Because flushing happens ≤ once per frame, high-frequency streams won’t thrash the DOM even when chunks arrive rapidly.

---

## Related modules

-   `useChat` — consumes this accumulator to build assistant messages.
-   Legacy `useTailStream` — superseded by this composable.
-   Streaming infrastructure in `~/core` — responsible for turning OpenRouter SSE events into `append()` calls.
</file>

<file path="composables/useThreadHistoryActions.md">
# useThreadHistoryActions

Registry for adding custom actions to the thread history sidebar dropdown. Mirrors the document history registry but targets threads, letting plugins inject export, share, or workflow buttons.

---

## What does it do?

`useThreadHistoryActions` exposes:

-   `registerThreadHistoryAction()` / `unregisterThreadHistoryAction()` to manage action lifecycle.
-   `useThreadHistoryActions()` to read a sorted, reactive list of actions for rendering.
-   `listRegisteredThreadHistoryActionIds()` for debugging or collision checks.

Actions are stored globally on `globalThis`, so they persist across HMR and shared imports.

---

## Basic Example

```ts
import {
    registerThreadHistoryAction,
    unregisterThreadHistoryAction,
    useThreadHistoryActions,
} from '~/composables/threads/useThreadHistoryActions';

registerThreadHistoryAction({
    id: 'custom:export-thread',
    icon: 'i-ph-cloud-arrow-down',
    label: 'Export Thread',
    order: 210,
    async handler({ document }) {
        await exportThread(document.id);
    },
});

const actions = useThreadHistoryActions();

onScopeDispose(() => {
    unregisterThreadHistoryAction('custom:export-thread');
});
```

---

## How to use it

### 1. Register actions when your plugin loads

-   Namespace IDs (`my-plugin:action`) to avoid collisions.
-   Provide `icon`, `label`, optional `order`, and a `handler` receiving `{ document: Thread }`.

### 2. Consume the computed list

-   Components like `SidebarThreadHistory.vue` call `useThreadHistoryActions()` to obtain sorted actions.
-   The returned array is already sorted by `order` (default 200) so you can render directly.

### 3. Cleanup for HMR

-   Call `unregisterThreadHistoryAction()` (or wrap registration in `useHookEffect`) to keep the registry tidy during hot reloads.

### 4. Handle async operations

-   `handler` can be async; manage toasts/loading in your own logic.

---

## What you get back

`useThreadHistoryActions()` → `ComputedRef<ThreadHistoryAction[]>` where each action includes:

| Property  | Type                                 | Description                              |
| --------- | ------------------------------------ | ---------------------------------------- | --------------- |
| `id`      | `string`                             | Unique identifier.                       |
| `icon`    | `string`                             | Iconify name to display in the dropdown. |
| `label`   | `string`                             | Action text shown next to the icon.      |
| `order`   | `number \| undefined`                | Sorting hint (default 200).              |
| `handler` | `(ctx: { document: Thread }) => void | Promise<void>`                           | Click callback. |

---

## Under the hood

1. **Global registry** – Uses `globalThis.__or3ThreadHistoryActionsRegistry` so multiple imports share the same entries.
2. **Reactive mirror** – Maintains `reactiveList.items` for Vue to track updates without making the map reactive.
3. **Sorting** – The computed accessor sorts by `order` each time, keeping render order deterministic.
4. **HMR-safe** – Overwriting the same ID just replaces the entry; dev warnings can be added similarly to other registries if needed.

---

## Edge cases & tips

-   **Duplicate IDs**: Last registration wins. Use `listRegisteredThreadHistoryActionIds()` to inspect the registry.
-   **Missing thread**: Ensure components pass the correct `Thread` to handlers; the registry doesn’t enforce schema.
-   **Async errors**: Catch and surface toast messages yourself—the registry doesn’t handle failure reporting.
-   **Order buckets**: Follow the convention (built-ins ~100–150, extensions ≥200) for predictable placement.

---

## Related

-   `useDocumentHistoryActions` — sister registry for documents.
-   `useThreadSearch` — locate threads for history UI.
-   `~/app/components/sidebar/ThreadHistory.vue` — consumes this registry to render dropdown actions.

---

## TypeScript

```ts
interface ThreadHistoryAction {
    id: string;
    icon: string;
    label: string;
    order?: number;
    handler: (ctx: { document: Thread }) => void | Promise<void>;
}
```
</file>

<file path="composables/useThreadSearch.md">
# useThreadSearch

Thread-specific search composable that powers the sidebar query field. Builds a small Orama index over thread titles, debounces input, and falls back to substring matching when required.

---

## What does it do?

`useThreadSearch(threads)` delivers:

-   A writable `query` ref bound to the search input.
-   A reactive `results` list kept in sync with Orama hits or substring fallback.
-   Automatic index rebuilds when the thread collection grows or shrinks.
-   Debounced searches (120 ms) to avoid excessive recomputation.
-   Convenience helpers (`rebuild`, `runSearch`) plus ready/busy flags.

---

## Basic Example

```ts
import { useThreadSearch } from '~/composables/threads/useThreadSearch';

const threads = useThreads(); // Ref<Thread[]>

const { query, results, ready, busy, rebuild } = useThreadSearch(threads);

watch(results, (list) => console.debug('Thread matches', list.length));

// Force rebuild after an import
await rebuild();
```

---

## How to use it

### 1. Pass a reactive thread array

Provide a `Ref<Thread[]>`. The composable rebuilds the index whenever the array length changes. For title-only edits, call `rebuild()` manually.

### 2. Bind `query`

Use `v-model="query.value"` (or simply `v-model="query"`) on your search input. Typing triggers debounced searches; clearing it restores the full thread list.

### 3. Render `results`

Loop over `results.value` to render matches ordered by relevance or fallback order.

### 4. Observe status

-   `ready.value` becomes `true` after the first successful index build.
-   `busy.value` is `true` while an index rebuild is in flight.

### 5. Control manually when needed

Call `await rebuild()` before heavy operations, or `await runSearch()` to refresh results after custom filters.

---

## What you get back

| Property    | Type                  | Description                        |
| ----------- | --------------------- | ---------------------------------- |
| `query`     | `Ref<string>`         | Current search string.             |
| `results`   | `Ref<Thread[]>`       | Matching threads.                  |
| `ready`     | `Ref<boolean>`        | Indicates the index is built.      |
| `busy`      | `Ref<boolean>`        | `true` when rebuilding the index.  |
| `rebuild`   | `() => Promise<void>` | Forces index rebuild.              |
| `runSearch` | `() => Promise<void>` | Runs search for the current query. |

---

## Under the hood

1. **Index build** — Uses `createDb`/`buildIndex` from `~/core/search/orama` with schema `{ id, title, updated_at }`.
2. **ID map** — Maintains an `id → Thread` dictionary for quick hit resolution.
3. **Debounce** — Delays `runSearch()` by 120 ms after each query change via `setTimeout`.
4. **Fallback** — If Orama returns zero hits or throws, filters by `title.toLowerCase().includes(query)` and logs a warning once.
5. **Stale guard** — Uses `lastQueryToken` to ignore late async responses when queries change quickly.

---

## Edge cases & tips

-   **Untitled threads**: Empty titles default to `'Untitled Thread'` before indexing, so they still appear.
-   **Empty query**: Returns the full thread list to mirror the sidebar UX.
-   **Large datasets**: Increase the search limit in the composed call if you need more than 200 hits.
-   **SSR**: Safe to import on the server; the index only builds on the client when watchers run.

---

## Related

-   `useSidebarSearch` — multi-entity search that also covers projects and documents.
-   `useThreadHistoryActions` — companion registry for thread dropdown actions.
-   `~/core/search/orama` — shared Orama helpers used throughout the app.

---

## TypeScript

```ts
function useThreadSearch(threads: Ref<Thread[]>): {
    query: Ref<string>;
    results: Ref<Thread[]>;
    ready: Ref<boolean>;
    busy: Ref<boolean>;
    rebuild: () => Promise<void>;
    runSearch: () => Promise<void>;
};
```
</file>

<file path="composables/useWorkspaceBackup.md">
# useWorkspaceBackup

Full-featured workspace export/import controller for OR3. It coordinates Dexie exports, streaming backups, progress reporting, hook telemetry, and error handling so the UI can offer reliable backup workflows.

---

## What does it do?

`useWorkspaceBackup` manages every stage of backing up and restoring the local database:

-   Streams workspace exports to the File System Access API or StreamSaver fallback
-   Peeks backup files to surface metadata before import (format, table counts, etc.)
-   Imports backups in “replace” or “append” modes, with optional value overwrites
-   Tracks progress, step state, and errors in reactive refs for real-time UI updates
-   Dispatches hook events for extension telemetry and clean integrations

---

## Basic Example

```ts
import { useWorkspaceBackup } from '~/composables/core/useWorkspaceBackup';

const backup = useWorkspaceBackup();

async function exportNow() {
    await backup.exportWorkspace();
}

async function importFile(file: File) {
    await backup.peekBackup(file); // show metadata & ask user
    await backup.importWorkspace(file);
}
```

---

## How to use it

### 1. Create the composable

```ts
const backup = useWorkspaceBackup();
const { state } = backup;
```

`state` contains refs for loading indicators, progress bars, metadata, and errors—bind them straight into your component.

### 2. Export workflow

1. Call `backup.exportWorkspace()` in response to “Export” action.
2. Observe `state.isExporting`, `state.progress`, and `state.currentStep` for UI feedback.
3. On success, `currentStep` becomes `'done'`; reset the form with `backup.reset()` if you want to start fresh.

### 3. Inspect a backup file

1. Prompt the user for a file.
2. Call `await backup.peekBackup(file)`.
3. Read `state.backupMeta` (tables, counts) and `state.backupFormat` (`'stream'` or `'dexie'`).
4. Let the user choose `state.importMode` (`'replace' | 'append'`) and `state.overwriteValues` if appending.

### 4. Import workflow

1. Call `await backup.importWorkspace(file)`.
2. Watch `state.isImporting`, `state.progress`, and `state.currentStep`.
3. On completion, the composable fires `workspace:reloaded` hook so downstream stores can refresh.

### 5. Error handling

If any step fails, `state.error` holds an `AppError`. Show `state.currentStep === 'error'` to display a retry prompt. `backup.reset()` clears the state.

---

## API

```ts
const backup = useWorkspaceBackup();
```

### Returned object

| Property / Method       | Type                            | Description                                             |
| ----------------------- | ------------------------------- | ------------------------------------------------------- |
| `state`                 | `WorkspaceBackupState`          | Reactive refs for UI (see table below).                 |
| `exportWorkspace()`     | `() => Promise<void>`           | Streams the database to disk. No-op if already running. |
| `peekBackup(file)`      | `(file: Blob) => Promise<void>` | Reads metadata and sets `backupMeta`/`backupFormat`.    |
| `importWorkspace(file)` | `(file: Blob) => Promise<void>` | Imports according to `importMode`/`overwriteValues`.    |
| `reset()`               | `() => void`                    | Clears status flags, metadata, and errors.              |

### `WorkspaceBackupState`

| Ref               | Type                | Purpose                                              |
| ----------------- | ------------------- | ---------------------------------------------------- | ----------------------------------------------- | ------------------------------------------- | ----------- | ------ | --------- | -------------------------- |
| `isExporting`     | `Ref<boolean>`      | `true` while an export is in progress.               |
| `isImporting`     | `Ref<boolean>`      | `true` while an import is running.                   |
| `progress`        | `Ref<number>`       | 0–100 progress percentage.                           |
| `currentStep`     | `Ref<'idle'         | 'peeking'                                            | 'confirm'                                       | 'importing'                                 | 'exporting' | 'done' | 'error'>` | High-level step indicator. |
| `importMode`      | `Ref<'replace'      | 'append'>`                                           | Import strategy the user selected.              |
| `overwriteValues` | `Ref<boolean>`      | When appending, whether to replace conflicting rows. |
| `backupMeta`      | `Ref<ImportMetadata | null>`                                               | Metadata discovered during `peekBackup`.        |
| `backupFormat`    | `Ref<'stream'       | 'dexie'                                              | null>`                                          | Format derived from peek or auto-detection. |
| `error`           | `Ref<AppError       | null>`                                               | Last failure captured for UI display/reporting. |

`ImportMetadata` contains the Dexie database name/version plus table stats so you can present them to the user.

---

## Under the hood

1. **Module-level loaders** — Lazily imports `dexie-export-import` and `streamsaver` the first time they’re needed, caching promises for reuse.
2. **Export path** — Prefers the File System Access API (`showSaveFilePicker`) when available; otherwise falls back to StreamSaver with service worker shim. Progress is tracked by table/row counts from `streamWorkspaceExport` helpers.
3. **Peek** — Detects backup format by sniffing the file header. Dexie backups use `dexie-export-import`’s `peakImportFile`; stream backups parse the header line for metadata validation.
4. **Import** — Chooses between streaming import (`importWorkspaceStream`) and Dexie import (`importInto`). Appends respect `overwriteValues`; replace mode wipes tables first.
5. **Hooks** — Emits `workspace.backup.*` actions (`before`, `after`, `error`, `cancelled`) at each stage, plus `workspace:reloaded` after a successful import so other stores can resync.
6. **Error handling** — Wraps failures in `asAppError`, logs via `reportError`, and stores them in `state.error` with domain/action tags.

---

## Edge cases & tips

-   **Browser-only**: Every major action checks for `window`. In SSR contexts the composable will set an error explaining the limitation.
-   **Abort handling**: If the user cancels a save picker, the export resets to idle without surfacing an error.
-   **Version checks**: Both Dexie and stream imports validate database name/version; importing something from a newer schema raises a clear error.
-   **Chunk sizing**: Streaming exports use `STREAM_CHUNK_SIZE = 500` rows; Dexie imports default to ~1 MB chunks (`DEFAULT_KILOBYTES_PER_CHUNK`). Adjust in utilities if you need different throughput.
-   **Overwrite semantics**: In append mode, `overwriteValues` lets you merge data without wiping tables—set it via UI toggle before calling `importWorkspace`.
-   **Cleanup**: Call `reset()` after successful operations if you want to start a new flow without refreshing the page.

---

## Related

-   `~/utils/workspace-backup-stream.ts` — Implements the streaming codec used here.
-   `usePreviewCache` — Pair with this composable to manage heavy preview blobs alongside exports.
-   Hook reference in `docs/core-hook-map.md` — Lists the backup-related hooks emitted during each stage.
</file>

<file path="database/attachments.md">
# attachments

Attachment table helpers for creating, updating, and deleting upload metadata with full hook coverage.

---

## What does it do?

-   Validates attachment payloads against `AttachmentCreateSchema`/`AttachmentSchema`.
-   Pipes all mutations through `dbTry` so quota and Dexie errors surface with contextual toasts.
-   Fires hook filters/actions around create, upsert, soft delete, hard delete, and reads.
-   Provides `nowSec()` driven soft delete flagging so rows stay recoverable until hard-deleted.

---

## Data shape

| Field        | Type      | Notes                                                |
| ------------ | --------- | ---------------------------------------------------- |
| `id`         | `string`  | Primary key supplied by caller.                      |
| `type`       | `string`  | Attachment type tag (image/pdf/etc).                 |
| `name`       | `string`  | Display name.                                        |
| `url`        | `string`  | Blob/object URL or remote link. Must be a valid URL. |
| `created_at` | `number`  | Unix timestamp (sec). Auto-defaulted by schema.      |
| `updated_at` | `number`  | Unix timestamp (sec). Auto-defaulted by schema.      |
| `deleted`    | `boolean` | Soft delete flag toggled by `softDeleteAttachment`.  |
| `clock`      | `number`  | Monotonic revision counter.                          |

---

## API surface

| Function               | Signature                                          | Description                                              |
| ---------------------- | -------------------------------------------------- | -------------------------------------------------------- | ----------------------------------------------------- |
| `createAttachment`     | `(input: AttachmentCreate) => Promise<Attachment>` | Filter + validate + insert new attachment row.           |
| `upsertAttachment`     | `(value: Attachment) => Promise<void>`             | Filter + validate + replace existing attachment.         |
| `softDeleteAttachment` | `(id: string) => Promise<void>`                    | Marks an attachment as deleted and bumps `updated_at`.   |
| `hardDeleteAttachment` | `(id: string) => Promise<void>`                    | Removes the row outright (no blob storage handled here). |
| `getAttachment`        | `(id: string) => Promise<Attachment                | undefined>`                                              | Reads a single attachment and applies output filters. |

---

## Hook points

-   `db.attachments.create:filter:input` → mutate incoming payloads before validation.
-   `db.attachments.create:action:before/after`
-   `db.attachments.upsert:filter:input` + matching before/after actions.
-   `db.attachments.delete:action:soft:*` and `db.attachments.delete:action:hard:*` fire during deletes.
-   `db.attachments.get:filter:output` lets consumers normalize read results.

---

## Usage tips

-   Always supply a `clock` increment when calling `upsertAttachment`; schema enforces numeric clocks.
-   Soft deletes keep the blob data available; schedule `hardDeleteAttachment` when you want to reclaim disk.
-   Extend hooks to inject signed URLs or sanitize file names before persistence.
</file>

<file path="database/branching.md">
# branching

Utilities for forking threads, retry-branching assistant replies, and building merged conversation contexts across Dexie tables.

---

## What does it do?

-   Provides `forkThread`, `retryBranch`, and `buildContext` helpers that run inside Dexie transactions.
-   Normalizes branch modes (`reference` vs `copy`) and message roles for consistent downstream handling.
-   Clones ancestor messages when in copy mode and keeps indexes dense.
-   Merges ancestor + local messages for context building while respecting hook-driven filtering.

---

## Key types

| Type                             | Description                                                                 |
| -------------------------------- | --------------------------------------------------------------------------- |
| `ForkMode`                       | Alias of `BranchMode` (either `'reference'` or `'copy'`).                   |
| `ForkThreadParams`               | Required `sourceThreadId`, `anchorMessageId`, optional mode/title override. |
| `RetryBranchParams`              | Assistant message to branch from plus optional mode/title.                  |
| `BranchForkBeforePayload`        | Hook payload describing source thread, anchor message, and options.         |
| `MessageEntity` / `ThreadEntity` | Lightweight shapes passed through the hook engine.                          |

---

## API surface

| Function       | Signature                                                                                   | Description                                                                           |
| -------------- | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| `forkThread`   | `({ sourceThreadId, anchorMessageId, mode, titleOverride }) => Promise<{ thread, anchor }>` | Forks a thread at a specific message, optionally copying ancestor messages.           |
| `retryBranch`  | `({ assistantMessageId, mode, titleOverride }) => Promise<{ thread, anchor }>`              | Finds the preceding user message and delegates to `forkThread`.                       |
| `buildContext` | `({ threadId }) => Promise<Message[]>`                                                      | Builds the playable context for a thread, stitching ancestors for reference branches. |

---

## Hook integration

-   `branch.fork:filter:options` to mutate incoming fork parameters.
-   `branch.fork:action:before/after` around thread creation.
-   `branch.retry:*` sequence around retry-based forks.
-   `branch.context:filter:messages` lets extensions rewrite the merged entity list before final merging.

---

## Implementation notes

1. **Transactions** — Forking and context building happen within Dexie transactions touching `threads` and `messages` tables to avoid race conditions.
2. **Indexing** — Copied messages normalize indexes starting at `0` to keep order stable in fresh forks.
3. **Role normalization** — Any non-assistant/system role becomes `user` so AI context stays predictable.
4. **Perf** — `buildContext` batches ancestor and local queries in parallel and dedupes via `Map` before merging.

---

## Usage tips

-   Use `mode: 'copy'` when you need historical messages physically duplicated for offline tweaks; otherwise the cheaper reference mode keeps storage down.
-   Customize `branch.fork:filter:options` to auto-name forks (e.g., prepend emoji or include anchor timestamp).
-   When building custom prompts, call `buildContext` to get the exact message list that the composer expects.
</file>

<file path="database/client.md">
# client

Dexie database client that defines the `Or3DB` schema, typed tables, and versioning rules.

---

## What does it do?

-   Establishes the single IndexedDB database named `or3-db`.
-   Declares typed `Dexie.Table` instances for every entity (projects, threads, messages, etc.).
-   Collapses historical migrations into version `5` so existing installs stay compatible without upgrade churn.

---

## Tables & indexes

| Table         | Primary key | Secondary indexes                                                                                                                                                       |
| ------------- | ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `projects`    | `id`        | `name`, `clock`, `created_at`, `updated_at`                                                                                                                             |
| `threads`     | `id`        | `[project_id+updated_at]`, `parent_thread_id`, `[parent_thread_id+anchor_index]`, `status`, `pinned`, `deleted`, `last_message_at`, `clock`, `created_at`, `updated_at` |
| `messages`    | `id`        | `[thread_id+index]`, `thread_id`, `index`, `role`, `deleted`, `stream_id`, `clock`, `created_at`, `updated_at`                                                          |
| `kv`          | `id`        | `&name`, `clock`, `created_at`, `updated_at`                                                                                                                            |
| `attachments` | `id`        | `type`, `name`, `clock`, `created_at`, `updated_at`                                                                                                                     |
| `file_meta`   | `hash`      | `[kind+deleted]`, `mime_type`, `clock`, `created_at`, `updated_at`                                                                                                      |
| `file_blobs`  | `hash`      | (none)                                                                                                                                                                  |
| `posts`       | `id`        | `title`, `postType`, `deleted`, `created_at`, `updated_at`                                                                                                              |

> ℹ️ `file_blobs` stores raw Binary Large Objects; the rest are JSON-like metadata rows.

---

## Usage

```ts
import { db } from '~/app/db';

await db.open();
const allThreads = await db.threads.toArray();
```

-   Prefer the higher-level modules (`threads.ts`, `messages.ts`, etc.) for business logic and hook coverage.
-   Only change the schema via `this.version(<next>).stores({...})` and bump the version number; ensure you migrate existing data when necessary.

---

## Versioning tips

-   Keep version pegged at `5` until you add columns or indexes. When you bump, implement Dexie upgrade paths to migrate data.
-   Since older migrations were consolidated, new changes should avoid breaking existing user stores—plan upgrades carefully.
</file>

<file path="database/dbTry.md">
# dbTry

Thin error-handling wrapper around Dexie calls that surfaces quota issues and standardizes error metadata.

---

## What does it do?

-   Executes a provided function and traps IndexedDB quota exceptions.
-   Emits toast-friendly `ERR_DB_QUOTA_EXCEEDED` errors with guidance text.
-   Tags all other failures as `ERR_DB_READ_FAILED`/`ERR_DB_WRITE_FAILED` and forwards them to `reportError`.
-   Optionally rethrows after logging when `opts.rethrow` is true.

---

## API

```ts
dbTry<T>(fn: () => Promise<T> | T, tags: DbTryTags, opts?: { rethrow?: boolean }): Promise<T | undefined>
```

| Parameter      | Type                | Notes                                                          |
| -------------- | ------------------- | -------------------------------------------------------------- | ------------------------------------------- |
| `fn`           | `() => Promise<T>  | T`                                                             | Database action to execute.                 |
| `tags`         | `{ op: 'read'       | 'write'; entity?: string; ... }`                               | Required tags used for logging/diagnostics. |
| `opts.rethrow` | `boolean`           | When `true`, the original exception is rethrown after logging. |

Returns the function result (possibly `undefined` when suppressed) or `undefined` if an error was swallowed.

---

## Constants

-   `DB_QUOTA_GUIDANCE` — UI-friendly message instructing users to clear space when storage quota is exceeded.

---

## When to use

-   Wrap all Dexie reads/writes that could hit quota or data corruption.
-   Pair with `{ rethrow: true }` when the caller cannot recover (e.g., creation flows) so upstream can surface precise failures.

---

## Error tagging

-   Adds `domain: 'db'` and `rw: tags.op` so hooks/devtools can filter DB-related errors.
-   Quota failures set `retryable: false`; other failures remain retryable to allow user retriggering.
</file>

<file path="database/documents.md">
# documents

Document storage built on the shared `posts` table (`postType: 'doc'`) with TipTap JSON payloads and hook integration.

---

## What does it do?

-   Serializes rich-text documents into the `posts` table without introducing a new Dexie store.
-   Surfaces CRUD helpers that parse/merge content and titles through hook filters.
-   Provides soft- and hard-delete paths, plus a small `ensureDbOpen` helper used by feature modules.

---

## Data structures

| Row              | Field              | Meaning                                                  |
| ---------------- | ------------------ | -------------------------------------------------------- |
| `DocumentRow`    | `content: string`  | Raw JSON string persisted in Dexie.                      |
|                  | `postType`         | Always `'doc'`; used to discriminate from prompts/posts. |
|                  | `deleted: boolean` | Soft delete flag toggled via `softDeleteDocument`.       |
| `DocumentRecord` | `content: any`     | Parsed TipTap JSON returned to callers.                  |

---

## API surface

| Function                    | Description                                                                                |
| --------------------------- | ------------------------------------------------------------------------------------------ |
| `createDocument(input?)`    | Validates title/content, runs hooks, writes a new row, returns parsed record.              |
| `getDocument(id)`           | Loads a single document, applies output filters, returns parsed record.                    |
| `listDocuments(limit?)`     | Fetches non-deleted docs, sorts by `updated_at` desc, slices to limit, applies filters.    |
| `updateDocument(id, patch)` | Re-resolves titles/content, fires before/after hooks, persists and returns updated record. |
| `softDeleteDocument(id)`    | Marks `deleted: true` and bumps `updated_at`.                                              |
| `hardDeleteDocument(id)`    | Removes the row entirely.                                                                  |
| `ensureDbOpen()`            | Opens Dexie when closed (no-op if already open).                                           |

---

## Hooks

-   `db.documents.title:filter` — customize title normalization per phase.
-   `db.documents.<stage>:filter:input/output` — mutate entities before persistence or after reads.
-   `db.documents.delete:action:*` — observe both soft and hard deletes.

---

## Implementation notes

1. **Title normalization** — `normalizeTitle` trims empty strings to `'Untitled'`, then passes through hook filters.
2. **Content safety** — `parseContent` guards against malformed JSON, returning an empty doc structure on error.
3. **Update payloads** — Build `DbUpdatePayload` objects so hooks receive full `existing`, `updated`, and `patch` context.

---

## Usage tips

-   Use `listDocuments()` for sidebar listings; it already caps results and filters deleted rows.
-   Call `updateDocument` with partial patches—passing `content` as TipTap JSON automatically serializes to string.
-   Write hook extensions to auto-tag docs or enforce title casing.
</file>

<file path="database/files-select.md">
# files-select

Read-only helpers for paging `file_meta` rows when browsing uploads or the recycle bin.

---

## What does it do?

-   Exposes lightweight list queries scoped to image-like files.
-   Applies simple paging (`offset`, `limit`) over an `updated_at` index.
-   Provides a rename helper that bumps `updated_at` for sorting freshness.

---

## API surface

| Function                     | Signature                                         | Description                                         |
| ---------------------------- | ------------------------------------------------- | --------------------------------------------------- |
| `listImageMetasPaged`        | `(offset = 0, limit = 50) => Promise<FileMeta[]>` | Returns newest-first non-deleted image meta rows.   |
| `listDeletedImageMetasPaged` | `(offset = 0, limit = 50) => Promise<FileMeta[]>` | Returns soft-deleted image meta rows for bin views. |
| `updateFileName`             | `(hash: string, name: string) => Promise<void>`   | Renames a file (if found) and updates `updated_at`. |

---

## Filtering rules

-   Images are detected via `kind === 'image'` or `mime_type` prefix `image/`.
-   Deleted and non-deleted lists are separated to simplify UI logic.

---

## Usage tips

-   Combine with `createOrRefFile` / `softDeleteFile` from `files.ts` for lifecycle actions.
-   Use `offset`/`limit` for infinite scroll; Dexie performs the filtering client-side so keep limits small (<= 100) for snappy results.
</file>

<file path="database/files-util.md">
# files-util

Utility helpers for enforcing message file limits and serializing file hash arrays.

---

## What does it do?

-   Resolves `MAX_FILES_PER_MESSAGE` from `NUXT_PUBLIC_MAX_MESSAGE_FILES` (bounded 1–12).
-   Provides JSON parse/serialize helpers for the `file_hashes` message column.
-   Dedupes hashes and preserves insertion order when serializing.

---

## Constants

| Constant                  | Description                                            |
| ------------------------- | ------------------------------------------------------ |
| `MAX_FILES_PER_MESSAGE`   | Runtime cap on attachments per message (default 6).    |
| `MAX_MESSAGE_FILE_HASHES` | Deprecated alias retained for backwards compatibility. |

---

## API surface

| Function              | Signature                      | Description                                      |
| --------------------- | ------------------------------ | ------------------------------------------------ | ---------------------------------------------------------------------- |
| `parseFileHashes`     | `(serialized?: string          | null) => string[]`                               | Safely parses JSON array, strips invalid entries, enforces max length. |
| `serializeFileHashes` | `(hashes: string[]) => string` | Dedupes, bounds to max, and returns JSON string. |

---

## Usage tips

-   Always run message updates through these helpers before writing to Dexie to avoid oversized rows.
-   When increasing the limit via env, remember it caps at 12 to avoid UI abuse.
</file>

<file path="database/files.md">
# files

File storage layer that deduplicates blobs by hash, keeps metadata in Dexie, and exposes hook-friendly lifecycle helpers.

---

## What does it do?

-   Generates content hashes (`computeFileHash`) to reuse existing uploads.
-   Stores binary blobs in `file_blobs` and metadata in `file_meta` with ref counting.
-   Emits numerous hooks so extensions can validate, annotate, or track file usage.
-   Supports soft delete, restore, hard delete, and reference counting operations.

---

## Data structures

| Field            | Description                                                     |
| ---------------- | --------------------------------------------------------------- |
| `hash`           | MD5 hash used as primary key for both metadata and blob tables. |
| `name`           | Display name supplied by uploader.                              |
| `mime_type`      | MIME type (defaults to `application/octet-stream`).             |
| `kind`           | `'image'` or `'pdf'` (auto-detected).                           |
| `size_bytes`     | Blob size in bytes; enforced against 20 MB cap.                 |
| `width`/`height` | Optional image dimensions extracted via object URL.             |
| `ref_count`      | Number of referencing entities (messages).                      |
| `deleted`        | Soft delete flag set by `softDeleteFile`/`softDeleteMany`.      |

---

## API surface

| Function                           | Description                                                                             |
| ---------------------------------- | --------------------------------------------------------------------------------------- |
| `createOrRefFile(file, name)`      | Dedupes by hash, increments ref count, stores blob + metadata, runs before/after hooks. |
| `getFileMeta(hash)`                | Loads metadata and applies output filters.                                              |
| `getFileBlob(hash)`                | Returns the stored `Blob` (or `undefined`).                                             |
| `softDeleteFile(hash)`             | Marks a single file as deleted.                                                         |
| `softDeleteMany(hashes)`           | Batch soft delete inside a transaction.                                                 |
| `restoreMany(hashes)`              | Clears `deleted` flag for multiple files.                                               |
| `hardDeleteMany(hashes)`           | Removes metadata and blob entries entirely.                                             |
| `derefFile(hash)`                  | Decrements ref count (never below zero).                                                |
| `changeRefCount(hash, delta)`      | Internal helper exported for testing/hooks (invokes `db.files.refchange`).              |
| `fileDeleteError(message, cause?)` | Convenience error factory with tags for delete flows.                                   |

---

## Hooks

-   `db.files.create:filter:input` and `db.files.create:action:(before|after)`
-   `db.files.get:filter:output`
-   `db.files.refchange:action:after`
-   `db.files.delete:action:(soft|hard):(before|after)`
-   `db.files.restore:action:(before|after)`

These make it easy to inject custom validation, analytics, or audit trails around file lifecycle events.

---

## Implementation notes

1. **Perf markers** — In dev mode the module records `performance.measure` spans for create/ref operations.
2. **Image metadata** — Uses an object URL to resolve dimensions without full decode; errors are swallowed gracefully.
3. **Transactions** — Critical write operations run inside Dexie transactions covering both metadata and blob tables to keep state consistent.

---

## Usage tips

-   Always call `derefFile` when removing file references from messages to keep ref counts accurate.
-   Hook into `db.files.create:filter:input` to enforce custom size caps or rename files.
-   When batch deleting, prefer `softDeleteMany` first; run `hardDeleteMany` during periodic cleanups to reclaim storage.
</file>

<file path="database/index.md">
# index

Barrel exports for the database layer, re-exporting the Dexie client, CRUD helpers, and common type aliases.

---

## What does it do?

-   Centralizes imports so callers can `import { create, queries, del } from '~/app/db'`.
-   Groups helpers into semantic objects: `create`, `upsert`, `queries`, `del`, `tx`, and `kv`.
-   Re-exports schema types (`Thread`, `Project`, `Document`, etc.) for consumer convenience.

---

## Aggregated namespaces

| Namespace  | Contents                                                                 |
| ---------- | ------------------------------------------------------------------------ |
| `create`   | `thread`, `message`, `kv`, `attachment`, `project`, `post`, `document`.  |
| `upsert`   | Sibling upsert helpers; note `document` maps to `updateDocument`.        |
| `queries`  | Read/query helpers spanning threads, messages, KV, posts, documents.     |
| `del.soft` | Soft-delete functions per entity.                                        |
| `del.hard` | Hard-delete counterparts (including KV helpers).                         |
| `tx`       | Transactional utilities (`appendMessage`, `moveMessage`, `copyMessage`). |
| `kv`       | Shorthand `get`, `set`, `delete` wrappers around name-based KV helpers.  |

---

## Usage example

```ts
import { create, queries, del } from '~/app/db';

const thread = await create.thread({ title: 'New chat' });
const messages = await queries.messagesByThread(thread.id);
await del.soft.thread(thread.id);
```

-   Prefer this barrel when wiring feature modules to keep import paths short and consistent.
</file>

<file path="database/kv.md">
# kv

Key-value helpers for storing small preference or credential blobs in the Dexie `kv` table.

---

## What does it do?

-   Validates KV payloads with `KvCreateSchema`/`KvSchema`.
-   Wraps reads/writes in `dbTry` with detailed error tagging.
-   Integrates with the hook system for before/after actions and output filters.
-   Provides name-based helpers for common flows like OpenRouter token storage.

---

## Data shape

| Field        | Type     | Notes                                                        |
| ------------ | -------- | ------------------------------------------------------------ | ----------------------------------------- |
| `id`         | `string` | Primary key. Name-based helpers use `kv:${name}` convention. |
| `name`       | `string` | Logical key.                                                 |
| `value`      | `string  | null`                                                        | Serialized payload (often JSON or token). |
| `clock`      | `number` | Monotonic counter incremented on `setKvByName`.              |
| `created_at` | `number` | Unix seconds.                                                |
| `updated_at` | `number` | Unix seconds.                                                |

---

## API surface

| Function                   | Description                                                                      |
| -------------------------- | -------------------------------------------------------------------------------- |
| `createKv(input)`          | Inserts a new KV row after filtering and validation.                             |
| `upsertKv(value)`          | Full-row upsert with before/after hooks.                                         |
| `hardDeleteKv(id)`         | Removes a row by primary key.                                                    |
| `getKv(id)`                | Fetches by primary key and applies output filters.                               |
| `getKvByName(name)`        | Finds first row matching `name`.                                                 |
| `setKvByName(name, value)` | Creates or updates a row using `kv:${name}` ids, increments `clock`, runs hooks. |
| `hardDeleteKvByName(name)` | Deletes by `name` with before/after hooks.                                       |

---

## Hooks

-   `db.kv.create:filter:input` / `db.kv.create:action:(before|after)`
-   `db.kv.upsert:filter:input`
-   `db.kv.get:filter:output` and `db.kv.getByName:filter:output`
-   `db.kv.upsertByName:filter:input` / `:action:after`
-   `db.kv.delete(:action:hard:* )` + `db.kv.deleteByName:action:hard:*`

---

## Usage tips

-   Store encrypted or user-provided tokens by name; `setKvByName` will generate IDs automatically.
-   Use hooks to redact values before logging or to enforce naming conventions.
-   Keep payloads tiny (<10 KB) to avoid IndexedDB quota pressure.
</file>

<file path="database/message-files.md">
# message-files

Helpers for attaching/detaching files to chat messages while maintaining ref counts and serialized hash lists.

---

## What does it do?

-   Resolves `file_hashes` arrays from messages and returns their metadata.
-   Adds files to messages either by Blob (new upload) or by existing hash.
-   Ensures Dexie transactions update messages and file tables atomically.
-   Dereferences files when hashes are removed.

---

## Types

| Type          | Description                                                                      |
| ------------- | -------------------------------------------------------------------------------- |
| `AddableFile` | Discriminated union `{ type: 'blob'; blob; name? }` or `{ type: 'hash'; hash }`. |

---

## API surface

| Function                                 | Description                                                                        |
| ---------------------------------------- | ---------------------------------------------------------------------------------- |
| `filesForMessage(messageId)`             | Loads `FileMeta[]` for the hashes stored on a message.                             |
| `addFilesToMessage(messageId, files)`    | Uploads or references files, merges hashes, applies hooks, writes serialized list. |
| `removeFileFromMessage(messageId, hash)` | Removes a hash, saves new list, decrements ref count.                              |

---

## Implementation notes

1. **Transactions** — All mutating functions run inside Dexie transactions touching `messages`, `file_meta`, and `file_blobs` to ensure consistency.
2. **Hooks** — `db.messages.files.validate:filter:hashes` lets extensions prune or reorder hash lists before persistence.
3. **Serialization** — Uses `serializeFileHashes` so limits/deduping stay consistent with message creation flows.

---

## Usage tips

-   Pass Blobs when users drop files; the helper will call `createOrRefFile` and reuse existing hashes.
-   For quick attach of already-uploaded media, pass `{ type: 'hash', hash }` to avoid re-computation.
-   Always call `removeFileFromMessage` (not manual mutation) so ref counts stay accurate.
</file>

<file path="database/messages.md">
# messages

Thread message CRUD utilities with hook integration, sparse indexing, and attachment support.

---

## What does it do?

-   Creates, upserts, and queries messages with schema validation.
-   Manages sparse indexes (`index` field) to support fast insertion and ordered retrieval.
-   Exposes transactional helpers for append/move/copy/insert operations that also update thread timestamps.
-   Provides normalization tools like `normalizeThreadIndexes`.

---

## Key data fields

| Field         | Description                                                     |
| ------------- | --------------------------------------------------------------- |
| `id`          | Message UUID (auto-generated for create flows).                 |
| `thread_id`   | Foreign key to the parent thread.                               |
| `role`        | `'user' \| 'assistant' \| 'system'` (validated via schema).     |
| `data`        | Arbitrary payload (serialized JSON) used by renderers.          |
| `index`       | Sparse ordering integer (default increments by 1000).           |
| `file_hashes` | Serialized JSON array of file hashes; use `files-util` helpers. |
| `clock`       | Revision counter.                                               |

---

## API surface

| Function                                          | Description                                                                                 |
| ------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| `createMessage(input)`                            | Validates payload (including array → string conversion for `file_hashes`) and writes a row. |
| `upsertMessage(value)`                            | Validates and replaces a row.                                                               |
| `messagesByThread(threadId)`                      | Fetches ordered messages, applying output filters.                                          |
| `getMessage(id)` / `messageByStream(streamId)`    | Targeted lookups with output filters.                                                       |
| `softDeleteMessage(id)` / `hardDeleteMessage(id)` | Delete flows with before/after hook actions.                                                |
| `appendMessage(input)`                            | Transactionally inserts at end of thread and updates timestamps.                            |
| `moveMessage(messageId, toThreadId)`              | Moves a message to another thread and reindexes.                                            |
| `copyMessage(messageId, toThreadId)`              | Duplicates a message into another thread with new ID.                                       |
| `insertMessageAfter(afterId, input)`              | Inserts between two messages, normalizing indexes as needed.                                |
| `normalizeThreadIndexes(threadId, start?, step?)` | Reassigns sequential indexes (default 1000 spacing).                                        |

---

## Hooks

-   `db.messages.create:filter:input` / `:action:before/after`
-   `db.messages.upsert`, `db.messages.byThread:filter:output`, `db.messages.get:filter:output`
-   Action hooks for delete, append, move, copy, insert, and normalize operations.

These hooks allow feature modules to enrich messages (e.g., auto-tagging, analytics) and react to lifecycle changes.

---

## Sparse indexing strategy

-   New messages default to increments of `1000`, leaving gaps for future inserts.
-   `insertMessageAfter` uses midpoint spacing; when no gap remains it calls `normalizeThreadIndexes` to re-sequence.
-   Dexie compound index `[thread_id+index]` keeps ordering queries fast.

---

## Usage tips

-   Always feed `file_hashes` as string arrays; the module serializes and bounds automatically.
-   Use `appendMessage` rather than manual `createMessage` when you need thread timestamps updated.
-   Call `normalizeThreadIndexes` after bulk edits to keep indexes tidy.
</file>

<file path="database/posts.md">
# posts

Generic post storage built on the `posts` Dexie table; used for lightweight CMS data like release notes or docs.

---

## What does it do?

-   Validates posts with `PostCreateSchema`/`PostSchema` before persistence.
-   Normalizes optional `meta` payloads to JSON strings for compact storage.
-   Exposes CRUD helpers plus simple search utilities.
-   Integrates with hook filters/actions at every lifecycle step.

---

## Data shape

| Field      | Description                                                      |
| ---------- | ---------------------------------------------------------------- |
| `id`       | Primary key (auto-generated if omitted).                         |
| `title`    | Required, trimmed string.                                        |
| `content`  | Arbitrary string content (often Markdown).                       |
| `postType` | Logical discriminator (e.g., `'markdown'`, `'doc'`, `'prompt'`). |
| `meta`     | JSON string or structured object/array; normalized upstream.     |
| `deleted`  | Soft delete flag.                                                |

---

## API surface

| Function             | Description                                        |
| -------------------- | -------------------------------------------------- |
| `createPost(input)`  | Filters, normalizes meta/title, writes a new post. |
| `upsertPost(value)`  | Replaces an existing post with validation.         |
| `getPost(id)`        | Fetches a post by id with output filters.          |
| `allPosts()`         | Returns all posts (unfiltered); hook can prune.    |
| `searchPosts(term)`  | Case-insensitive title search using Dexie filter.  |
| `softDeletePost(id)` | Marks `deleted: true` and updates timestamp.       |
| `hardDeletePost(id)` | Removes the row entirely.                          |

---

## Hooks

-   `db.posts.create:filter:input` / `:action:(before|after)`
-   `db.posts.upsert:filter:input`
-   `db.posts.get/all/search:filter:output`
-   `db.posts.delete:action:(soft|hard):(before|after)`

---

## Usage tips

-   Use `postType` to segment content (e.g., `'doc'` and `'prompt'` reuse this table via other modules).
-   Normalize heavily structured `meta` objects before calling `createPost`; the helper will serialize for you but invalid JSON becomes `undefined`.
-   Hooks are the right place to inject slug generation or analytics side effects.
</file>

<file path="database/projects.md">
# projects

CRUD helpers for project metadata stored in the `projects` Dexie table.

---

## What does it do?

-   Validates incoming project objects with `ProjectSchema`.
-   Wraps persistence in `dbTry` for consistent error handling.
-   Emits hook actions/filters for create, upsert, delete, and read flows.

---

## Data shape

| Field                       | Description                                        |
| --------------------------- | -------------------------------------------------- |
| `id`                        | Project ID (string).                               |
| `name`                      | Display name.                                      |
| `description`               | Optional string (nullable).                        |
| `data`                      | Arbitrary JSON payload scoped to project features. |
| `clock`                     | Revision counter.                                  |
| `deleted`                   | Soft delete flag updated via `softDeleteProject`.  |
| `created_at` / `updated_at` | Unix seconds timestamps.                           |

---

## API surface

| Function                | Description                                       |
| ----------------------- | ------------------------------------------------- |
| `createProject(input)`  | Filters + validates + writes a new project.       |
| `upsertProject(value)`  | Filters + validates + replaces the row.           |
| `softDeleteProject(id)` | Marks project deleted within a Dexie transaction. |
| `hardDeleteProject(id)` | Removes the project entirely.                     |
| `getProject(id)`        | Reads a project by id and applies output filters. |

---

## Hooks

-   `db.projects.create:filter:input` / `:action:(before|after)`
-   `db.projects.upsert:filter:input`
-   `db.projects.delete:action:(soft|hard):(before|after)`
-   `db.projects.get:filter:output`

---

## Usage tips

-   Store structured per-project state inside `data`; use hooks to enforce schema or migrate old versions.
-   Soft delete keeps history for undo flows—run hard deletes during cleanup tasks only.
</file>

<file path="database/prompts.md">
# prompts

Prompt library built on the shared `posts` table (`postType: 'prompt'`) with TipTap JSON payloads.

---

## What does it do?

-   Adds CRUD helpers for saved prompt templates.
-   Normalizes titles (allowing empty strings when updating) and serializes content.
-   Reuses hook payload conventions (`DbCreatePayload`, `DbUpdatePayload`, `DbDeletePayload`).
-   Supports soft/hard delete flows plus a simple `ensureDbOpen` helper.

---

## Data structures

| Row            | Field             | Meaning                          |
| -------------- | ----------------- | -------------------------------- |
| `PromptRow`    | `content: string` | Raw JSON string stored in Dexie. |
|                | `postType`        | Always `'prompt'`.               |
|                | `deleted`         | Soft delete flag.                |
| `PromptRecord` | `content: any`    | Parsed JSON returned to callers. |

---

## API surface

| Function                  | Description                                                                               |
| ------------------------- | ----------------------------------------------------------------------------------------- |
| `createPrompt(input?)`    | Generates an id, normalizes title/content, runs hooks, writes row, returns parsed record. |
| `getPrompt(id)`           | Loads a single prompt with output filters.                                                |
| `listPrompts(limit?)`     | Lists non-deleted prompts ordered by `updated_at` desc, capped to limit.                  |
| `updatePrompt(id, patch)` | Applies patches through hooks, persists, and returns updated record.                      |
| `softDeletePrompt(id)`    | Sets `deleted: true` and bumps `updated_at`.                                              |
| `hardDeletePrompt(id)`    | Deletes row from the posts table.                                                         |
| `ensureDbOpen()`          | Opens Dexie if closed.                                                                    |

---

## Hooks

-   `db.prompts.create:filter:input` / `:action:(before|after)`
-   `db.prompts.update:filter:input` (receives full payload context)
-   `db.prompts.list:filter:output`
-   `db.prompts.delete:action:(soft|hard):(before|after)`

---

## Usage tips

-   Leverage `normalizeTitle`’s `allowEmpty` option to let users save blank-titled prompts while still providing fallbacks.
-   Store structured prompt metadata inside hook filters instead of extending Dexie schema—`PromptEntity` supports custom fields.
-   Call `ensureDbOpen` before large migrations or offline flows to avoid lazy-open delays.
</file>

<file path="database/schema.md">
# schema

Central Zod schemas and generated TypeScript types for all Dexie tables.

---

## What does it do?

-   Defines runtime validation for every entity (`Project`, `Thread`, `Message`, etc.).
-   Supplies create-specific schemas that auto-populate IDs/timestamps via transforms.
-   Exports inferred TypeScript types to keep DB modules strongly typed.

---

## Schemas overview

| Schema                                        | Highlights                                                                 |
| --------------------------------------------- | -------------------------------------------------------------------------- |
| `ProjectSchema`                               | Basic metadata with optional description/data and `clock` counter.         |
| `ThreadSchema`                                | Supports branching fields (`parent_thread_id`, `anchor_*`, `branch_mode`). |
| `ThreadCreateSchema`                          | Optional fields with defaults for `id`, `clock`, timestamps.               |
| `MessageSchema`                               | Includes `file_hashes` string column, `stream_id`, sparse `index`.         |
| `MessageCreateSchema`                         | Auto-generates `id`, `clock`, timestamps; leaves `index` optional.         |
| `PostSchema` / `PostCreateSchema`             | Covers generic posts plus normalized title/meta logic.                     |
| `KvSchema` / `KvCreateSchema`                 | Simple key-value store with optional `value`.                              |
| `AttachmentSchema` / `AttachmentCreateSchema` | Enforces URL+type/name, optional `deleted`.                                |
| `FileMetaSchema` / `FileMetaCreateSchema`     | Metadata for blobs, defaulting `ref_count` and `clock`.                    |

---

## Helpers

-   `newId()` — Returns `crypto.randomUUID()` when available, fallback to timestamp string.
-   `nowSec()` — Unix timestamp (seconds) used as default for timestamps.

---

## Usage tips

-   Always run incoming data through `parseOrThrow(schema, value)` to catch invalid shapes before writing to Dexie.
-   When extending schema fields, update both the base schema and any related create schema so defaults stay aligned.
-   Compose new derived types via `z.infer<typeof Schema>` to keep type safety consistent across modules.
</file>

<file path="database/threads.md">
# threads

Thread CRUD and query helpers with hook integration, branching support, and system prompt utilities.

---

## What does it do?

-   Creates and upserts thread rows with full schema validation.
-   Provides soft/hard delete flows that coordinate with message cleanup.
-   Offers search helpers and child-thread queries for branching UIs.
-   Implements a simple fork helper for cloning threads (optionally copying messages).
-   Stores per-thread system prompt references.

---

## Key fields

| Field                                | Description                                             |
| ------------------------------------ | ------------------------------------------------------- |
| `parent_thread_id`                   | Links branches back to their source thread.             |
| `anchor_message_id` / `anchor_index` | Track branching anchor points.                          |
| `branch_mode`                        | `'reference'` or `'copy'`; controls fork behavior.      |
| `forked`                             | Boolean flag marking branched threads.                  |
| `system_prompt_id`                   | Optional prompt reference stored with helper functions. |

---

## API surface

| Function                                       | Description                                                  |
| ---------------------------------------------- | ------------------------------------------------------------ |
| `createThread(input)`                          | Filters input, applies defaults, validates, persists thread. |
| `upsertThread(value)`                          | Validates and writes thread updates.                         |
| `threadsByProject(projectId)`                  | Returns threads scoped to a project (hook-filtered).         |
| `searchThreadsByTitle(term)`                   | Case-insensitive title filter using Dexie.                   |
| `getThread(id)`                                | Fetches a thread by id with output filters.                  |
| `childThreads(parentThreadId)`                 | Lists direct branch children.                                |
| `softDeleteThread(id)`                         | Marks deleted flag and updates timestamp inside transaction. |
| `hardDeleteThread(id)`                         | Deletes thread and cascades delete to messages.              |
| `forkThread(sourceId, overrides?, options?)`   | Clones thread metadata, optionally copies messages.          |
| `updateThreadSystemPrompt(threadId, promptId)` | Stores/clears prompt reference.                              |
| `getThreadSystemPrompt(threadId)`              | Reads stored prompt id (hook-filtered).                      |

---

## Hooks

-   `db.threads.create|upsert:filter:input` + before/after actions.
-   `db.threads.delete:action:(soft|hard)`
-   `db.threads.fork:action:(before|after)`
-   `db.threads.updateSystemPrompt:action:(before|after)`
-   Output filters for query helpers (`byProject`, `searchByTitle`, `get`, `children`, `getSystemPrompt`).

---

## Implementation notes

1. **Transactions** — Delete/fork flows run inside Dexie transactions touching both `threads` and `messages` to stay consistent.
2. **Forking** — New thread IDs generated via `newId()`. When copying messages the helper duplicates rows and optionally updates thread metadata timestamps.
3. **Search** — Title search uses Dexie filter; pair with Orama-based composables for better ranking when needed.

---

## Usage tips

-   Use `forkThread` (from this module) for quick clones, or the richer branching utilities in `app/db/branching.ts` when you need anchor-aware forks.
-   Always go through `updateThreadSystemPrompt` to change prompts so hooks and timestamps stay aligned.
-   When cleaning up, call `softDeleteThread` first so UI consumers can offer undo before executing destructive `hardDeleteThread`.
</file>

<file path="database/util.md">
# util

Shared helpers for parsing with Zod, generating IDs, and producing Unix timestamps.

---

## What does it do?

-   Wraps `schema.safeParse` to throw readable errors when validation fails (`parseOrThrow`).
-   Exposes `nowSec()` for consistent second-based timestamps across modules.
-   Provides `newId()` that prefers `crypto.randomUUID()` with a safe fallback.

---

## API surface

| Function       | Signature                       | Description                                                           |
| -------------- | ------------------------------- | --------------------------------------------------------------------- |
| `parseOrThrow` | `(schema, data) => ZodInfer<T>` | Validates data against a Zod schema; throws on failure.               |
| `nowSec`       | `() => number`                  | Returns `Math.floor(Date.now() / 1000)`.                              |
| `newId`        | `() => string`                  | Generates a UUID v4 or timestamp-based ID when crypto is unavailable. |

---

## Usage tips

-   Always use `parseOrThrow` before writing to Dexie to catch client-side shape regressions early.
-   `nowSec()` keeps timestamps compact (seconds vs milliseconds); align any server sync logic accordingly.
-   The timestamp fallback in `newId()` keeps IDs unique even in legacy browsers—no extra seeding required.
</file>

<file path="hooks/hook-catalog.md">
# hook-catalog

Authoritative catalog of available hooks with their argument shapes and return values. This is derived from the codebase (hook keys, payload types, and call sites) so developers don’t have to console.log.

---

## How to read this

-   Kind: action vs filter. Actions return void; filters must return the next value in the chain.
-   Args: tuple passed to your handler. Use `typedOn(hooks).on(key, fn)` for editor inference.
-   Returns: concrete return type for filters. Veto-capable filters allow `false` (or `''`) to cancel/clear.

See also: `hooks.md` for engine API, `hook-keys.md` and `hook-types.md` for detailed payload types.

---

## Chat and AI

| Key                               | Kind   | Args (tuple)                                     | Returns                            |
| --------------------------------- | ------ | ------------------------------------------------ | ---------------------------------- |
| `ui.chat.message:filter:outgoing` | filter | `[text: string]`                                 | `string \| false` (veto to cancel) |
| `ui.chat.message:filter:incoming` | filter | `[text: string, threadId?: string]`              | `string`                           |
| `ai.chat.model:filter:select`     | filter | `[modelId: string]`                              | `string` (new model id)            |
| `ai.chat.messages:filter:input`   | filter | `[messages: any[]]`                              | `any[]`                            |
| `ai.chat.send:action:before`      | action | `[payload: AiSendBeforePayload]`                 | —                                  |
| `ai.chat.send:action:after`       | action | `[payload: AiSendAfterPayload]`                  | —                                  |
| `ai.chat.stream:action:delta`     | action | `[chunk: string, ctx: AiStreamDeltaPayload]`     | —                                  |
| `ai.chat.stream:action:reasoning` | action | `[chunk: string, ctx: AiStreamReasoningPayload]` | —                                  |
| `ai.chat.stream:action:complete`  | action | `[ctx: AiStreamCompletePayload]`                 | —                                  |
| `ai.chat.stream:action:error`     | action | `[ctx: AiStreamErrorPayload]`                    | —                                  |
| `ai.chat.retry:action:before`     | action | `[payload: AiRetryBeforePayload]`                | —                                  |
| `ai.chat.retry:action:after`      | action | `[payload: AiRetryAfterPayload]`                 | —                                  |

---

## Pane lifecycle

| Key                             | Kind   | Args (tuple)                                                 | Returns                 |
| ------------------------------- | ------ | ------------------------------------------------------------ | ----------------------- |
| `ui.pane.active:action`         | action | `[payload: UiPaneActivePayload]`                             | —                       |
| `ui.pane.blur:action`           | action | `[payload: UiPaneBlurPayload]`                               | —                       |
| `ui.pane.switch:action`         | action | `[payload: UiPaneSwitchPayload]`                             | —                       |
| `ui.pane.thread:filter:select`  | filter | `[requestedId: string, pane: PaneState, previousId: string]` | `string \| '' \| false` |
| `ui.pane.thread:action:changed` | action | `[payload: UiPaneThreadChangedPayload]`                      | —                       |
| `ui.pane.doc:filter:select`     | filter | `[requestedId: string, pane: PaneState, previousId: string]` | `string \| '' \| false` |
| `ui.pane.doc:action:changed`    | action | `[payload: UiPaneDocChangedPayload]`                         | —                       |
| `ui.pane.doc:action:saved`      | action | `[payload: UiPaneDocChangedPayload]`                         | —                       |
| `ui.pane.msg:action:sent`       | action | `[payload: UiPaneMsgSentPayload]`                            | —                       |
| `ui.pane.msg:action:received`   | action | `[payload: UiPaneMsgReceivedPayload]`                        | —                       |

Notes

-   The `select` filters support veto (`false`) and clear (`''`). See `useMultiPane.ts` and `usePaneDocuments.ts`.

---

## Files and uploads

| Key                         | Kind   | Args (tuple)                                  | Returns                            |
| --------------------------- | ------ | --------------------------------------------- | ---------------------------------- |
| `files.attach:filter:input` | filter | `[payload: FilesAttachInputPayload \| false]` | `FilesAttachInputPayload \| false` |

Notes

-   Returning `false` cancels the attachment. See `components/chat/file-upload-utils.ts`.

---

## Branching

| Key                              | Kind   | Args (tuple)                                                                                                       | Returns             |
| -------------------------------- | ------ | ------------------------------------------------------------------------------------------------------------------ | ------------------- |
| `branch.fork:action:before`      | action | `[payload: BranchForkBeforePayload]`                                                                               | —                   |
| `branch.fork:action:after`       | action | `[payload: ThreadEntity]`                                                                                          | —                   |
| `branch.retry:filter:options`    | filter | `[opts: { assistantMessageId: string; mode?: BranchMode; titleOverride?: string }]`                                | same shape as input |
| `branch.retry:action:before`     | action | `[payload: { assistantMessageId: string; precedingUserId: string; mode: BranchMode }]`                             | —                   |
| `branch.retry:action:after`      | action | `[payload: { assistantMessageId: string; precedingUserId: string; newThreadId: string; mode: BranchMode }]`        | —                   |
| `branch.context:filter:messages` | filter | `[messages: MessageEntity[], threadId: string, mode: BranchMode]`                                                  | `MessageEntity[]`   |
| `branch.context:action:after`    | action | `[payload: { threadId: string; mode: BranchMode; ancestorCount: number; localCount: number; finalCount: number }]` | —                   |

Notes

-   See `app/db/branching.ts` and `hook-types.ts` for the `Branch*` payloads.

---

## Database families (patterns)

Families: `messages | documents | files | threads | projects | posts | prompts | attachments | kv`

Actions

-   Before/after hooks per operation: `db.<family>.<op>:action:before|after`
-   Delete also emits `soft|hard` phases: `db.<family>.delete:action:soft|hard:before|after`

Filters

-   Input validators/transformers: `db.<family>.<op>:filter:input` — returns the (possibly transformed) input payload
-   Output mappers: `db.<family>.<op>:filter:output` — returns the (possibly transformed) result value

Common ops per family (varies by module; see each `app/db/*.ts`):

-   `create`, `upsert`, `update`, `delete`, `get`, `byThread`/`byProject`/`children`, `search`, specialized ops like `append`, `insertAfter`, `normalize`, `fork`, `updateSystemPrompt`.

Special cases

-   `db.files.refchange:action:after`
-   `db.kv.upsertByName:action:after`
-   `db.kv.deleteByName:action:hard:before|after`

Returns quick-reference

-   Action hooks: `void \| Promise<void>`
-   Filter input hooks: return the validated/transformed input shape
-   Filter output hooks: return the transformed entity/array being output

---

## App and errors (observed in code)

| Key                                       | Kind   | Args (tuple)                              | Returns               |
| ----------------------------------------- | ------ | ----------------------------------------- | --------------------- | --- |
| `app.init:action:after`                   | action | `[nuxtApp: any]`                          | —                     |
| `error:raised`                            | action | `[error: unknown]`                        | —                     |
| `error:<domain>`                          | action | `[error: unknown]`                        | —                     |
| `ai.chat.error:action`                    | action | `[payload: { error: unknown }]`           | —                     |
| `chat.systemPrompt.select:action:after`   | action | `[payload: { id: string; content: any }]` | —                     |
| `chat.systemPrompt.default:action:update` | action | `[id: string]`                            | —                     |
| `ui.sidebar.select:action:before`         | action | `[payload: { kind: 'chat'                 | 'doc'; id: string }]` | —   |
| `ui.sidebar.select:action:after`          | action | `[payload: { kind: 'chat'                 | 'doc'; id: string }]` | —   |
| `ui.chat.new:action:after`                | action | `[payload: {}]`                           | —                     |
| `editor.created:action:after`             | action | `[payload: { editor: any }]`              | —                     |
| `editor.updated:action:after`             | action | `[payload: { editor: any }]`              | —                     |

Notes

-   These are gathered from call sites across `app/**` and may evolve; prefer wildcard listeners for families like `error:*`.

---

## DX tips

-   Use `typedOn(hooks)` from `hook-keys` to get argument inference for known keys.
-   Filters: always return the next value. For veto-capable filters, return `false` to cancel and `''` to clear where supported.
-   For DB hooks, check the specific module under `app/db/` to see exactly which ops emit hooks and with which shapes.
</file>

<file path="hooks/hook-keys.md">
# hook-keys

Catalog of high-signal hook keys and typed helpers for ergonomically registering listeners.

---

## What does it do?

-   Defines string literal unions for well-known UI/AI/DB hook names.
-   Provides the `typedOn` helper, returning a type-safe `on()` wrapper around the hook engine.
-   Exposes utility return types to clarify filter semantics.

---

## Key unions

| Type           | Description                                                                  |
| -------------- | ---------------------------------------------------------------------------- |
| `KnownHookKey` | Enumerated list of frequently-used hooks (chat, pane, files).                |
| `DbFamily`     | Union of DB entity families (`'messages'`, `'documents'`, …).                |
| `DbHookKey`    | Template literal `db.${DbFamily}.${string}` covering table-specific hooks.   |
| `HookKey`      | Final public union combining known keys, DB hooks, and open string fallback. |

These unions power editor autocomplete while remaining permissive for plugin authors.

---

## Hook payload mapping

`HookPayloads` maps each `KnownHookKey` to a tuple of arguments expected by handlers. Examples:

-   `'ai.chat.stream:action:delta'` → `[requestId: string, payload: AiStreamDeltaPayload]`
-   `'ui.pane.thread:filter:select'` → `[threadId, pane, previousId]`
-   `'files.attach:filter:input'` → `[FilesAttachInputPayload | false]`

This mapping feeds the `typedOn` helper.

---

## `typedOn(hooks)`

```ts
import { typedOn } from '~/core/hooks/hook-keys';

const on = typedOn(useHooks()._engine);
on('ui.pane.msg:action:sent', (payload) => {
    console.log(payload.message.length);
});
```

-   Narrows `key` to `KnownHookKey` entries.
-   Infers callback parameters from `HookPayloads`.
-   Delegates to the underlying `hooks.on` and returns its disposer.

---

## Utility return types

-   `ChatOutgoingFilterReturn` — `string | false` (veto sending by returning `false`).
-   `ChatIncomingFilterReturn` — Always `string`.
-   `FilesAttachFilterReturn` — `FilesAttachInputPayload | false`.

Use these aliases in docs and tests to clarify expectations.

---

## Usage tips

-   Add new hooks by extending `KnownHookKey`/`HookPayloads` incrementally to keep compile times low.
-   Prefer `typedOn` in modules that need maximum inference but still interact with the untyped engine instance.
-   For custom plugin hooks, rely on `HookKey`’s permissiveness and extend via `hook-types` global augmentation.
</file>

<file path="hooks/hook-types.md">
# hook-types

TypeScript toolkit describing hook names, payload interfaces, and inference helpers for the OR3 hook engine.

---

## What does it do?

-   Defines structured payload interfaces for AI, UI panes, sidebar, branching, DB entities, and more.
-   Exposes string literal unions for action/filter hook names, including DB template literals.
-   Derives argument tuples and return types for every hook via `HookPayloadMap`.
-   Provides utility types for plugins to validate hook names and callback signatures.

---

## Payload interfaces

Notable groups:

-   **AI** — `AiSendBeforePayload`, `AiStreamDeltaPayload`, `AiRetryAfterPayload`.
-   **Pane/UI** — `UiPaneActivePayload`, `UiPaneMsgSentPayload`, `UiSidebarSelectPayload`.
-   **Branching** — `BranchForkOptions`, `BranchContextAfterPayload`.
-   **DB entities** — Lightweight mirror types (`MessageEntity`, `FileEntity`, `PromptEntity`, …).
-   **Utility** — `DbCreatePayload<T>`, `DbUpdatePayload<T>`, `DbDeletePayload<T>`.

These interfaces power typed composables, doc tables, and hook filters.

---

## Hook name unions

| Type               | Description                                                                                                               |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------- |
| `ActionHookName`   | Literal union matching `*:action:*` hooks (core + DB + extensions).                                                       |
| `FilterHookName`   | Literal union matching `*:filter:*` hooks (core + DB + extensions).                                                       |
| `HookName`         | Combined action + filter union used across the app.                                                                       |
| `DbActionHookName` | Template literal union for DB action hooks, including delete phases and custom cases (`db.files.refchange:action:after`). |
| `DbFilterHookName` | Template literal union for DB filters, including specialized titles/hash validators.                                      |

Plugin authors can augment `Or3ActionHooks` / `Or3FilterHooks` globally to extend these unions.

---

## Inference utilities

| Type                          | Purpose                                                                      |
| ----------------------------- | ---------------------------------------------------------------------------- |
| `InferHookParams<K>`          | Tuple of callback parameters for hook `K`.                                   |
| `InferHookReturn<K>`          | Return type a callback must produce (`void` for actions, value for filters). |
| `InferHookCallback<K>`        | Full function signature expected for hook `K`.                               |
| `IsAction<K>` / `IsFilter<K>` | Type-level booleans.                                                         |
| `ExtractHookPayload<K>`       | First parameter payload, handy for documentation.                            |
| `MatchingHooks<'pattern'>`    | Narrow hooks by template literal pattern (`'db.files.*'`).                   |
| `InferDbEntity<'db.files.*'>` | Maps hook strings back to entity interfaces.                                 |

These utilities are heavily used by `typed-hooks.ts` and composables like `useHookEffect`.

---

## Error helpers

-   `ValidateHookName<'bad.name'>` produces string literal diagnostics suggesting similar hooks.
-   `CallbackMismatch<Expected, Got>` formats readable error messages for mismatched callbacks.
-   Temporary guard `__hook_name_checks__` keeps frequently-used names anchored in the type system.

---

## Usage tips

-   When adding new hooks, update `CoreHookPayloadMap` (or appropriate DB unions) first; inference and docs will follow automatically.
-   For plugin ecosystems, augment `Or3ActionHooks`/`Or3FilterHooks` in a `.d.ts` file to make your hooks discoverable.
-   Use `InferHookCallback<'ui.pane.msg:action:sent'>` in unit tests to ensure mocks stay in sync with payload evolution.

---

## Related

-   `hook-keys.ts` — Convenience `typedOn` helper that leans on these types.
-   `typed-hooks.ts` — Runtime wrapper applying `InferHookCallback` signatures to the hook engine.
-   `useHookEffect` — Composable that uses `InferHookCallback` for DX.
</file>

<file path="hooks/hooks.md">
# hooks

Lightweight hook engine that powers OR3’s action/filter system with priority scheduling, async support, and diagnostics.

---

## What does it do?

-   Registers callbacks as **actions** (fire-and-forget) or **filters** (value transformers).
-   Supports wildcard subscriptions with glob patterns (`ai.chat.*`).
-   Executes listeners in priority order, tracking the current priority stack.
-   Provides both async (`doAction`, `applyFilters`) and sync variants.
-   Captures timing and error metrics for introspection.

---

## Core concepts

| Concept   | Details                                                                           |
| --------- | --------------------------------------------------------------------------------- |
| Action    | Side-effect listeners, return `void`/`Promise<void>`. Run via `doAction`.         |
| Filter    | Transform a value and return the next value in the chain. Run via `applyFilters`. |
| Priority  | Lower numbers execute first (default `10`). Ties fall back to insertion order.    |
| Wildcards | Use `*` to match multiple hook names (`db.*.delete:action:after`).                |

---

## API surface

| Function                | Signature                              | Notes                                                  |
| ----------------------- | -------------------------------------- | ------------------------------------------------------ |
| `addAction`             | `(name, fn, priority?, acceptedArgs?)` | Registers an action listener.                          |
| `removeAction`          | `(name, fn, priority?)`                | Removes a specific action listener.                    |
| `doAction`              | `(name, ...args) => Promise<void>`     | Runs all action listeners async.                       |
| `doActionSync`          | `(name, ...args) => void`              | Synchronous variant.                                   |
| `addFilter`             | `(name, fn, priority?, acceptedArgs?)` | Registers filter listener.                             |
| `removeFilter`          | `(name, fn, priority?)`                | Removes filter listener.                               |
| `applyFilters`          | `(name, value, ...args) => Promise<T>` | Runs filters async, returning the final value.         |
| `applyFiltersSync`      | `(name, value, ...args) => T`          | Synchronous variant.                                   |
| `on`                    | `(name, fn, opts?) => disposer`        | Ergonomic wrapper picking `action` vs `filter`.        |
| `off`                   | `(disposer) => void`                   | Safely invokes disposers (with error reporting).       |
| `onceAction`            | `(name, fn, priority?) => disposer`    | Auto-removes listener after first fire.                |
| `hasAction / hasFilter` | `(name?, fn?)`                         | Returns `false`/priority/boolean for existence checks. |
| `removeAllCallbacks`    | `(priority?)`                          | Drops all callbacks, optionally by priority.           |
| `currentPriority`       | `() => number \| false`                | Reports the priority currently executing.              |

Diagnostics live under `_diagnostics` with per-hook timing arrays and error counts.

---

## Execution flow

1. **Lookup** — Gathers exact matches plus wildcard entries, then sorts by priority/id.
2. **Timing** — Measures each callback using `performance.now` when available.
3. **Errors** — Logs console errors and increments `_diagnostics.errors[name]` without interrupting other listeners.
4. **Filters** — Thread the transformed value through the chain, returning the final result.

---

## Wildcards

-   Register with `hooks.addAction('ui.pane.*', handler)` to observe entire families.
-   Stored with a compiled `RegExp` for quick matching, still respecting priority.
-   Removal requires the original glob string + callback reference.

---

## Usage tips

-   Favor the typed wrapper (`createTypedHookEngine`) or composable (`useHooks`) for better DX.
-   Always return the transformed value from filters; returning `undefined` will propagate.
-   Use `onceAction` for analytics pings or onboarding to avoid manual cleanup.
-   Inspect `hooks._diagnostics.timings` in devtools to spot slow listeners.

---

## Related

-   `hook-types.ts` — Type system describing hook names and payloads.
-   `typed-hooks.ts` — Zero-cost typed wrapper around this engine.
-   `useHookEffect` — Vue composable for lifecycle-aware subscriptions.
</file>

<file path="hooks/typed-hooks.md">
# typed-hooks

Typed wrapper around the hook engine that preserves runtime behavior while delivering full TypeScript inference.

---

## What does it do?

-   Wraps a `HookEngine` with strongly typed methods for registering/executing hooks.
-   Infers callback signatures from `hook-types.ts` using `InferHookCallback` utilities.
-   Normalizes `hooks.on` to pick `action` vs `filter` automatically when the name contains `:filter:`.
-   Exposes diagnostics and the underlying engine for advanced use.

---

## API

`createTypedHookEngine(engine: HookEngine): TypedHookEngine`

Returns an object implementing:

-   `addAction`, `removeAction`, `doAction`, `doActionSync`
-   `addFilter`, `removeFilter`, `applyFilters`, `applyFiltersSync`
-   `on`, `off`, `onceAction`
-   `hasAction`, `hasFilter`, `removeAllCallbacks`, `currentPriority`
-   `_engine`, `_diagnostics`

### Example

```ts
import { createHookEngine } from '~/core/hooks/hooks';
import { createTypedHookEngine } from '~/core/hooks/typed-hooks';

const engine = createHookEngine();
const hooks = createTypedHookEngine(engine);

hooks.addFilter('ui.chat.message:filter:outgoing', (text) => text.trim());
const sanitized = await hooks.applyFilters(
    'ui.chat.message:filter:outgoing',
    message
);
```

TypeScript enforces that callbacks return the correct value (`string` above) and that the hook name exists.

---

## Kind inference

-   `on(name, callback, opts?)` automatically sets `opts.kind` to `'filter'` when the name includes `':filter:'`.
-   You can still override `opts.kind` to handle custom naming schemes.

---

## Passthrough utilities

-   `hasAction` / `hasFilter` — Useful for tests or debugging.
-   `removeAllCallbacks` — Clear listeners by priority (e.g., during teardown).
-   `currentPriority` — Inspect priority during nested hook execution.
-   `_diagnostics` — Direct access to timing/error aggregates from the base engine.

---

## Usage tips

-   Use `useHooks()` (which already wraps the injected engine) instead of building a new typed engine in most components.
-   Export the typed instance when building plugins so consumers benefit from strong typing.
-   When extending hook payloads via declaration merging, the typed engine automatically reflects the new signatures.
</file>

<file path="hooks/useHooks.md">
# useHooks

Nuxt composable that returns the app-wide typed hook engine, creating a fallback instance when none is provided.

---

## What does it do?

-   Reads the injected `$hooks` instance from `useNuxtApp()`.
-   Wraps it with `createTypedHookEngine` to provide full TypeScript inference.
-   Caches the typed engine per provider to avoid rebuilding wrappers.
-   Creates a dev-only fallback hook engine when `$hooks` is missing (e.g., during unit tests).

---

## API

```ts
function useHooks(): TypedHookEngine;
```

Example usage:

```ts
const hooks = useHooks();

hooks.doAction('ui.pane.active:action', {
    pane,
    index: 0,
});

const sanitized = await hooks.applyFilters(
    'ui.chat.message:filter:outgoing',
    draft
);
```

-   The returned object includes every typed method described in `typed-hooks.md`.
-   Consumers do not need to import `hook-types` directly; inference is automatic.

---

## Fallback behavior

-   When `$hooks` is absent (tests, SSR stubs), the composable instantiates a local engine and logs a warning in dev mode.
-   The fallback stays cached across calls so listeners persist for the session.

---

## Caching strategy

-   Stores `{ engine, typed }` in a module-level `cached` object keyed by the current `$hooks` reference.
-   When the provider changes (e.g., HMR re-injection), the typed wrapper is rebuilt to keep methods in sync.

---

## Usage tips

-   Call `useHooks()` inside Vue `setup()` or other composables; it relies on Nuxt’s app context.
-   Pair with `useHookEffect` when you want automatic lifecycle cleanup around `hooks.on`.
-   In tests, stub `$hooks` on the Nuxt app to assert listener registration without touching the fallback.
</file>

<file path="types/composables.md">
# Composables types

Canonical reference for every exported TypeScript type and interface defined under `app/composables`. These contracts power registry utilities, workspace state, streaming, UI chrome, and plugin extension points. Each table links the shape you consume when building features or plugins on top of the composable layer.

---

## Shared registry helpers (`app/composables/_registry.ts`)

| Type             | Kind      | Description                                                                                                                            |
| ---------------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| `RegistryItem`   | interface | Minimal contract for registry entries (`id`, optional `order`). Shared by sidebar, header, project tree, and other registries.         |
| `RegistryApi<T>` | interface | Generic API returned by `createRegistry` exposing `register`, `unregister`, `listIds`, `snapshot`, and a reactive `useItems()` helper. |

```ts
// app/composables/_registry.ts
import { computed, shallowRef } from 'vue';
import type { ComputedRef, ShallowRef } from 'vue';

export interface RegistryItem {
    id: string;
    order?: number;
}

export interface RegistryApi<T extends RegistryItem> {
    register(item: T): void;
    unregister(id: string): void;
    listIds(): string[];
    snapshot(): T[];
    useItems(): ComputedRef<readonly T[]>;
}

export function createRegistry<T extends RegistryItem>(
    globalKey: string,
    sortFn: (a: T, b: T) => number = (a, b) =>
        (a.order ?? 200) - (b.order ?? 200)
): RegistryApi<T> {
    const g: any = globalThis as any;
    const registry: Map<string, T> =
        g[globalKey] || (g[globalKey] = new Map<string, T>());
    const store: ShallowRef<T[]> = shallowRef([]);

    function sync() {
        store.value = Array.from(registry.values());
    }

    function register(item: T) {
        if (import.meta.dev && registry.has(item.id)) {
            console.warn(`[registry:${globalKey}] Replacing id: ${item.id}`);
        }
        const frozen = Object.freeze({ ...item });
        registry.set(item.id, frozen);
        sync();
    }

    function unregister(id: string) {
        if (registry.delete(id)) sync();
    }

    function listIds() {
        return Array.from(registry.keys());
    }

    function snapshot(): T[] {
        return store.value.slice();
    }

    function useItems(): ComputedRef<readonly T[]> {
        return computed(() => [...store.value].sort(sortFn));
    }

    if (!store.value.length && registry.size) sync();

    return { register, unregister, listIds, snapshot, useItems };
}
```

---

## Workspace backup & preview caching

| Type                   | Kind      | Description                                                                                                                                  |
| ---------------------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| `WorkspaceImportMode`  | union     | `'replace'` or `'append'`; controls how imports merge with the existing Dexie database.                                                      |
| `WorkspaceBackupState` | interface | Reactive state bag returned by `useWorkspaceBackup()` (`isExporting`, `progress`, `currentStep`, `importMode`, `backupMeta`, `error`, etc.). |
| `ImportMetadata`       | interface | Parsed metadata pulled from `.or3` exports: database name/version plus per-table row counts.                                                 |
| `WorkspaceBackupApi`   | interface | Public API of `useWorkspaceBackup()` exposing `exportWorkspace`, `peekBackup`, `importWorkspace`, and `reset`.                               |
| `PreviewCacheOptions`  | alias     | Re-exported from `~/config/preview-cache`; defines limits such as `maxUrls`, `maxBytes`, and eviction strategy knobs.                        |
| `PreviewCacheMetrics`  | interface | Snapshot of cache stats (`urls`, `bytes`, `hits`, `misses`, `evictions`) produced by `usePreviewCache().metrics()`.                          |

```ts
// app/composables/core/useWorkspaceBackup.ts
import { ref, type Ref } from 'vue';
import type { AppError } from '~/utils/errors';

export type WorkspaceImportMode = 'replace' | 'append';

export interface WorkspaceBackupState {
    isExporting: Ref<boolean>;
    isImporting: Ref<boolean>;
    progress: Ref<number>;
    currentStep: Ref<
        | 'idle'
        | 'peeking'
        | 'confirm'
        | 'importing'
        | 'exporting'
        | 'done'
        | 'error'
    >;
    importMode: Ref<WorkspaceImportMode>;
    overwriteValues: Ref<boolean>;
    backupMeta: Ref<ImportMetadata | null>;
    backupFormat: Ref<'stream' | 'dexie' | null>;
    error: Ref<AppError | null>;
}

export interface ImportMetadata {
    databaseName: string;
    databaseVersion: number;
    tables: Array<{ name: string; rowCount: number }>;
}

export interface WorkspaceBackupApi {
    state: WorkspaceBackupState;
    exportWorkspace(): Promise<void>;
    peekBackup(file: Blob): Promise<void>;
    importWorkspace(file: Blob): Promise<void>;
    reset(): void;
}
```

```ts
// app/config/preview-cache.ts
export type PreviewCacheOptions = {
    maxUrls: number;
    maxBytes: number;
};

const BASE_LIMITS: PreviewCacheOptions = {
    maxUrls: 120,
    maxBytes: 80 * 1024 * 1024,
};

const LOW_MEMORY_LIMITS: PreviewCacheOptions = {
    maxUrls: 80,
    maxBytes: 48 * 1024 * 1024,
};

function detectDeviceMemory(): number | undefined {
    if (typeof navigator === 'undefined') return undefined;
    const value = (navigator as any).deviceMemory;
    return typeof value === 'number' && Number.isFinite(value)
        ? value
        : undefined;
}

export function resolvePreviewCacheOptions(
    overrides: Partial<PreviewCacheOptions> = {}
): PreviewCacheOptions {
    const memory = detectDeviceMemory();
    const defaults = memory && memory <= 4 ? LOW_MEMORY_LIMITS : BASE_LIMITS;
    return {
        maxUrls: overrides.maxUrls ?? defaults.maxUrls,
        maxBytes: overrides.maxBytes ?? defaults.maxBytes,
    };
}
```

```ts
// app/composables/core/usePreviewCache.ts
import type { PreviewCacheOptions } from '~/config/preview-cache';

export interface PreviewCacheMetrics {
    urls: number;
    bytes: number;
    hits: number;
    misses: number;
    evictions: number;
}
```

---

## Multi-pane orchestration (`app/composables/core/useMultiPane.ts`, `documents/usePaneDocuments.ts`)

| Type                      | Kind      | Description                                                                                                              |
| ------------------------- | --------- | ------------------------------------------------------------------------------------------------------------------------ |
| `MultiPaneMessage`        | interface | Normalised pane message payload (`role`, `content`, optional `file_hashes`, `id`, `stream_id`).                          |
| `PaneState`               | interface | Persistent pane descriptor (`id`, `mode`, `threadId`, optional `documentId`, `messages`, `validating`).                  |
| `UseMultiPaneOptions`     | interface | Optional configuration for `useMultiPane()` (`initialThreadId`, `maxPanes`, `onFlushDocument`, `loadMessagesFor`).       |
| `UseMultiPaneApi`         | interface | Methods returned by `useMultiPane()` (`panes`, `activePaneIndex`, `addPane`, `setPaneThread`, navigation helpers, etc.). |
| `MultiPaneState`          | alias     | Re-export of `PaneState` for consumers that prefer `MultiPaneState[]` semantics.                                         |
| `UsePaneDocumentsOptions` | interface | `usePaneDocuments()` inputs (pane refs, `activePaneIndex`, `createNewDoc`, `flushDocument`).                             |
| `UsePaneDocumentsApi`     | interface | Document helpers returned by `usePaneDocuments()` (`newDocumentInActive`, `selectDocumentInActive`).                     |

```ts
// app/composables/core/useMultiPane.ts
import type { Ref, ComputedRef } from 'vue';

export type MultiPaneMessage = {
    role: 'user' | 'assistant';
    content: string;
    file_hashes?: string | null;
    id?: string;
    stream_id?: string;
};

export interface PaneState {
    id: string;
    mode: 'chat' | 'doc';
    threadId: string;
    documentId?: string;
    messages: MultiPaneMessage[];
    validating: boolean;
}

export interface UseMultiPaneOptions {
    initialThreadId?: string;
    maxPanes?: number;
    onFlushDocument?: (id: string) => void | Promise<void>;
    loadMessagesFor?: (id: string) => Promise<MultiPaneMessage[]>;
}

export interface UseMultiPaneApi {
    panes: Ref<PaneState[]>;
    activePaneIndex: Ref<number>;
    canAddPane: ComputedRef<boolean>;
    newWindowTooltip: ComputedRef<string>;
    addPane(): void;
    closePane(index: number): Promise<void> | void;
    setActive(index: number): void;
    focusPrev(current: number): void;
    focusNext(current: number): void;
    setPaneThread(index: number, threadId: string): Promise<void>;
    loadMessagesFor(id: string): Promise<MultiPaneMessage[]>;
    ensureAtLeastOne(): void;
}

export type MultiPaneState = PaneState;

// app/composables/documents/usePaneDocuments.ts
```

```ts
// app/composables/documents/usePaneDocuments.ts
import type { Ref } from 'vue';
import type { MultiPaneState } from '~/composables/core/useMultiPane';

export interface UsePaneDocumentsOptions {
    panes: Ref<MultiPaneState[]>;
    activePaneIndex: Ref<number>;
    createNewDoc: (initial?: { title?: string }) => Promise<{ id: string }>;
    flushDocument: (id: string) => Promise<void> | void;
}

export interface UsePaneDocumentsApi {
    newDocumentInActive(initial?: {
        title?: string;
    }): Promise<{ id: string } | undefined>;
    selectDocumentInActive(id: string): Promise<void>;
}
```

---

## Document & thread history registries

| Type                    | Kind      | Description                                                                                                  |
| ----------------------- | --------- | ------------------------------------------------------------------------------------------------------------ |
| `DocumentHistoryAction` | interface | Defines sidebar document history actions (id, icon, label, optional `order`, async `handler({ document })`). |
| `ThreadHistoryAction`   | interface | Same pattern for thread history dropdown entries (`handler({ document: Thread })`).                          |

```ts
// app/composables/documents/useDocumentHistoryActions.ts
import type { Post } from '~/db';

export interface DocumentHistoryAction {
    id: string;
    icon: string;
    label: string;
    order?: number;
    handler: (ctx: { document: Post }) => void | Promise<void>;
}

// app/composables/threads/useThreadHistoryActions.ts
import type { Thread } from '~/db';

export interface ThreadHistoryAction {
    id: string;
    icon: string;
    label: string;
    order?: number;
    handler: (ctx: { document: Thread }) => void | Promise<void>;
}
```

---

## Prompt, messaging & AI state

| Type                | Kind      | Description                                                                                                       |
| ------------------- | --------- | ----------------------------------------------------------------------------------------------------------------- |
| `ActivePromptState` | interface | Module-singleton state describing the currently selected system prompt (`activePromptId`, `activePromptContent`). |
| `ChatMessageAction` | interface | Extendable chat message action button contract (id, icon, tooltip, `showOn`, optional `order`, async handler).    |
| `AiSettingsV1`      | interface | Persisted AI preferences (`masterSystemPrompt`, `defaultModelMode`, optional `fixedModelId`, schema version).     |

```ts
// app/composables/chat/useActivePrompt.ts
import { ref, readonly } from 'vue';

export interface ActivePromptState {
    activePromptId: string | null;
    activePromptContent: any | null;
}

// app/composables/chat/useMessageActions.ts
export interface ChatMessageAction {
    id: string;
    icon: string;
    tooltip: string;
    showOn: 'user' | 'assistant' | 'both';
    order?: number;
    handler: (ctx: { message: any; threadId?: string }) => void | Promise<void>;
}

// app/composables/chat/useAiSettings.ts
export interface AiSettingsV1 {
    version: 1;
    masterSystemPrompt: string;
    defaultModelMode: 'lastSelected' | 'fixed';
    fixedModelId: string | null;
}
```

---

## Streaming accumulator (`app/composables/chat/useStreamAccumulator.ts`)

| Type                    | Kind      | Description                                                                                         |
| ----------------------- | --------- | --------------------------------------------------------------------------------------------------- |
| `StreamingState`        | interface | Reactive token buffer state (`text`, `reasoningText`, `isActive`, `finalized`, `error`, `version`). |
| `AppendKind`            | union     | `'text'` or `'reasoning'`; distinguishes which buffer `append()` targets.                           |
| `StreamAccumulatorApi`  | interface | Contract returned by `createStreamAccumulator()` (`state`, `append`, `finalize`, `reset`).          |
| `UnifiedStreamingState` | alias     | Re-export of `StreamingState` for callers expecting the previous naming.                            |

```ts
// app/composables/chat/useStreamAccumulator.ts
export interface StreamingState {
    text: string;
    reasoningText: string;
    isActive: boolean;
    finalized: boolean;
    error: Error | null;
    version: number;
}

export type AppendKind = 'text' | 'reasoning';

export interface StreamAccumulatorApi {
    state: Readonly<StreamingState>;
    append(delta: string, options: { kind: AppendKind }): void;
    finalize(opts?: { error?: Error; aborted?: boolean }): void;
    reset(): void;
}

export type UnifiedStreamingState = StreamingState;
```

---

## Project tree & workspace CRUD

| Type                    | Kind      | Description                                                                                               |
| ----------------------- | --------- | --------------------------------------------------------------------------------------------------------- |
| `ProjectTreeKind`       | union     | `'chat'` or `'doc'`; identifies tree row flavor.                                                          |
| `ShowOnKind`            | union     | `'root'`, `'all'`, `'chat'`, `'doc'`; used to limit project tree actions.                                 |
| `ProjectTreeChild`      | interface | Child row descriptor (value, label, optional icon/parentId/select handler).                               |
| `ProjectTreeRoot`       | interface | Root row descriptor (project id/name, optional expansion flag, children, handler).                        |
| `ProjectTreeRow`        | alias     | Union of `ProjectTreeRoot` and `ProjectTreeChild`.                                                        |
| `ProjectTreeHandlerCtx` | interface | Context passed to project tree action handlers (`treeRow`, plus legacy `child`/`root`).                   |
| `ProjectTreeAction`     | interface | Registry entry for project tree context menu items (id, icon, label, optional `order`/`showOn`, handler). |
| `CreateProjectInput`    | interface | Input accepted by `useProjectsCrud().createProject` (name, optional description/id override).             |
| `DeleteProjectOptions`  | interface | Options for `deleteProject` (`soft` defaults to true, `false` triggers hard delete).                      |

```ts
// app/composables/projects/useProjectTreeActions.ts
import type { RegistryItem } from '#imports';

export type ProjectTreeKind = 'chat' | 'doc';
export type ShowOnKind = 'root' | 'all' | 'chat' | 'doc';

export interface ProjectTreeChild {
    value: string;
    label: string;
    icon?: string;
    kind?: ProjectTreeKind;
    parentId?: string;
    onSelect?: (e: Event) => void;
}

export interface ProjectTreeRoot {
    value: string;
    label: string;
    defaultExpanded?: boolean;
    children?: ProjectTreeChild[];
    onSelect?: (e: Event) => void;
}

export type ProjectTreeRow = ProjectTreeRoot | ProjectTreeChild;

export interface ProjectTreeHandlerCtx {
    treeRow: ProjectTreeRow;
    child?: ProjectTreeChild;
    root?: ProjectTreeRoot;
}

export interface ProjectTreeAction extends RegistryItem {
    id: string;
    icon: string;
    label: string;
    order?: number;
    showOn?: ShowOnKind[];
    handler: (ctx: ProjectTreeHandlerCtx) => void | Promise<void>;
}

// app/composables/projects/useProjectsCrud.ts
export interface CreateProjectInput {
    name: string;
    description?: string | null;
    id?: string;
}

export interface DeleteProjectOptions {
    soft?: boolean;
}
```

---

## Dashboard plugins & navigation

| Type                            | Kind      | Description                                                                                                             |
| ------------------------------- | --------- | ----------------------------------------------------------------------------------------------------------------------- |
| `DashboardPlugin`               | interface | Primary plugin registration shape (id, icon, label, optional description/order/handler/pages/capabilities).             |
| `DashboardPluginPage`           | interface | Per-plugin page descriptor (id, title, optional icon/order/description, component or async factory).                    |
| `DashboardNavigationErrorCode`  | union     | Error codes emitted by navigation helpers (`'missing-plugin'`, `'missing-page'`, `'handler-error'`, `'resolve-error'`). |
| `DashboardNavigationError`      | interface | Structured error object carrying a `message`, optional plugin/page context, and original `cause`.                       |
| `DashboardNavigationState`      | interface | Reactive navigation state (`view`, `activePluginId`, `activePageId`, `loadingPage`, `error`).                           |
| `DashboardNavigationResult`     | union     | Result wrapper for navigation attempts (`{ ok: true }` or `{ ok: false; error }`).                                      |
| `UseDashboardNavigationOptions` | interface | Optional base plugin list for `useDashboardNavigation()` bootstrap.                                                     |

```ts
// app/composables/dashboard/useDashboardPlugins.ts
import type { Component } from 'vue';

export interface DashboardPlugin {
    id: string;
    icon: string;
    label: string;
    description?: string;
    order?: number;
    handler?: (ctx: { id: string }) => void | Promise<void>;
    pages?: DashboardPluginPage[];
    capabilities?: string[];
}

export interface DashboardPluginPage {
    id: string;
    title: string;
    icon?: string;
    order?: number;
    description?: string;
    component: Component | (() => Promise<any>);
}

export type DashboardNavigationErrorCode =
    | 'missing-plugin'
    | 'missing-page'
    | 'handler-error'
    | 'resolve-error';

export interface DashboardNavigationError {
    code: DashboardNavigationErrorCode;
    message: string;
    pluginId?: string;
    pageId?: string;
    cause?: unknown;
}

export interface DashboardNavigationState {
    view: 'dashboard' | 'page';
    activePluginId: string | null;
    activePageId: string | null;
    loadingPage: boolean;
    error: DashboardNavigationError | null;
}

export type DashboardNavigationResult =
    | { ok: true }
    | { ok: false; error: DashboardNavigationError };

export interface UseDashboardNavigationOptions {
    baseItems?: DashboardPlugin[];
}
```

---

## Sidebar, header & composer chrome

| Type                         | Kind      | Description                                                                                                            |
| ---------------------------- | --------- | ---------------------------------------------------------------------------------------------------------------------- |
| `SidebarSectionPlacement`    | union     | `'top'`, `'main'`, or `'bottom'`; controls where custom sections render.                                               |
| `SidebarSection`             | interface | Registry entry for sidebar stack sections (id, component/async loader, optional `order`/`placement`).                  |
| `SidebarFooterActionContext` | interface | Runtime context passed to footer action handlers (`activeThreadId`, `activeDocumentId`, `isCollapsed`).                |
| `ChromeActionColor`          | union     | Palette of supported footer/header button colors (Iconify-compatible strings plus strong/neutral variants).            |
| `SidebarFooterAction`        | interface | Footer action registry entry (id, icon, optional label/tooltip/order/color, handler + visibility/disabled predicates). |
| `SidebarFooterActionEntry`   | interface | Derived tuple returned by `useSidebarFooterActions()` (`action`, `disabled`).                                          |
| `HeaderActionContext`        | interface | Context for header actions (current route, `isMobile`, arbitrary params).                                              |
| `HeaderAction`               | interface | Header action registry entry (id, icon, optional tooltip/label/order/color, handler + visibility/disabled guards).     |
| `HeaderActionEntry`          | interface | Result rows returned by `useHeaderActions()` with resolved `disabled` state.                                           |
| `ComposerActionContext`      | interface | Composer button context (`editor`, `threadId`, `paneId`, `isStreaming`, custom metadata).                              |
| `ComposerAction`             | interface | Composer toolbar action contract (id, icon, optional tooltip/label/order/color, handler + visibility/disabled guards). |
| `ComposerActionEntry`        | interface | Wrapper returned by `useComposerActions()` that pairs an action with its `disabled` flag.                              |

```ts
// app/composables/sidebar/useSidebarSections.ts
import type { Component, ComputedRef } from 'vue';
import type { RouteLocationNormalizedLoaded } from 'vue-router';
import type { Editor } from '@tiptap/vue-3';
import type { RegistryItem } from '../_registry';

export type SidebarSectionPlacement = 'top' | 'main' | 'bottom';

export interface SidebarSection extends RegistryItem {
    id: string;
    component: Component | (() => Promise<any>);
    order?: number;
    placement?: SidebarSectionPlacement;
}

export interface SidebarFooterActionContext {
    activeThreadId?: string | null;
    activeDocumentId?: string | null;
    isCollapsed?: boolean;
}

export type ChromeActionColor =
    | 'neutral'
    | 'primary'
    | 'secondary'
    | 'success'
    | 'warning'
    | 'error'
    | 'info'
    | 'inverse-primary'
    | (string & {});

export interface SidebarFooterAction extends RegistryItem {
    id: string;
    icon: string;
    label?: string;
    tooltip?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: SidebarFooterActionContext) => void | Promise<void>;
    visible?: (ctx: SidebarFooterActionContext) => boolean;
    disabled?: (ctx: SidebarFooterActionContext) => boolean;
}

export interface SidebarFooterActionEntry {
    action: SidebarFooterAction;
    disabled: boolean;
}

// app/composables/sidebar/useHeaderActions.ts
export interface HeaderActionContext {
    route?: RouteLocationNormalizedLoaded | null;
    isMobile?: boolean;
    [key: string]: unknown;
}

export interface HeaderAction extends RegistryItem {
    id: string;
    icon: string;
    tooltip?: string;
    label?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: HeaderActionContext) => void | Promise<void>;
    visible?: (ctx: HeaderActionContext) => boolean;
    disabled?: (ctx: HeaderActionContext) => boolean;
}

export interface HeaderActionEntry {
    action: HeaderAction;
    disabled: boolean;
}

// app/composables/sidebar/useComposerActions.ts
export interface ComposerActionContext {
    editor?: Editor | null;
    threadId?: string | null;
    paneId?: string | null;
    isStreaming?: boolean;
    [key: string]: unknown;
}

export interface ComposerAction {
    id: string;
    icon: string;
    tooltip?: string;
    label?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: ComposerActionContext) => void | Promise<void>;
    visible?: (ctx: ComposerActionContext) => boolean;
    disabled?: (ctx: ComposerActionContext) => boolean;
}

export interface ComposerActionEntry {
    action: ComposerAction;
    disabled: boolean;
}
```

---

## Editor extension points (`app/composables/editor`)

| Type                  | Kind      | Description                                                                                                     |
| --------------------- | --------- | --------------------------------------------------------------------------------------------------------------- |
| `EditorNode`          | interface | TipTap node extension registration (id, `Node` instance, optional `order`).                                     |
| `EditorMark`          | interface | TipTap mark extension registration (id, `Mark` instance, optional `order`).                                     |
| `EditorExtension`     | interface | Generic TipTap extension registration (id, `Extension` instance, optional `order`).                             |
| `EditorToolbarButton` | interface | Editor toolbar button contract (id, icon, tooltip, optional `order`, `isActive`, `visible`, and click handler). |

```ts
// app/composables/editor/useEditorNodes.ts
import type { Node, Mark, Extension } from '@tiptap/core';

export interface EditorNode {
    id: string;
    extension: Node;
    order?: number;
}

export interface EditorMark {
    id: string;
    extension: Mark;
    order?: number;
}

export interface EditorExtension {
    id: string;
    extension: Extension;
    order?: number;
}

// app/composables/editor/useEditorToolbar.ts
import type { Editor } from '@tiptap/vue-3';

export interface EditorToolbarButton {
    id: string;
    icon: string;
    tooltip?: string;
    order?: number;
    isActive?: (editor: Editor) => boolean;
    onClick: (editor: Editor) => void | Promise<void>;
    visible?: (editor: Editor) => boolean;
}
```

---

Maintaining this catalogue alongside the code ensures plugin authors and internal feature teams share a single source of truth. Update the relevant section whenever you add, rename, or extend a composable type so the documentation stays authoritative.
</file>

<file path="types/database.md">
# Database types

Reference for every exported type and interface defined under `app/db`. These aliases describe the Dexie schema, higher-level records, and helper payloads that wrap database operations.

---

## Schema-derived entities (`app/db/schema.ts`)

| Type               | Kind  | Source schema                  | Description                                                                                          |
| ------------------ | ----- | ------------------------------ | ---------------------------------------------------------------------------------------------------- |
| `Project`          | alias | `ProjectSchema`                | Fully validated project row (id, name, description, clocks, timestamps).                             |
| `Thread`           | alias | `ThreadSchema`                 | Thread row with branching metadata, status flags, and clock fields.                                  |
| `ThreadCreate`     | alias | `ThreadCreateSchema` input     | Looser input shape accepted when creating a thread prior to validation.                              |
| `Message`          | alias | `MessageSchema`                | Stored message row with role, data payload, ordering index, and timestamps.                          |
| `MessageCreate`    | alias | `MessageCreateSchema` input    | Input contract for new messages before normalization (allows sparse indexes, file hashes as arrays). |
| `Post`             | alias | `PostSchema`                   | Post/blog row persisted in Dexie.                                                                    |
| `PostCreate`       | alias | `PostCreateSchema` input       | Input structure for creating posts.                                                                  |
| `Kv`               | alias | `KvSchema`                     | Key-value record (name/value pairs plus clock/timestamps).                                           |
| `KvCreate`         | alias | `KvCreateSchema`               | Input payload for inserting KV entries.                                                              |
| `Attachment`       | alias | `AttachmentSchema`             | Attachment row linking messages to files.                                                            |
| `AttachmentCreate` | alias | `AttachmentCreateSchema` input | Input contract for creating attachments.                                                             |
| `FileMeta`         | alias | `FileMetaSchema`               | Stored metadata for blobs (hash, mime, size, soft delete flags).                                     |
| `FileMetaCreate`   | alias | `FileMetaCreateSchema` input   | Input structure when minting new file metadata.                                                      |

The `app/db/index.ts` barrel re-exports these aliases (including `Document`) for consumers using `import { Thread } from '~/db'` style imports.

```ts
// app/db/schema.ts
import { z } from 'zod';
import { newId, nowSec } from './util';

export const ProjectSchema = z.object({
    id: z.string(),
    name: z.string(),
    description: z.string().nullable().optional(),
    data: z.any(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    deleted: z.boolean().default(false),
    clock: z.number().int(),
});
export type Project = z.infer<typeof ProjectSchema>;

export const ThreadSchema = z.object({
    id: z.string(),
    title: z.string().nullable().optional(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    last_message_at: z.number().int().nullable().optional(),
    parent_thread_id: z.string().nullable().optional(),
    anchor_message_id: z.string().nullable().optional(),
    anchor_index: z.number().int().nullable().optional(),
    branch_mode: z.enum(['reference', 'copy']).nullable().optional(),
    status: z.string().default('ready'),
    deleted: z.boolean().default(false),
    pinned: z.boolean().default(false),
    clock: z.number().int(),
    forked: z.boolean().default(false),
    project_id: z.string().nullable().optional(),
    system_prompt_id: z.string().nullable().optional(),
});
export type Thread = z.infer<typeof ThreadSchema>;

export const ThreadCreateSchema = ThreadSchema.partial({
    id: true,
    title: true,
    last_message_at: true,
    parent_thread_id: true,
    status: true,
    deleted: true,
    pinned: true,
    forked: true,
    project_id: true,
    system_prompt_id: true,
})
    .omit({ created_at: true, updated_at: true, id: true, clock: true })
    .extend({
        id: z
            .string()
            .optional()
            .transform((v) => v ?? newId()),
        clock: z
            .number()
            .int()
            .optional()
            .transform((v) => v ?? 0),
        created_at: z.number().int().default(nowSec()),
        updated_at: z.number().int().default(nowSec()),
    });
export type ThreadCreate = z.input<typeof ThreadCreateSchema>;

export const MessageSchema = z.object({
    id: z.string(),
    data: z.unknown().nullable().optional(),
    role: z.string(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    error: z.string().nullable().optional(),
    deleted: z.boolean().default(false),
    thread_id: z.string(),
    index: z.number().int(),
    clock: z.number().int(),
    stream_id: z.string().nullable().optional(),
    file_hashes: z.string().nullable().optional(),
});
export type Message = z.infer<typeof MessageSchema>;

export const MessageCreateSchema = MessageSchema.partial({ index: true })
    .omit({ created_at: true, updated_at: true, id: true, clock: true })
    .extend({
        id: z
            .string()
            .optional()
            .transform((v) => v ?? newId()),
        clock: z
            .number()
            .int()
            .optional()
            .transform((v) => v ?? 0),
        created_at: z.number().int().default(nowSec()),
        updated_at: z.number().int().default(nowSec()),
    });
export type MessageCreate = z.input<typeof MessageCreateSchema>;

export const PostSchema = z.object({
    id: z.string(),
    title: z
        .string()
        .transform((s) => s.trim())
        .refine((s) => s.length > 0, 'Title is required'),
    content: z.string().default(''),
    postType: z.string().default('markdown'),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    deleted: z.boolean().default(false),
    meta: z.union([
        z.string(),
        z.object({
            key: z.string(),
            value: z.string().nullable().optional(),
        }),
        z
            .array(
                z.object({
                    key: z.string(),
                    value: z.string().nullable().optional(),
                })
            )
            .nullable()
            .optional(),
    ]),
    file_hashes: z.string().nullable().optional(),
});
export type Post = z.infer<typeof PostSchema>;

export const PostCreateSchema = PostSchema.partial({
    id: true,
    created_at: true,
    updated_at: true,
}).extend({
    id: z
        .string()
        .optional()
        .transform((v) => v ?? newId()),
    created_at: z.number().int().default(nowSec()),
    updated_at: z.number().int().default(nowSec()),
});
export type PostCreate = z.input<typeof PostCreateSchema>;

export const KvSchema = z.object({
    id: z.string(),
    name: z.string(),
    value: z.string().nullable().optional(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    clock: z.number().int(),
});
export type Kv = z.infer<typeof KvSchema>;

export const KvCreateSchema = KvSchema.omit({
    created_at: true,
    updated_at: true,
}).extend({
    created_at: z.number().int().default(nowSec()),
    updated_at: z.number().int().default(nowSec()),
});
export type KvCreate = z.infer<typeof KvCreateSchema>;

export const AttachmentSchema = z.object({
    id: z.string(),
    type: z.string(),
    name: z.string(),
    url: z.url(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    deleted: z.boolean().default(false),
    clock: z.number().int(),
});
export type Attachment = z.infer<typeof AttachmentSchema>;

export const AttachmentCreateSchema = AttachmentSchema.omit({
    created_at: true,
    updated_at: true,
}).extend({
    created_at: z.number().int().default(nowSec()),
    updated_at: z.number().int().default(nowSec()),
});
export type AttachmentCreate = z.infer<typeof AttachmentCreateSchema>;

export const FileMetaSchema = z.object({
    hash: z.string(),
    name: z.string(),
    mime_type: z.string(),
    kind: z.enum(['image', 'pdf']).default('image'),
    size_bytes: z.number().int(),
    width: z.number().int().optional(),
    height: z.number().int().optional(),
    page_count: z.number().int().optional(),
    ref_count: z.number().int().default(0),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    deleted: z.boolean().default(false),
    clock: z.number().int(),
});
export type FileMeta = z.infer<typeof FileMetaSchema>;

export const FileMetaCreateSchema = FileMetaSchema.omit({
    created_at: true,
    updated_at: true,
    ref_count: true,
}).extend({
    created_at: z.number().int().default(nowSec()),
    updated_at: z.number().int().default(nowSec()),
    ref_count: z.number().int().default(1),
    clock: z.number().int().default(0),
});
export type FileMetaCreate = z.infer<typeof FileMetaCreateSchema>;
```

---

## Document store helpers (`app/db/documents.ts`)

| Type                  | Kind      | Description                                                                             |
| --------------------- | --------- | --------------------------------------------------------------------------------------- |
| `DocumentRow`         | interface | Minimal Dexie row projection (id, title, content, timestamps).                          |
| `DocumentRecord`      | interface | Extended record used in composables (includes denormalised helpers like `paneIndex`).   |
| `CreateDocumentInput` | interface | Shape accepted by `createDocument` before schema validation (title, content, metadata). |
| `UpdateDocumentPatch` | interface | Partial update payload (existing record, merged document data, metadata).               |
| `Document`            | alias     | Re-export of `DocumentRecord` for ergonomic imports.                                    |

```ts
// app/db/documents.ts
export interface DocumentRow {
    id: string;
    title: string;
    content: string;
    postType: string;
    created_at: number;
    updated_at: number;
    deleted: boolean;
}

export interface DocumentRecord {
    id: string;
    title: string;
    content: any;
    created_at: number;
    updated_at: number;
    deleted: boolean;
}

export interface CreateDocumentInput {
    title?: string | null;
    content?: any;
}

export interface UpdateDocumentPatch {
    title?: string;
    content?: any;
}

export type Document = DocumentRecord;
```

---

## Prompt store helpers (`app/db/prompts.ts`)

| Type                | Kind      | Description                                                               |
| ------------------- | --------- | ------------------------------------------------------------------------- |
| `PromptRow`         | interface | Dexie row projection (id, name, text, timestamps).                        |
| `PromptRecord`      | interface | Rich record returned by prompt helpers (includes folder/project context). |
| `CreatePromptInput` | interface | Input payload for creating prompts (name, text, optional metadata).       |
| `UpdatePromptPatch` | interface | Patch contract for updating prompts (existing record, updates, metadata). |
| `Prompt`            | alias     | Re-export of `PromptRecord` for ergonomic imports.                        |

```ts
// app/db/prompts.ts
export interface PromptRow {
    id: string;
    title: string;
    content: string;
    postType: string;
    created_at: number;
    updated_at: number;
    deleted: boolean;
}

export interface PromptRecord {
    id: string;
    title: string;
    content: any;
    created_at: number;
    updated_at: number;
    deleted: boolean;
}

export interface CreatePromptInput {
    title?: string | null;
    content?: any;
}

export interface UpdatePromptPatch {
    title?: string;
    content?: any;
}

export type Prompt = PromptRecord;
```

---

## File linking helpers

| Type          | Kind        | Description                                                                                                        |
| ------------- | ----------- | ------------------------------------------------------------------------------------------------------------------ |
| `AddableFile` | union alias | Discriminated union accepted by `addFilesToMessage` (`{ type: 'blob'; blob; name? }` or `{ type: 'hash'; hash }`). |
| `FileBlobRow` | interface   | Underlying Dexie row for the `file_blobs` table (`hash`, `blob`).                                                  |

```ts
// app/db/message-files.ts
export type AddableFile =
    | { type: 'blob'; blob: Blob; name?: string }
    | { type: 'hash'; hash: string };

// app/db/client.ts
export interface FileBlobRow {
    hash: string;
    blob: Blob;
}
```

---

## Operational utilities

| Type        | Kind      | Description                                                                                        |
| ----------- | --------- | -------------------------------------------------------------------------------------------------- | --------------------------------------------------------- |
| `DbTryTags` | interface | Metadata passed to `dbTry` (`op: 'read'                                                            | 'write'`, optional `entity`, arbitrary diagnostics tags). |
| `ForkMode`  | alias     | Re-export of `BranchMode` describing `'reference'` vs `'copy'` branch semantics in `branching.ts`. |

```ts
// app/db/dbTry.ts
export interface DbTryTags {
    readonly op: 'read' | 'write';
    readonly entity?: string;
    readonly [k: string]: any;
}

// app/db/branching.ts
import type { BranchMode } from '../core/hooks/hook-types';
export type ForkMode = BranchMode;
```

These helper types surface the inputs and outputs that higher-level database APIs expose to composables, hooks, and plugins. Keep them in sync with schema or payload changes so consumer code stays type-safe.
</file>

<file path="types/hooks.md">
# Hooks types

Canonical reference for every exported TypeScript type and interface that powers the hook engine. All definitions come from `app/core/hooks/**/*.ts` and are grouped by concern so you can locate payload shapes, key unions, and helper generics quickly.

---

## Engine primitives

| Name              | Kind       | Description                                                                                                                             |
| ----------------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| `HookKind`        | union      | `'action'` or `'filter'`; used to declare hook registration intent.                                                                     |
| `RegisterOptions` | interface  | Common options (`priority`, `acceptedArgs`) shared by action/filter registration helpers.                                               |
| `OnOptions`       | interface  | Extends `RegisterOptions` with optional `kind` to drive the ergonomic `on()` helper.                                                    |
| `HookEngine`      | interface  | Runtime contract implemented by `createHookEngine()`; exposes registration, execution, diagnostics, and lifecycle helpers.              |
| `HookFn`          | type alias | Re-exports the internal `AnyFn` as a convenience import for external `.d.ts` usage.                                                     |
| `TypedHookEngine` | interface  | Purely type-level wrapper returned by `createTypedHookEngine()` exposing fully typed action/filter helpers while delegating at runtime. |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hooks.ts
export type HookKind = 'action' | 'filter';

export interface RegisterOptions {
    priority?: number;
    acceptedArgs?: number;
}

export interface OnOptions extends RegisterOptions {
    kind?: HookKind;
}

export type HookFn = (...args: any[]) => any;

export interface HookEngine {
    addFilter<F extends (...args: any[]) => any>(
        name: string,
        fn: F,
        priority?: number,
        acceptedArgs?: number
    ): void;
    removeFilter<F extends (...args: any[]) => any>(
        name: string,
        fn: F,
        priority?: number
    ): void;
    applyFilters<T>(name: string, value: T, ...args: any[]): Promise<T>;
    applyFiltersSync<T>(name: string, value: T, ...args: any[]): T;

    addAction<F extends (...args: any[]) => any>(
        name: string,
        fn: F,
        priority?: number,
        acceptedArgs?: number
    ): void;
    removeAction<F extends (...args: any[]) => any>(
        name: string,
        fn: F,
        priority?: number
    ): void;
    doAction(name: string, ...args: any[]): Promise<void>;
    doActionSync(name: string, ...args: any[]): void;

    hasFilter(name?: string, fn?: (...args: any[]) => any): boolean | number;
    hasAction(name?: string, fn?: (...args: any[]) => any): boolean | number;
    removeAllCallbacks(priority?: number): void;
    currentPriority(): number | false;

    onceAction(
        name: string,
        fn: (...args: any[]) => any,
        priority?: number
    ): () => void;
    on(name: string, fn: (...args: any[]) => any, opts?: OnOptions): () => void;
    off(disposer: () => void): void;

    _diagnostics: {
        timings: Record<string, number[]>;
        errors: Record<string, number>;
        callbacks(actionOrFilter?: HookKind): number;
    };
}

// Source: app/core/hooks/typed-hooks.ts
type Tail<T extends any[]> = T extends [any, ...infer Rest] ? Rest : [];

export interface TypedHookEngine {
    addAction<K extends ActionHookName>(
        name: K,
        callback: InferHookCallback<K>,
        priority?: number
    ): void;
    removeAction<K extends ActionHookName>(
        name: K,
        callback: InferHookCallback<K>,
        priority?: number
    ): void;
    doAction<K extends ActionHookName>(
        name: K,
        ...args: InferHookParams<K>
    ): Promise<void>;
    doActionSync<K extends ActionHookName>(
        name: K,
        ...args: InferHookParams<K>
    ): void;
    addFilter<K extends FilterHookName>(
        name: K,
        callback: InferHookCallback<K>,
        priority?: number
    ): void;
    removeFilter<K extends FilterHookName>(
        name: K,
        callback: InferHookCallback<K>,
        priority?: number
    ): void;
    applyFilters<K extends FilterHookName>(
        name: K,
        value: InferHookParams<K>[0],
        ...args: Tail<InferHookParams<K>>
    ): Promise<InferHookReturn<K>>;
    applyFiltersSync<K extends FilterHookName>(
        name: K,
        value: InferHookParams<K>[0],
        ...args: Tail<InferHookParams<K>>
    ): InferHookReturn<K>;
    on<K extends HookName>(
        name: K,
        callback: InferHookCallback<K>,
        opts?: OnOptions & {
            kind?: K extends ActionHookName
                ? 'action'
                : K extends FilterHookName
                ? 'filter'
                : 'action' | 'filter';
        }
    ): () => void;
    off(disposer: () => void): void;
    onceAction<K extends ActionHookName>(
        name: K,
        callback: InferHookCallback<K>,
        priority?: number
    ): () => void;
    hasAction<K extends ActionHookName>(
        name?: K,
        fn?: InferHookCallback<K>
    ): boolean | number;
    hasFilter<K extends FilterHookName>(
        name?: K,
        fn?: InferHookCallback<K>
    ): boolean | number;
    removeAllCallbacks(priority?: number): void;
    currentPriority(): number | false;
    readonly _engine: HookEngine;
    readonly _diagnostics: HookEngine['_diagnostics'];
}
```

---

## Key unions and handlers

| Name                       | Kind             | Description                                                                                                                                   |
| -------------------------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| `KnownHookKey`             | union            | Enumerates high-signal hook names (`ui.chat.message:filter:outgoing`, `ai.chat.send:action:before`, …) for first-class editor autocomplete.   |
| `DbFamily`                 | union            | Database table families (`'messages'`, `'documents'`, `'files'`, `'threads'`, `'projects'`, `'posts'`, `'prompts'`, `'attachments'`, `'kv'`). |
| `DbHookKey`                | template literal | Forms `db.${DbFamily}.${string}` for flexible DB hook addressing.                                                                             |
| `HookKey`                  | union            | Final public key type combining `KnownHookKey`, `DbHookKey`, and an open string fallback for plugins.                                         |
| `HookPayloads`             | interface        | Maps each `KnownHookKey` to its listener argument tuple (e.g. `'ui.pane.thread:filter:select'` → `[requestedId, pane, previousId]`).          |
| `ChatOutgoingFilterReturn` | alias            | `string \| false`; standardized return contract for outgoing chat filters.                                                                    |
| `ChatIncomingFilterReturn` | alias            | Always `string`; incoming assistant transforms must emit text.                                                                                |
| `FilesAttachFilterReturn`  | alias            | `FilesAttachInputPayload \| false`; allows file-attach veto from filters.                                                                     |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-keys.ts
export type KnownHookKey =
    | 'ui.chat.message:filter:outgoing'
    | 'ui.chat.message:filter:incoming'
    | 'ai.chat.model:filter:select'
    | 'ai.chat.messages:filter:input'
    | 'ai.chat.send:action:before'
    | 'ai.chat.send:action:after'
    | 'ai.chat.stream:action:delta'
    | 'ai.chat.stream:action:reasoning'
    | 'ai.chat.stream:action:complete'
    | 'ai.chat.stream:action:error'
    | 'ai.chat.retry:action:before'
    | 'ai.chat.retry:action:after'
    | 'ui.pane.active:action'
    | 'ui.pane.blur:action'
    | 'ui.pane.switch:action'
    | 'ui.pane.thread:filter:select'
    | 'ui.pane.thread:action:changed'
    | 'ui.pane.doc:filter:select'
    | 'ui.pane.doc:action:changed'
    | 'ui.pane.doc:action:saved'
    | 'ui.pane.msg:action:sent'
    | 'ui.pane.msg:action:received'
    | 'files.attach:filter:input';

export type DbFamily =
    | 'messages'
    | 'documents'
    | 'files'
    | 'threads'
    | 'projects'
    | 'posts'
    | 'prompts'
    | 'attachments'
    | 'kv';

export type DbHookKey = `db.${DbFamily}.${string}`;

export type HookKey = KnownHookKey | DbHookKey | (string & {});

export interface HookPayloads {
    'ai.chat.send:action:before': [AiSendBeforePayload];
    'ai.chat.send:action:after': [AiSendAfterPayload];
    'ai.chat.stream:action:delta': [string, AiStreamDeltaPayload];
    'ai.chat.stream:action:reasoning': [string, AiStreamReasoningPayload];
    'ai.chat.stream:action:complete': [AiStreamCompletePayload];
    'ai.chat.stream:action:error': [AiStreamErrorPayload];
    'ui.pane.msg:action:sent': [UiPaneMsgSentPayload];
    'ui.pane.msg:action:received': [UiPaneMsgReceivedPayload];
    'ui.pane.active:action': [UiPaneActivePayload];
    'ui.pane.blur:action': [UiPaneBlurPayload];
    'ui.pane.switch:action': [UiPaneSwitchPayload];
    'ui.pane.thread:filter:select': [
        string,
        UiPaneThreadChangedPayload['pane'],
        string
    ];
    'ui.pane.thread:action:changed': [UiPaneThreadChangedPayload];
    'ui.pane.doc:filter:select': [
        string,
        UiPaneDocChangedPayload['pane'],
        string
    ];
    'ui.pane.doc:action:changed': [UiPaneDocChangedPayload];
    'ui.pane.doc:action:saved': [UiPaneDocChangedPayload];
    'ui.chat.message:filter:outgoing': [string];
    'ui.chat.message:filter:incoming': [string, string | undefined];
    'ai.chat.model:filter:select': [string];
    'ai.chat.messages:filter:input': [any[]];
    'files.attach:filter:input': [FilesAttachInputPayload | false];
    'ai.chat.retry:action:before': [AiRetryBeforePayload];
    'ai.chat.retry:action:after': [AiRetryAfterPayload];
}

export type ChatOutgoingFilterReturn = string | false;
export type ChatIncomingFilterReturn = string;
export type FilesAttachFilterReturn = FilesAttachInputPayload | false;
```

---

## AI and chat payloads

| Name                        | Kind      | Description                                                                           |
| --------------------------- | --------- | ------------------------------------------------------------------------------------- |
| `AiSendBeforePayload`       | interface | Context before streaming begins (thread, model, user/assistant metadata).             |
| `AiSendAfterPayloadTimings` | interface | Timing breakdown (`startedAt`, `endedAt`, `durationMs`) attached to send completions. |
| `AiSendAfterPayload`        | interface | Post-send context including request/response summaries, timings, and abort flag.      |
| `AiStreamDeltaContext`      | interface | Token delta context (`threadId`, `assistantId`, lengths, `chunkIndex`).               |
| `AiStreamReasoningContext`  | interface | Reasoning stream metadata (reasoning span length).                                    |
| `AiStreamCompleteContext`   | interface | Final stream state (total length, reasoning length, file hashes).                     |
| `AiStreamErrorContext`      | interface | Error detail for streaming failures or aborts.                                        |
| `AiStreamDeltaPayload`      | alias     | Equal to `AiStreamDeltaContext` for ergonomics.                                       |
| `AiStreamReasoningPayload`  | alias     | Equal to `AiStreamReasoningContext`.                                                  |
| `AiStreamCompletePayload`   | alias     | Equal to `AiStreamCompleteContext`.                                                   |
| `AiStreamErrorPayload`      | alias     | Equal to `AiStreamErrorContext`.                                                      |
| `AiRetryBeforePayload`      | interface | Retry initiation context (original user/assistant IDs, trigger source).               |
| `AiRetryAfterPayload`       | interface | Retry completion context (replacement message IDs, thread).                           |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-types.ts
export interface AiSendBeforePayload {
    threadId?: string;
    modelId: string;
    user: { id: string; length: number };
    assistant: { id: string; streamId: string };
    messagesCount?: number;
}

export interface AiSendAfterPayloadTimings {
    startedAt: number;
    endedAt: number;
    durationMs: number;
}

export interface AiSendAfterPayload {
    threadId?: string;
    request?: { modelId?: string; userId?: string };
    response?: { assistantId?: string; length?: number };
    timings?: AiSendAfterPayloadTimings;
    aborted?: boolean;
}

export interface AiStreamDeltaContext {
    threadId?: string;
    assistantId: string;
    streamId: string;
    deltaLength: number;
    totalLength: number;
    chunkIndex: number;
}

export interface AiStreamReasoningContext {
    threadId?: string;
    assistantId: string;
    streamId: string;
    reasoningLength: number;
}

export interface AiStreamCompleteContext {
    threadId?: string;
    assistantId: string;
    streamId: string;
    totalLength: number;
    reasoningLength?: number;
    fileHashes?: string | null;
}

export interface AiStreamErrorContext {
    threadId?: string;
    streamId?: string;
    error?: unknown;
    aborted?: boolean;
}

export type AiStreamDeltaPayload = AiStreamDeltaContext;
export type AiStreamReasoningPayload = AiStreamReasoningContext;
export type AiStreamCompletePayload = AiStreamCompleteContext;
export type AiStreamErrorPayload = AiStreamErrorContext;

export interface AiRetryBeforePayload {
    threadId?: string;
    originalUserId: string;
    originalAssistantId?: string;
    triggeredBy: 'user' | 'assistant';
}

export interface AiRetryAfterPayload {
    threadId?: string;
    originalUserId: string;
    originalAssistantId?: string;
    newUserId?: string;
    newAssistantId?: string;
}
```

---

## Pane and UI payloads

| Name                         | Kind      | Description                                                            |
| ---------------------------- | --------- | ---------------------------------------------------------------------- | -------------- |
| `UiPaneMsgBase`              | interface | Core shape for pane messages (`id`, `threadId`, lengths, file hashes). |
| `UiPaneMsgReceived`          | interface | Extends `UiPaneMsgBase` with optional `reasoningLength`.               |
| `UiPaneActivePayload`        | interface | Fired when a pane becomes active (`pane`, `index`, `previousIndex`).   |
| `UiPaneBlurPayload`          | interface | Blur event payload capturing previous focus index.                     |
| `UiPaneSwitchPayload`        | interface | Pane switch payload with current and previous indices.                 |
| `UiPaneThreadChangedPayload` | interface | Thread change detail (old/new IDs, pane index, message count).         |
| `UiPaneDocChangedPayload`    | interface | Document change detail (old/new doc IDs, pane index, metadata).        |
| `UiPaneMsgSentPayload`       | interface | Outgoing pane message context including optional `meta`.               |
| `UiPaneMsgReceivedPayload`   | interface | Incoming pane message context including reasoning metadata.            |
| `UiSidebarSelectPayload`     | interface | Sidebar selection event (`kind: 'chat'                                 | 'doc'`, `id`). |
| `UiChatNewPayload`           | interface | Chat creation context (thread ID, creation timestamp).                 |
| `AppInitPayload`             | interface | Nuxt application bootstrap payload (`nuxtApp`).                        |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-types.ts
type PaneState = MultiPaneState;

export interface UiPaneMsgBase {
    id: string;
    threadId?: string;
    length?: number;
    fileHashes?: string | null;
}

export interface UiPaneMsgReceived extends UiPaneMsgBase {
    reasoningLength?: number;
}

export interface UiPaneActivePayload {
    pane: PaneState;
    index: number;
    previousIndex?: number;
}

export interface UiPaneBlurPayload {
    pane: PaneState;
    previousIndex: number;
}

export interface UiPaneSwitchPayload {
    pane: PaneState;
    index: number;
    previousIndex?: number;
}

export interface UiPaneThreadChangedPayload {
    pane: PaneState;
    oldThreadId: string | '';
    newThreadId: string;
    paneIndex: number;
    messageCount?: number;
}

export interface UiPaneDocChangedPayload {
    pane: PaneState;
    oldDocumentId: string | '';
    newDocumentId: string;
    paneIndex: number;
    meta?: Record<string, unknown>;
}

export interface UiPaneMsgSentPayload {
    pane: PaneState;
    paneIndex: number;
    message: UiPaneMsgBase;
    meta?: Record<string, unknown>;
}

export interface UiPaneMsgReceivedPayload {
    pane: PaneState;
    paneIndex: number;
    message: UiPaneMsgReceived;
    meta?: Record<string, unknown>;
}

export interface UiSidebarSelectPayload {
    kind: 'chat' | 'doc';
    id: string;
}

export interface UiChatNewPayload {
    threadId?: string;
    createdAt?: number;
}

export interface AppInitPayload {
    nuxtApp: any;
}
```

---

## Files, uploads, and attachments

| Name                      | Kind      | Description                                                                                       |
| ------------------------- | --------- | ------------------------------------------------------------------------------------------------- |
| `FilesAttachInputPayload` | interface | Filter payload describing a candidate file (`file`, `name`, `mime`, `size`, `kind`).              |
| `FilesAttachPayload`      | interface | Extends `FilesAttachInputPayload` with persistence metadata (`accepted`, optional `url`, `hash`). |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-types.ts
export interface FilesAttachInputPayload {
    file: File;
    name: string;
    mime: string;
    size: number;
    kind: 'image' | 'pdf';
}

export interface FilesAttachPayload extends FilesAttachInputPayload {
    accepted: boolean;
    url?: string;
    hash?: string;
}
```

---

## Branching and context utilities

| Name                        | Kind      | Description                                                                        |
| --------------------------- | --------- | ---------------------------------------------------------------------------------- |
| `BranchMode`                | alias     | `'reference'` or `'copy'` branch semantics.                                        |
| `BranchForkOptions`         | interface | Input parameters when forking threads (source IDs, mode, optional title override). |
| `BranchForkBeforePayload`   | interface | Pre-fork payload used by hooks (`source`, `anchor`, `mode`, optional `options`).   |
| `BranchContextAfterPayload` | interface | Post-branch context summary (thread counts, mode).                                 |
| `KvUpsertByNameInput`       | interface | Convenience payload for KV upserts by `name`.                                      |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-types.ts
export type BranchMode = 'reference' | 'copy';

export interface BranchForkOptions {
    sourceThreadId: string;
    anchorMessageId: string;
    mode?: BranchMode;
    titleOverride?: string;
}

export interface BranchForkBeforePayload {
    source: ThreadEntity;
    anchor: MessageEntity;
    mode: BranchMode;
    options?: { titleOverride?: string };
}

export interface BranchContextAfterPayload {
    threadId: string;
    mode: BranchMode;
    ancestorCount: number;
    localCount: number;
    finalCount: number;
}

export interface KvUpsertByNameInput {
    name: string;
    value: any;
}
```

---

## Entity mirrors and DB payload wrappers

| Name                 | Kind      | Description                                                                                |
| -------------------- | --------- | ------------------------------------------------------------------------------------------ |
| `MessageEntity`      | interface | Hook-friendly projection of a message row (`id`, `thread_id`, `role`, `data`, timestamps). |
| `ThreadEntity`       | interface | Thread metadata consumed by hooks (status, branching info, clock).                         |
| `DocumentEntity`     | interface | Document metadata for hooks (title, content, timestamps).                                  |
| `FileEntity`         | interface | File metadata (`hash`, `name`, `mime`, `size`, reference count).                           |
| `ProjectEntity`      | interface | Project record summary (name, description, clock flags).                                   |
| `PostEntity`         | interface | Lightweight post/blog record.                                                              |
| `PromptEntity`       | interface | Prompt data (`id`, `name`, `text`).                                                        |
| `AttachmentEntity`   | interface | Attachment record linking messages to files.                                               |
| `KvEntry`            | interface | Key-value store record (name/value, clocks, timestamps).                                   |
| `DbCreatePayload<T>` | interface | Generic wrapper emitted before/after `create` operations (`entity`, `tableName`).          |
| `DbUpdatePayload<T>` | interface | Wrapper for update lifecycle (existing, updated, patch, table).                            |
| `DbDeletePayload<T>` | interface | Wrapper for delete lifecycle (entity, id, table).                                          |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-types.ts
export interface MessageEntity {
    id: string;
    thread_id: string;
    role: 'user' | 'assistant' | 'system';
    data: any;
    index: number;
    created_at: number;
    updated_at?: number;
}

export interface ThreadEntity {
    id: string;
    title?: string | null;
    created_at: number;
    updated_at: number;
    last_message_at?: number | null;
    parent_thread_id?: string | null;
    anchor_message_id?: string | null;
    anchor_index?: number | null;
    branch_mode?: 'reference' | 'copy' | null;
    status: string;
    deleted: boolean;
    pinned: boolean;
    clock: number;
    forked: boolean;
    project_id?: string | null;
    system_prompt_id?: string | null;
}

export interface DocumentEntity {
    id: string;
    title?: string;
    content?: string;
    created_at?: number;
    updated_at?: number;
}

export interface FileEntity {
    hash: string;
    name: string;
    mime: string;
    size: number;
    ref_count?: number;
}

export interface ProjectEntity {
    id: string;
    name: string;
    description?: string | null;
    data: any;
    created_at: number;
    updated_at: number;
    deleted: boolean;
    clock: number;
}

export interface PostEntity {
    id: string;
    title?: string;
    body?: string;
    created_at?: number;
    updated_at?: number;
}

export interface PromptEntity {
    id: string;
    name: string;
    text: string;
}

export interface AttachmentEntity {
    id: string;
    message_id?: string;
    file_hash?: string;
}

export interface KvEntry {
    id: string;
    name: string;
    value?: string | null;
    created_at: number;
    updated_at: number;
    clock: number;
}

export interface DbCreatePayload<T = any> {
    entity: T;
    tableName: string;
}

export interface DbUpdatePayload<T = any> {
    existing: T;
    updated: T;
    patch: Partial<T>;
    tableName: string;
}

export interface DbDeletePayload<T = any> {
    entity: T;
    id: string;
    tableName: string;
}
```

---

## Hook name families and DB literals

| Name                      | Kind             | Description                                                                                               |
| ------------------------- | ---------------- | --------------------------------------------------------------------------------------------------------- |
| `DbEntityName`            | union            | Valid entity literals for DB hooks (`'messages'`, `'threads'`, …).                                        |
| `DbOperation`             | union            | Supported DB operations (`'create'`, `'update'`, `'delete'`, `'get'`, `'search'`, `'normalize'`, etc.).   |
| `DbPhase`                 | union            | `'before'` or `'after'` lifecycle for action hooks.                                                       |
| `DbDeleteType`            | union            | Distinguishes `'soft'` vs `'hard'` delete hooks.                                                          |
| `DbActionHookName`        | template literal | Enumerates action hook naming convention across DB families (`db.posts.delete:action:soft:before`, etc.). |
| `DbFilterHookName`        | template literal | Enumerates filter hook naming convention (`db.messages.create:filter:input`, etc.).                       |
| `CoreActionHookName`      | conditional      | Extracts built-in action hook keys from `CoreHookPayloadMap`.                                             |
| `ExtensionActionHookName` | alias            | `keyof Or3ActionHooks`; supports module augmentation.                                                     |
| `ActionHookName`          | union            | Combines core and extension action hook names.                                                            |
| `CoreFilterHookName`      | conditional      | Extracts built-in filter hook keys from `CoreHookPayloadMap`.                                             |
| `ExtensionFilterHookName` | alias            | `keyof Or3FilterHooks`; extension hook keys.                                                              |
| `FilterHookName`          | union            | Combines core and extension filter names.                                                                 |
| `HookName`                | union            | Full set of action + filter names.                                                                        |

---

## Payload maps and inference helpers

| Name                              | Kind          | Description                                                                                       |
| --------------------------------- | ------------- | ------------------------------------------------------------------------------------------------- |
| `CoreHookPayloadMap`              | mapped type   | Master mapping from built-in hook names to argument tuples; foundation for inference.             |
| `HookPayloadMap`                  | intersection  | `CoreHookPayloadMap` combined with developer augmentations via `Or3ActionHooks`/`Or3FilterHooks`. |
| `InferHookParams<K>`              | conditional   | Resolves the argument tuple for hook name `K`.                                                    |
| `InferHookReturn<K>`              | conditional   | Infers the expected return type for hook `K` (void for actions, chained value for filters).       |
| `InferHookCallback<K>`            | function type | Convenience signature for callbacks keyed by `K`.                                                 |
| `IsAction<K>`                     | conditional   | Type predicate that narrows `true` when `K` is an action hook.                                    |
| `IsFilter<K>`                     | conditional   | Type predicate for filter hook names.                                                             |
| `ExtractHookPayload<K>`           | conditional   | Pulls the payload tuple for hook `K`.                                                             |
| `MatchingHooks<Pattern>`          | conditional   | Extracts hook names that match a template literal pattern.                                        |
| `InferDbEntity<K>`                | conditional   | Infers the DB entity type represented by a hook key (e.g. `db.messages.*`).                       |
| `Tail<T>`                         | alias         | Removes the first element from a tuple (`T extends [any, ...infer Rest] ? Rest : []`).            |
| `SuggestSimilar<K>`               | conditional   | Produces human-readable suggestions for invalid hook keys during type checking.                   |
| `ValidateHookName<K>`             | conditional   | Emits helpful diagnostics when a hook name is invalid.                                            |
| `TypeName<T>`                     | conditional   | Friendly string literal describing the TypeScript type `T`.                                       |
| `CallbackMismatch<Expected, Got>` | conditional   | Diagnostic helper that compares expected vs actual callback signatures.                           |

---

## Usage notes

-   The hook engine exposes runtime APIs via `HookEngine` while `TypedHookEngine` wraps them for inference. Use `useHooks()` to obtain the typed variant.
-   When adding new hook keys, update `HookPayloads` and the relevant payload interfaces so documentation and inference stay aligned.
-   Generics like `InferHookParams` and `MatchingHooks` power helper utilities and schema validation—reference them when building tooling around the hook system.
</file>

<file path="docmap.json">
{
    "title": "OR3 Docs",
    "description": "Documentation for the OR3 project",
    "version": "1.0.0",
    "sections": [
        {
            "title": "Composables",
            "path": "/composables",
            "files": [
                {
                    "name": "useActivePrompt.md",
                    "path": "/composables/useActivePrompt",
                    "category": "Chat"
                },
                {
                    "name": "useAiSettings.md",
                    "path": "/composables/useAiSettings",
                    "category": "Chat"
                },
                {
                    "name": "useChat.md",
                    "path": "/composables/useChat",
                    "category": "Chat"
                },
                {
                    "name": "useChatInputBridge.md",
                    "path": "/composables/useChatInputBridge",
                    "category": "Chat"
                },
                {
                    "name": "useDefaultPrompt.md",
                    "path": "/composables/useDefaultPrompt",
                    "category": "Chat"
                },
                {
                    "name": "useMessageActions.md",
                    "path": "/composables/useMessageActions",
                    "category": "Chat"
                },
                {
                    "name": "useMessageEditing.md",
                    "path": "/composables/useMessageEditing",
                    "category": "Chat"
                },
                {
                    "name": "useModelStore.md",
                    "path": "/composables/useModelStore",
                    "category": "Chat"
                },
                {
                    "name": "useStreamAccumulator.md",
                    "path": "/composables/useStreamAccumulator",
                    "category": "Chat"
                },
                {
                    "name": "useDocumentHistoryActions.md",
                    "path": "/composables/useDocumentHistoryActions",
                    "category": "Documents"
                },
                {
                    "name": "useDocumentsList.md",
                    "path": "/composables/useDocumentsList",
                    "category": "Documents"
                },
                {
                    "name": "useDocumentsStore.md",
                    "path": "/composables/useDocumentsStore",
                    "category": "Documents"
                },
                {
                    "name": "useEditorNodes.md",
                    "path": "/composables/useEditorNodes",
                    "category": "Editor"
                },
                {
                    "name": "useEditorToolbar.md",
                    "path": "/composables/useEditorToolbar",
                    "category": "Editor"
                },
                {
                    "name": "useComposerActions.md",
                    "path": "/composables/useComposerActions",
                    "category": "Sidebar"
                },
                {
                    "name": "useHeaderActions.md",
                    "path": "/composables/useHeaderActions",
                    "category": "Sidebar"
                },
                {
                    "name": "useDashboardPlugins.md",
                    "path": "/composables/useDashboardPlugins",
                    "category": "Dashboard"
                },
                {
                    "name": "usePaneDocuments.md",
                    "path": "/composables/usePaneDocuments",
                    "category": "Documents"
                },
                {
                    "name": "useProjectTreeActions.md",
                    "path": "/composables/useProjectTreeActions",
                    "category": "Projects"
                },
                {
                    "name": "useProjectsCrud.md",
                    "path": "/composables/useProjectsCrud",
                    "category": "Projects"
                },
                {
                    "name": "useSidebarSearch.md",
                    "path": "/composables/useSidebarSearch",
                    "category": "Sidebar"
                },
                {
                    "name": "useSidebarSections.md",
                    "path": "/composables/useSidebarSections",
                    "category": "Sidebar"
                },
                {
                    "name": "useThreadHistoryActions.md",
                    "path": "/composables/useThreadHistoryActions",
                    "category": "Threads"
                },
                {
                    "name": "useThreadSearch.md",
                    "path": "/composables/useThreadSearch",
                    "category": "Threads"
                },
                {
                    "name": "useHookEffect.md",
                    "path": "/composables/useHookEffect",
                    "category": "Core"
                },
                {
                    "name": "useMultiPane.md",
                    "path": "/composables/useMultiPane",
                    "category": "Core"
                },
                {
                    "name": "usePanePrompt.md",
                    "path": "/composables/usePanePrompt",
                    "category": "Core"
                },
                {
                    "name": "usePreviewCache.md",
                    "path": "/composables/usePreviewCache",
                    "category": "Core"
                },
                {
                    "name": "useWorkspaceBackup.md",
                    "path": "/composables/useWorkspaceBackup",
                    "category": "Core"
                }
            ]
        },
        {
            "title": "Hooks",
            "path": "/hooks",
            "files": [
                {
                    "name": "hook-catalog.md",
                    "path": "/hooks/hook-catalog",
                    "category": "Reference"
                },
                {
                    "name": "hooks.md",
                    "path": "/hooks/hooks",
                    "category": "Core"
                },
                {
                    "name": "typed-hooks.md",
                    "path": "/hooks/typed-hooks",
                    "category": "Core"
                },
                {
                    "name": "hook-types.md",
                    "path": "/hooks/hook-types",
                    "category": "Types"
                },
                {
                    "name": "hook-keys.md",
                    "path": "/hooks/hook-keys",
                    "category": "Types"
                },
                {
                    "name": "useHooks.md",
                    "path": "/hooks/useHooks",
                    "category": "Integration"
                }
            ]
        },
        {
            "title": "Database",
            "path": "/database",
            "files": [
                {
                    "name": "attachments.md",
                    "path": "/database/attachments",
                    "category": "Entities"
                },
                {
                    "name": "branching.md",
                    "path": "/database/branching",
                    "category": "Threads"
                },
                {
                    "name": "client.md",
                    "path": "/database/client",
                    "category": "Core"
                },
                {
                    "name": "dbTry.md",
                    "path": "/database/dbTry",
                    "category": "Utilities"
                },
                {
                    "name": "documents.md",
                    "path": "/database/documents",
                    "category": "Entities"
                },
                {
                    "name": "files-select.md",
                    "path": "/database/files-select",
                    "category": "Utilities"
                },
                {
                    "name": "files-util.md",
                    "path": "/database/files-util",
                    "category": "Utilities"
                },
                {
                    "name": "files.md",
                    "path": "/database/files",
                    "category": "Entities"
                },
                {
                    "name": "index.md",
                    "path": "/database/index",
                    "category": "Core"
                },
                {
                    "name": "kv.md",
                    "path": "/database/kv",
                    "category": "Entities"
                },
                {
                    "name": "message-files.md",
                    "path": "/database/message-files",
                    "category": "Messages"
                },
                {
                    "name": "messages.md",
                    "path": "/database/messages",
                    "category": "Messages"
                },
                {
                    "name": "posts.md",
                    "path": "/database/posts",
                    "category": "Entities"
                },
                {
                    "name": "projects.md",
                    "path": "/database/projects",
                    "category": "Entities"
                },
                {
                    "name": "prompts.md",
                    "path": "/database/prompts",
                    "category": "Entities"
                },
                {
                    "name": "schema.md",
                    "path": "/database/schema",
                    "category": "Core"
                },
                {
                    "name": "threads.md",
                    "path": "/database/threads",
                    "category": "Threads"
                },
                {
                    "name": "util.md",
                    "path": "/database/util",
                    "category": "Utilities"
                }
            ]
        },
        {
            "title": "Auth",
            "path": "/auth",
            "files": [
                {
                    "name": "useOpenrouter.md",
                    "path": "/auth/useOpenrouter",
                    "category": "Authentication"
                },
                {
                    "name": "useUserApiKey.md",
                    "path": "/auth/useUserApiKey",
                    "category": "Authentication"
                },
                {
                    "name": "openrouter-auth.md",
                    "path": "/auth/openrouter-auth",
                    "category": "Exchange"
                },
                {
                    "name": "openrouter-build.md",
                    "path": "/auth/openrouter-build",
                    "category": "Messages"
                },
                {
                    "name": "models-service.md",
                    "path": "/auth/models-service",
                    "category": "Models"
                }
            ]
        },
        {
            "title": "Types",
            "path": "/types",
            "files": [
                {
                    "name": "hooks.md",
                    "path": "/types/hooks",
                    "category": "Hooks"
                },
                {
                    "name": "database.md",
                    "path": "/types/database",
                    "category": "Database"
                },
                {
                    "name": "composables.md",
                    "path": "/types/composables",
                    "category": "Composables"
                }
            ]
        }
    ]
}
</file>

<file path="llms.xml">
This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: README.md, docmap.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
composables/
  useActivePrompt.md
  useAiSettings.md
  useChat.md
  useChatInputBridge.md
  useComposerActions.md
  useDashboardPlugins.md
  useDefaultPrompt.md
  useDocumentHistoryActions.md
  useDocumentsList.md
  useDocumentsStore.md
  useEditorNodes.md
  useEditorToolbar.md
  useHeaderActions.md
  useHookEffect.md
  useMessageActions.md
  useMessageEditing.md
  useModelStore.md
  useMultiPane.md
  usePaneDocuments.md
  usePanePrompt.md
  usePreviewCache.md
  useProjectsCrud.md
  useProjectTreeActions.md
  useSidebarSearch.md
  useSidebarSections.md
  useStreamAccumulator.md
  useThreadHistoryActions.md
  useThreadSearch.md
  useWorkspaceBackup.md
database/
  attachments.md
  branching.md
  client.md
  dbTry.md
  documents.md
  files-select.md
  files-util.md
  files.md
  index.md
  kv.md
  message-files.md
  messages.md
  posts.md
  projects.md
  prompts.md
  schema.md
  threads.md
  util.md
hooks/
  hook-catalog.md
  hook-keys.md
  hook-types.md
  hooks.md
  typed-hooks.md
  useHooks.md
types/
  composables.md
  database.md
  hooks.md
repomix-output.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="composables/useActivePrompt.md">
# useActivePrompt

Reactive composable that manages the currently selected system prompt for chat conversations.

This composable provides a module-singleton selection state (id + content) so multiple components
and composables can read the active system prompt consistently without creating duplicate refs.

It integrates with the local prompt database (`~/db/prompts`) to load prompt content and emits a
hook event after a prompt is selected so other subsystems can react.

---

## Features

-   Shared, readonly reactive `activePromptId` and `activePromptContent` that are visible across
    all consumers in the same Vite/SSR process (module-singleton pattern).
-   `setActivePrompt(id)` loads the prompt from the DB and updates the shared state.
-   Calls the hooks engine: `chat.systemPrompt.select:action:after` with the selected id/content.
-   `clearActivePrompt()` resets the selection to `null`.

---

## Installation

No installation required — the composable is part of the app and can be imported directly:

```ts
import { useActivePrompt } from '~/composables/chat/useActivePrompt';
```

---

## Usage

Basic usage in a component:

```vue
<script setup lang="ts">
import { watch } from 'vue';
import { useActivePrompt } from '~/composables/chat/useActivePrompt';

const {
    activePromptId,
    activePromptContent,
    setActivePrompt,
    clearActivePrompt,
} = useActivePrompt();

// react to changes
watch(activePromptId, (id) => {
    console.log('Active prompt id changed:', id);
});

// select a prompt by id (async)
async function select(id: string) {
    await setActivePrompt(id);
}

// clear selection
function clear() {
    clearActivePrompt();
}
</script>
```

### Example: use in a send-flow

When sending a message you can include the active system prompt like this:

```ts
const { getActivePromptContent } = useActivePrompt();
const systemPrompt = getActivePromptContent();
// attach systemPrompt to the outgoing message payload if present
```

Note: `getActivePromptContent()` returns the raw content value (or `null`) and is synchronous.

---

## API

-   activePromptId: Readonly<Ref<string | null>> — readonly reactive id of the selected prompt.
-   activePromptContent: Readonly<Ref<any | null>> — readonly reactive prompt content loaded from DB.
-   setActivePrompt(id: string | null): Promise<void> — set selection. Passing `null` clears. If the
    id is not found the selection will be cleared.
-   clearActivePrompt(): void — convenience that clears the selection (calls `setActivePrompt(null)`).
-   getActivePromptContent(): any | null — synchronous getter returning the raw content value.

---

## Types

The composable exposes the following TypeScript shape (approx):

```ts
export interface ActivePromptState {
    activePromptId: string | null;
    activePromptContent: any | null;
}

function useActivePrompt(): {
    activePromptId: Readonly<Ref<string | null>>;
    activePromptContent: Readonly<Ref<any | null>>;
    setActivePrompt(id: string | null): Promise<void>;
    clearActivePrompt(): void;
    getActivePromptContent(): any | null;
};
```

---

## Internals & Notes

-   Module-singleton: the composable uses module-scoped `ref`s so every import/consumer shares the
    same state. This is intentional to keep selection consistent across UI components.
-   `setActivePrompt` is asynchronous and will call `getPrompt(id)` from `~/db/prompts`.
-   After a successful selection the composable dispatches a hook action using the app hooks
    engine: `hooks.doAction('chat.systemPrompt.select:action:after', { id, content })`.
-   If the requested prompt id does not exist the composable clears the active selection.
-   Concurrency: callers should await `setActivePrompt` if they depend on the state being updated
    immediately; multiple concurrent calls may race and the last-resolved call wins.
-   Do not mutate `activePromptContent` or `activePromptId` directly — use the provided methods.

### SSR / Client considerations

-   The composable relies on the DB helper `getPrompt` which is typically a client-side data source
    (Dexie/IndexedDB). Avoid calling `setActivePrompt` during server-side rendering. Reading the
    readonly refs is safe but may initially be `null` on the server.

---

## Related

-   `~/db/prompts` — prompt storage and retrieval used by `setActivePrompt`
-   hooks engine — event emitted: `chat.systemPrompt.select:action:after`

---

## Example (full)

```vue
<template>
    <div>
        <div v-if="activePromptContent">Active: {{ activePromptId }}</div>
        <button @click="select('builtin:short_instruct')">
            Select built-in
        </button>
        <button @click="clear">Clear</button>
    </div>
</template>

<script setup lang="ts">
import { useActivePrompt } from '~/composables/chat/useActivePrompt';

const {
    activePromptId,
    activePromptContent,
    setActivePrompt,
    clearActivePrompt,
} = useActivePrompt();

function select(id: string) {
    setActivePrompt(id);
}
function clear() {
    clearActivePrompt();
}

// exported to template
const activePrompt = { activePromptId, activePromptContent, select, clear };
</script>
```

---

Document generated from `app/composables/chat/useActivePrompt.ts` implementation.
</file>

<file path="composables/useAiSettings.md">
# useAiSettings

Persistence layer for AI preference knobs. Keeps the chat experience consistent by storing master prompts and model defaults in browser storage, while exposing a clean interface for UI controls or automated scripts.

---

## What it covers

`useAiSettings` gives you a reactive settings object and helper methods to read, update, and reset AI chat preferences. It sanitises input, survives hot-module reloads, and only touches storage in the browser.

-   Tracks the current settings in a single global store (HMR-safe)
-   Loads initial values from `localStorage` once per session
-   Persists updates automatically
-   Normalises user input to avoid bad types or unknown keys

---

## Quick start

```ts
import { useAiSettings } from '~/composables/chat/useAiSettings';

const { settings, set } = useAiSettings();

watchEffect(() => {
    console.log('Current default mode:', settings.value.defaultModelMode);
});

set({ defaultModelMode: 'fixed', fixedModelId: 'anthropic/claude-3-sonnet' });
```

---

## API

| Property     | Type                                     | Purpose                                                                      |
| ------------ | ---------------------------------------- | ---------------------------------------------------------------------------- |
| `settings`   | `ComputedRef<AiSettingsV1>`              | Reactive snapshot of the current settings.                                   |
| `set(patch)` | `(patch: Partial<AiSettingsV1>) => void` | Merge in new values, sanitise them, persist to storage.                      |
| `reset()`    | `() => void`                             | Restore defaults and persist them.                                           |
| `load()`     | `() => AiSettingsV1`                     | Re-read from storage, update the reactive store, and return the fresh value. |

### `AiSettingsV1`

```ts
interface AiSettingsV1 {
    version: 1;
    masterSystemPrompt: string;
    defaultModelMode: 'lastSelected' | 'fixed';
    fixedModelId: string | null;
}
```

Defaults:

```ts
const DEFAULT_AI_SETTINGS: AiSettingsV1 = {
    version: 1,
    masterSystemPrompt: '',
    defaultModelMode: 'lastSelected',
    fixedModelId: null,
};
```

---

## How to use it

### Drive a settings form

```vue
<template>
    <form class="space-y-4" @submit.prevent="save">
        <label class="block">
            <span>Master system prompt</span>
            <textarea v-model="prompt" class="retro-input" rows="3" />
        </label>

        <label class="block">
            <span>Default model mode</span>
            <select v-model="mode" class="retro-input">
                <option value="lastSelected">Remember last model</option>
                <option value="fixed">Always use a specific model</option>
            </select>
        </label>

        <label v-if="mode === 'fixed'" class="block">
            <span>Model ID</span>
            <input v-model="modelId" class="retro-input" />
        </label>

        <button type="submit" class="retro-btn">Save</button>
    </form>
</template>

<script setup lang="ts">
import { computed, ref, watch } from 'vue';
import { useAiSettings } from '~/composables/chat/useAiSettings';

const { settings, set } = useAiSettings();

const prompt = ref(settings.value.masterSystemPrompt);
const mode = ref(settings.value.defaultModelMode);
const modelId = ref(settings.value.fixedModelId ?? '');

watch(settings, (next) => {
    prompt.value = next.masterSystemPrompt;
    mode.value = next.defaultModelMode;
    modelId.value = next.fixedModelId ?? '';
});

function save() {
    set({
        masterSystemPrompt: prompt.value,
        defaultModelMode: mode.value,
        fixedModelId: mode.value === 'fixed' ? modelId.value || null : null,
    });
}
</script>
```

### Reset to defaults

```ts
const { reset } = useAiSettings();

reset();
```

### Hard refresh from storage

```ts
const { load } = useAiSettings();

const latest = load();
console.log('Reloaded settings', latest);
```

---

## Internal mechanics

1. **Singleton store**: A global object placed on `globalThis` survives HMR and ensures only one reactive store. The store holds `{ settings: Ref<AiSettingsV1>, loaded: boolean }`.
2. **Lazy hydration**: On first call in the browser, `loadFromStorage()` runs. Server contexts keep defaults because `window`/`document` are missing.
3. **Sanitisation**: `sanitizeAiSettings()` strips unknown keys, forces `defaultModelMode` to the allowed union, and normalises `fixedModelId`.
4. **Persistence**: `set` immediately writes to storage. A deep `watch` also saves direct mutations made outside of `set` for compatibility.
5. **Safety**: All storage access is wrapped in try/catch with console warnings in dev mode to avoid breaking the app when storage is unavailable.

---

## Edge cases & tips

-   **SSR**: Guarded by `isBrowser()` so storage isn’t touched during server rendering.
-   **Storage quota**: Failures fall back to logging a warning; settings stay in memory for the session.
-   **HMR**: Because the store lives on `globalThis`, you can tweak the composable without losing user-configured settings while the dev server is running.
-   **Direct mutations**: Prefer `set`, but the deep watch ensures manual changes like `settings.value.masterSystemPrompt = '...'` still persist.

---

## Related references

-   `useChat` — respects the defaults defined here.
-   `useAiSettingsPanel` (if present) — typical consumer for user-facing UI.
-   `AI_SETTINGS_STORAGE_KEY` — storage key constant if you need to inspect it manually.
</file>

<file path="composables/useChat.md">
# useChat

The main composable for managing AI chat conversations in OR3. Handles sending messages, streaming responses, retrying failed messages, and managing conversation state.

Think of `useChat` as your chat conversation manager — it keeps track of all messages, talks to the AI, and handles everything from loading states to error recovery.

---

## What does it do?

`useChat` is the heart of every chat conversation. When you want to:

- Send a message to an AI model
- Display a conversation with streaming responses
- Retry a failed message
- Show loading states while the AI is thinking
- Cancel an ongoing AI response

...this composable handles all of that for you.

---

## Basic Example

Here's the simplest way to use it:

```vue
<script setup>
import { useChat } from '~/composables/chat/useAi';

// Create a new chat
const chat = useChat();

// Send a message
async function ask() {
  await chat.sendMessage('Hello, how are you?');
}
</script>

<template>
  <div>
    <!-- Show all messages -->
    <div v-for="msg in chat.messages.value" :key="msg.id">
      <strong>{{ msg.role }}:</strong> {{ msg.text }}
    </div>

    <!-- Show loading state -->
    <div v-if="chat.loading.value">AI is thinking...</div>

    <!-- Send button -->
    <button @click="ask" :disabled="chat.loading.value">
      Send Message
    </button>
  </div>
</template>
```

---

## How to use it

### 1. Create a chat instance

```ts
// Start a new conversation
const chat = useChat();

// Or continue an existing thread
const chat = useChat(existingMessages, 'thread-id-123');

// Or with a pending system prompt
const chat = useChat([], undefined, 'prompt-id-456');
```

### 2. Send messages

```ts
// Simple text message
await chat.sendMessage('What is the weather like?');

// Message with images/files
await chat.sendMessage('Describe this image', {
  files: [{ type: 'image/png', url: 'https://...' }],
  model: 'openai/gpt-4-vision',
  online: false
});

// Message with file attachments (by hash)
await chat.sendMessage('Analyze these files', {
  file_hashes: ['abc123', 'def456'],
  model: 'anthropic/claude-3-sonnet'
});
```

### 3. Handle the response

The AI response appears in two places:

- **During streaming**: `chat.tailAssistant.value` shows the message being written
- **After complete**: The message moves to `chat.messages.value`

```vue
<template>
  <!-- Show completed messages -->
  <div v-for="msg in chat.messages.value" :key="msg.id">
    {{ msg.text }}
  </div>

  <!-- Show streaming message (being written right now) -->
  <div v-if="chat.tailAssistant.value" class="streaming">
    {{ chat.tailAssistant.value.text }}
    <span v-if="chat.tailAssistant.value.pending">▋</span>
  </div>
</template>
```

### 4. Retry failed messages

If a message fails, you can retry it:

```ts
// Retry with the same model
await chat.retryMessage(failedMessageId);

// Retry with a different model
await chat.retryMessage(failedMessageId, 'anthropic/claude-3-opus');
```

### 5. Cancel ongoing responses

```ts
// Stop the AI mid-response
chat.abort();
```

### 6. Clear everything

```ts
// Remove all messages and reset state
chat.clear();
```

---

## What you get back

When you call `useChat()`, you get an object with:

| Property | Type | Description |
|----------|------|-------------|
| `messages` | `Ref<UiChatMessage[]>` | All finalized messages in the conversation |
| `loading` | `Ref<boolean>` | `true` while waiting for AI response |
| `threadId` | `Ref<string \| undefined>` | The database thread ID for this conversation |
| `streamId` | `Ref<string \| undefined>` | Current streaming message ID |
| `streamState` | `object` | Stream status: `{ active, finalized, error, aborted }` |
| `tailAssistant` | `Ref<UiChatMessage \| null>` | The AI message currently being streamed (not in `messages` yet) |
| `sendMessage` | `function` | Send a new user message |
| `retryMessage` | `function` | Retry a failed message |
| `abort` | `function` | Cancel the current AI response |
| `clear` | `function` | Clear all messages |
| `resetStream` | `function` | Reset stream state (usually automatic) |
| `flushTailAssistant` | `function` | Move `tailAssistant` into `messages` (usually automatic) |

---

## Message format

### UiChatMessage

This is what you see in `messages.value` and `tailAssistant.value`:

```ts
interface UiChatMessage {
  id: string;                    // unique message ID
  role: 'user' | 'assistant' | 'system';
  text: string;                  // the actual message text
  file_hashes?: string[];        // attached file references
  reasoning_text?: string;       // AI's reasoning (if model supports it)
  stream_id?: string;            // for tracking streaming messages
  pending?: boolean;             // true while streaming
}
```

### SendMessageParams

Optional parameters when sending a message:

```ts
interface SendMessageParams {
  files?: { type: string; url: string }[];  // images or files to attach
  model?: string;                           // AI model to use (e.g., 'openai/gpt-4')
  file_hashes?: string[];                   // reference existing files by hash
  extraTextParts?: string[];                // additional text segments
  online: boolean;                          // enable web search (adds ':online' suffix)
}
```

---

## How it works (under the hood)

Here's what happens when you send a message:

1. **Check API key**: Won't send without OpenRouter API key
2. **Apply filters**: Runs `ui.chat.message:filter:outgoing` hook (can block message)
3. **Create thread**: If this is the first message, creates a new thread in the database
4. **Load system prompt**: Fetches the active system prompt for context
5. **Add user message**: Saves your message to the database and updates `messages.value`
6. **Prepare AI request**: 
   - Builds conversation history
   - Removes empty assistant messages (API requirement)
   - Converts to OpenRouter format
   - Applies image limit (5 images max to avoid rate limits)
7. **Start streaming**: Opens a stream to OpenRouter API
8. **Process chunks**: As AI responds:
   - Text chunks update `tailAssistant.value.text`
   - Generated images get saved and attached
   - Reasoning text (if supported) goes into `reasoning_text`
   - Progress saved to DB every 500ms
9. **Apply incoming filter**: Runs `ui.chat.message:filter:incoming` hook
10. **Finalize**: Saves complete message to DB and emits completion hooks

If anything fails, the error is caught and you can retry.

---

## Common patterns

### Check if chat is ready

```ts
if (chat.loading.value) {
  console.log('Please wait, AI is responding...');
}
```

### Show streaming indicator

```vue
<div v-if="chat.tailAssistant.value?.pending">
  AI is typing<span class="dots">...</span>
</div>
```

### Handle retry button

```vue
<button 
  v-if="message.error" 
  @click="chat.retryMessage(message.id)"
>
  Retry
</button>
```

### Cancel long responses

```vue
<button 
  v-if="chat.loading.value" 
  @click="chat.abort"
  class="danger"
>
  Stop Generating
</button>
```

### Multi-model support

```ts
// Let user pick model
const selectedModel = ref('anthropic/claude-3-sonnet');

await chat.sendMessage(userInput, {
  model: selectedModel.value,
  online: false
});
```

### Attach images

```ts
// From file input
const fileUrl = URL.createObjectURL(file);
await chat.sendMessage('What is this?', {
  files: [{ type: file.type, url: fileUrl }],
  model: 'openai/gpt-4-vision'
});
```

---

## Important notes

### Memory management

- `messages.value` contains finalized messages only
- `tailAssistant.value` holds the message currently being streamed
- When you send a new message, `tailAssistant` automatically moves to `messages`
- Call `clear()` to free memory if the conversation gets very long

### Thread creation

If you don't provide a `threadId`, the first `sendMessage` creates one automatically:
- Title: first 6 words of your message
- System prompt: uses pending prompt or default
- Timestamp: set to now

### Retry behavior

When you retry a message:
1. Finds the user message and its assistant response
2. Deletes both from database and memory
3. Re-sends with original text and attachments
4. Creates new message IDs

### Hooks integration

The composable emits several hook events you can listen to:

- `ui.chat.message:filter:outgoing` — before sending (can veto)
- `ui.chat.message:filter:incoming` — after receiving (can transform)
- `ai.chat.model:filter:select` — choose/override model
- `ai.chat.messages:filter:input` — modify conversation history
- `ai.chat.send:action:before` — before AI call
- `ai.chat.send:action:after` — after completion/abort
- `ai.chat.stream:action:complete` — stream finished
- `ai.chat.stream:action:error` — stream error
- `ai.chat.retry:action:before` — before retry
- `ai.chat.retry:action:after` — after retry
- `ui.pane.msg:action:sent` — multi-pane message sent
- `ui.pane.msg:action:received` — multi-pane message received

### Image handling

- User images: displayed in attachments gallery (not embedded in text)
- AI-generated images: embedded as markdown `![image](url)` in message text
- Image limit: Max 5 images per request (automatically trimmed)
- Previous assistant images are carried forward in conversation

### Model selection

If you don't specify a model, it uses:
1. Last selected model (from localStorage)
2. Fixed model (from settings)
3. Fallback: `openai/gpt-oss-120b`

### Online mode

Add `:online` suffix to enable web search:
```ts
await chat.sendMessage('Latest news?', {
  model: 'anthropic/claude-3-sonnet',
  online: true  // becomes 'anthropic/claude-3-sonnet:online'
});
```

---

## Troubleshooting

### "Message blocked"
Your message was filtered by an outgoing hook. Check hook extensions.

### Empty responses
Check if API key is valid and model is available.

### Stream errors
Usually network issues or invalid API responses. Retry should work.

### Memory issues with long conversations
Call `clear()` or create a new chat instance for fresh conversation.

### Images not showing
- User images: Check `file_hashes` are valid
- AI images: Must use vision-capable model

---

## Related

- `useActivePrompt` — manage system prompts
- `useUserApiKey` — OpenRouter API key management
- `useAiSettings` — model preferences and master system prompt
- `useModelStore` — available models catalog
- `~/db/messages` — direct database access
- `~/db/threads` — thread management

---

## TypeScript

Full type signature:

```ts
function useChat(
  msgs?: ChatMessage[],
  initialThreadId?: string,
  pendingPromptId?: string
): {
  messages: Ref<UiChatMessage[]>;
  loading: Ref<boolean>;
  threadId: Ref<string | undefined>;
  streamId: Ref<string | undefined>;
  streamState: {
    active: Ref<boolean>;
    finalized: Ref<boolean>;
    error: Ref<Error | null>;
    aborted: Ref<boolean>;
  };
  tailAssistant: Ref<UiChatMessage | null>;
  sendMessage: (content: string, params?: SendMessageParams) => Promise<void>;
  retryMessage: (messageId: string, modelOverride?: string) => Promise<void>;
  abort: () => void;
  clear: () => void;
  resetStream: () => void;
  flushTailAssistant: () => void;
}
```

---

## Example: Full chat component

```vue
<template>
  <div class="chat-container">
    <!-- Message list -->
    <div class="messages">
      <div 
        v-for="msg in chat.messages.value" 
        :key="msg.id"
        :class="`message message-${msg.role}`"
      >
        <div class="role">{{ msg.role }}</div>
        <div class="text">{{ msg.text }}</div>
        <button 
          v-if="msg.role === 'assistant'" 
          @click="retry(msg.id)"
          class="retry-btn"
        >
          ↻ Retry
        </button>
      </div>

      <!-- Streaming message -->
      <div 
        v-if="chat.tailAssistant.value" 
        class="message message-assistant streaming"
      >
        <div class="role">assistant</div>
        <div class="text">
          {{ chat.tailAssistant.value.text }}
          <span v-if="chat.tailAssistant.value.pending" class="cursor">▋</span>
        </div>
      </div>
    </div>

    <!-- Input area -->
    <div class="input-area">
      <textarea 
        v-model="input" 
        @keydown.enter.meta="send"
        :disabled="chat.loading.value"
        placeholder="Type your message..."
      />
      <button 
        v-if="!chat.loading.value"
        @click="send"
        :disabled="!input.trim()"
      >
        Send
      </button>
      <button 
        v-else
        @click="chat.abort()"
        class="stop-btn"
      >
        Stop
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { useChat } from '~/composables/chat/useAi';

const chat = useChat();
const input = ref('');

async function send() {
  if (!input.value.trim()) return;
  const text = input.value;
  input.value = '';
  await chat.sendMessage(text);
}

async function retry(messageId: string) {
  await chat.retryMessage(messageId);
}
</script>

<style scoped>
.chat-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

.messages {
  flex: 1;
  overflow-y: auto;
  padding: 1rem;
}

.message {
  margin-bottom: 1rem;
  padding: 0.5rem;
  border-radius: 4px;
}

.message-user {
  background: #e3f2fd;
  margin-left: 20%;
}

.message-assistant {
  background: #f5f5f5;
  margin-right: 20%;
}

.streaming .cursor {
  animation: blink 1s infinite;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

.input-area {
  display: flex;
  gap: 0.5rem;
  padding: 1rem;
  border-top: 1px solid #ddd;
}

textarea {
  flex: 1;
  padding: 0.5rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  resize: none;
  font-family: inherit;
}

button {
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 4px;
  background: #2196f3;
  color: white;
  cursor: pointer;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.stop-btn {
  background: #f44336;
}

.retry-btn {
  margin-top: 0.5rem;
  font-size: 0.875rem;
  background: #757575;
}
</style>
```

---

Document generated from `app/composables/chat/useAi.ts` implementation.
</file>

<file path="composables/useChatInputBridge.md">
# useChatInputBridge

Lightweight registry that lets external features (pane plugins, slash commands, automation) inject chat messages into an existing chat input without duplicating business logic.

---

## Why it exists

`useChatInputBridge` exposes a tiny, reactive directory of chat inputs keyed by `paneId`. Chat containers register their imperative API and the bridge forwards programmatic sends through the same UI pipeline a user click would trigger.

-   Keeps message handling inside `ChatInputDropper`
-   Avoids rehydrating chat state or bypassing hooks
-   Supports multiple panes/windows
-   Safe in dev (HMR-resilient)

---

## Surface area

| Function              | Signature                                               | Purpose                                                                                                    |
| --------------------- | ------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| `registerPaneInput`   | `(paneId: string, api: ChatInputImperativeApi) => void` | Register or update the imperative API for a pane. Called by the chat input component on mount/HMR.         |
| `unregisterPaneInput` | `(paneId: string) => void`                              | Remove the pane entry on unmount.                                                                          |
| `programmaticSend`    | `(paneId: string, text: string) => boolean`             | Push text into the pane input and trigger its native send handler. Returns `false` if the pane is missing. |
| `hasPane`             | `(paneId: string) => boolean`                           | Test whether a pane is currently registered.                                                               |

### `ChatInputImperativeApi`

```ts
interface ChatInputImperativeApi {
    setText(t: string): void;
    triggerSend(): void;
}
```

---

## Typical usage

### Registering inside a chat pane

```ts
import { onMounted, onUnmounted } from 'vue';
import {
    registerPaneInput,
    unregisterPaneInput,
} from '~/composables/chat/useChatInputBridge';

const paneId = usePaneId();

onMounted(() => {
    registerPaneInput(paneId, {
        setText: (value) => (messageInput.value = value),
        triggerSend: () => sendMessage(),
    });
});

onUnmounted(() => {
    unregisterPaneInput(paneId);
});
```

### Sending from an external plugin

```ts
import { programmaticSend } from '~/composables/chat/useChatInputBridge';

const success = programmaticSend(activePaneId, '/imagine neon city at dusk');

if (!success) {
    console.warn('Pane not ready yet');
}
```

---

## Implementation notes

1. **Registry** — Maintains a `Ref<RegisteredPaneInput[]>`. Lookup happens through the helper `find(paneId)` to keep the public API concise.
2. **Updates** — Re-registering the same pane ID replaces the stored API so HMR or re-renders don’t stack duplicates.
3. **Error handling** — `programmaticSend` wraps calls in `try/catch`; errors log in dev mode and return `false` so callers can retry or surface UI feedback.
4. **Debug hook** — In dev, the registry is exposed on `globalThis.__or3ChatInputBridge` for console inspection.
5. **No storage** — Everything lives in memory; it only coordinates runtime components.

---

## Tips & gotchas

-   Always call `unregisterPaneInput` on unmount to keep the registry clean.
-   `programmaticSend` does nothing server-side; ensure it runs in the client.
-   Avoid invoking it before the pane finishes mounting—`hasPane` lets you guard against that.
-   Keep `paneId` stable per chat instance so automations target the right recipient.

---

## Related modules

-   `ChatInputDropper.vue` — actual UI input exposing the imperative API.
-   `pane-plugin-api` — typical consumer needing programmatic sends.
-   `useChat` — eventual destination for messages triggered through the bridge.
</file>

<file path="composables/useComposerActions.md">
# useComposerActions

Composer action registry powering the quick-action buttons beneath the chat composer. Lets plugins add buttons that hook into the active editor, thread, or pane context with visibility and disabled logic.

---

## What does it do?

`useComposerActions` manages a global list of composer actions:

-   `registerComposerAction()` adds or replaces an action definition.
-   `useComposerActions(contextFn)` returns a computed list of actions + disabled state derived from the current pane.
-   `unregisterComposerAction()` cleans up during teardown/HMR.
-   `listRegisteredComposerActionIds()` helps debug what’s registered.

Actions can check editor state, streaming status, thread IDs, etc., and render with retro-friendly icons and colors.

---

## Basic Example

```ts
import {
    registerComposerAction,
    unregisterComposerAction,
    useComposerActions,
} from '~/composables/sidebar/useComposerActions';

registerComposerAction({
    id: 'custom:clear-editor',
    icon: 'i-ph-broom',
    label: 'Clear',
    color: 'warning',
    order: 180,
    handler: ({ editor }) => editor?.commands.clearContent(),
    disabled: ({ editor }) => !editor || editor.isEmpty,
});

const actions = useComposerActions(() => ({ editor: editorRef.value }));

onScopeDispose(() => unregisterComposerAction('custom:clear-editor'));
```

---

## How to use it

### 1. Register actions during setup

Call `registerComposerAction()` in a plugin or component. Namespace IDs (`your-plugin:action`) to avoid collisions. The composable freezes your payload to prevent accidental mutation.

### 2. Provide context to consumers

`useComposerActions(contextFn)` accepts a function returning the latest `ComposerActionContext` (editor ref, thread ID, streaming flag, etc.). When context values change, the computed array updates automatically.

### 3. Control visibility and disabled state

-   `visible(ctx)` hides the button when it returns `false`.
-   `disabled(ctx)` grays it out while keeping it in the layout.

Both callbacks run every render, so keep logic fast and side-effect free.

### 4. Handle clicks

`handler(ctx)` executes when the button is clicked. You can return a promise to perform async work (e.g., API calls). The UI doesn’t await by default—manage loading state externally if needed.

### 5. Clean up on unmount/HMR

Always call `unregisterComposerAction()` (or use `useHookEffect`) to avoid duplicate buttons when modules reload.

---

## What you get back

`useComposerActions(contextFn)` returns a `ComputedRef<ComposerActionEntry[]>`. Each entry includes the original `action` plus a `disabled` flag evaluated against the latest context.

| Property   | Type                                  | Description                                |
| ---------- | ------------------------------------- | ------------------------------------------ | --------------- |
| `id`       | `string`                              | Unique identifier.                         |
| `icon`     | `string`                              | Iconify name rendered in the composer bar. |
| `tooltip`  | `string \| undefined`                 | Optional hover text.                       |
| `label`    | `string \| undefined`                 | Optional button label.                     |
| `order`    | `number \| undefined`                 | Sorting hint (defaults to 200).            |
| `color`    | `ChromeActionColor \| undefined`      | Nuxt UI color token for button styling.    |
| `handler`  | `(ctx: ComposerActionContext) => void | Promise<void>`                             | Click callback. |
| `visible`  | `(ctx) => boolean`                    | Optional visibility predicate.             |
| `disabled` | `(ctx) => boolean`                    | Optional disabled predicate.               |

---

## API

```ts
registerComposerAction(action: ComposerAction): void;
unregisterComposerAction(id: string): void;
useComposerActions(context?: () => ComposerActionContext): ComputedRef<ComposerActionEntry[]>;
listRegisteredComposerActionIds(): string[];
```

---

## Under the hood

1. **Global registry** – Stores actions on `globalThis.__or3ComposerActionsRegistry`, ensuring a single source of truth across imports.
2. **Reactive list** – Mirrors the map with a Vue `reactive` wrapper so computed consumers react to updates.
3. **Sorting** – Ensures deterministic order via `order ?? 200` ascending.
4. **Immutability** – Actions are `Object.freeze`d to prevent accidental runtime mutation after registration.

---

## Edge cases & tips

-   **Duplicate IDs**: Later registrations overwrite earlier ones; dev mode logs a warning.
-   **Missing context**: All predicates receive an empty object if you omit `contextFn`—guard for undefined fields.
-   **Async errors**: Handlers should catch their own errors and show toasts; the registry doesn’t intercept failures.
-   **Streaming state**: Use `isStreaming` to disable actions while the AI is responding.

---

## Related

-   `useHeaderActions` — similar registry for the sidebar header buttons.
-   `useSidebarSections` — adds custom panels and footer actions to the chrome.
-   `~/app/components/chat` — consumes composer actions to render the button row.

---

## TypeScript

```ts
interface ComposerActionContext {
    editor?: Editor | null;
    threadId?: string | null;
    paneId?: string | null;
    isStreaming?: boolean;
}

interface ComposerAction {
    id: string;
    icon: string;
    tooltip?: string;
    label?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: ComposerActionContext) => void | Promise<void>;
    visible?: (ctx: ComposerActionContext) => boolean;
    disabled?: (ctx: ComposerActionContext) => boolean;
}
```
</file>

<file path="composables/useDashboardPlugins.md">
# useDashboardPlugins

Dashboard extension hub that lets first- and third-party features register launcher tiles, lazy-loaded pages, and capability flags for the retro dashboard. It centralises plugin discovery, page resolution, and in-app navigation state.

---

## What does it do?

`useDashboardPlugins` and its sibling utilities give you a full plugin registry:

-   `registerDashboardPlugin` / `unregisterDashboardPlugin` keep a global map of tiles, their icons, handlers, and optional inline pages.
-   `registerDashboardPluginPage` normalises page definitions, marks components as raw, and handles lazy factories + caches.
-   `useDashboardPlugins()` exposes a sorted, reactive list for rendering the dashboard grid.
-   `useDashboardNavigation()` orchestrates the dashboard → plugin → page flow, resolving components on demand and surfacing errors.
-   Capability helpers (`hasCapability`, `hasAllCapabilities`, etc.) enforce optional permission checks per plugin.

The registry survives HMR and SSR hydration thanks to `globalThis` caching and careful cloning/marking of reactive components.

---

## Basic Example

```ts
import {
    registerDashboardPlugin,
    registerDashboardPluginPage,
    useDashboardNavigation,
} from '~/composables/dashboard/useDashboardPlugins';

registerDashboardPlugin({
    id: 'notes',
    icon: 'i-ph-note-pencil',
    label: 'Notes',
    order: 120,
    capabilities: ['canWriteDocs'],
});

registerDashboardPluginPage('notes', {
    id: 'compose',
    title: 'Compose note',
    component: () => import('~/components/dashboard/NotesCompose.vue'),
});

const { dashboardItems, openPlugin, landingPages, openPage } =
    useDashboardNavigation();

await openPlugin('notes');
await openPage('notes', 'compose');
```

---

## How to use it

### 1. Register plugins early

Call `registerDashboardPlugin()` in a client entry (plugin, layout setup) so the dashboard grid has items on first render. Inline `pages` are optional but handy for declarative registration.

### 2. Define pages (optional)

Use `registerDashboardPluginPage(pluginId, page)` for additional routes or lazy modules. Page components can be direct Vue components or async factories; the registry caches the resolved component per plugin/page pair.

### 3. Drive the UI with `useDashboardNavigation`

The navigation composable merges built-in base items with registered plugins. It exposes:

-   `dashboardItems` — sorted tiles, ready for rendering.
-   `openPlugin(id)` — opens a plugin tile; routes to sole page automatically.
-   `openPage(pluginId, pageId)` — resolves and mounts a page component, tracking loading state and errors.
-   `goBack()` / `reset()` — return to the dashboard view.

Use `resolvedPageComponent` to mount the current page inside a `<component>`.

### 4. Enforce capabilities when needed

`hasCapability`, `hasAnyCapability`, and `hasAllCapabilities` read declarations from the registered plugin. Wire these into guards, button states, or context menus.

---

## API

### Plugin registry

```ts
registerDashboardPlugin(plugin: DashboardPlugin): void;
unregisterDashboardPlugin(id: string): void;
useDashboardPlugins(): ComputedRef<DashboardPlugin[]>;
listRegisteredDashboardPluginIds(): string[];
```

### Page registry

```ts
registerDashboardPluginPage(pluginId: string, page: DashboardPluginPage): void;
unregisterDashboardPluginPage(pluginId: string, pageId?: string): void;
useDashboardPluginPages(getId: () => string | undefined): ComputedRef<DashboardPluginPage[]>;
listDashboardPluginPages(pluginId: string): DashboardPluginPage[];
getDashboardPluginPage(pluginId: string, pageId: string): DashboardPluginPage | undefined;
resolveDashboardPluginPageComponent(pluginId: string, pageId: string): Promise<Component | undefined>;
```

### Navigation runtime

```ts
useDashboardNavigation(options?: { baseItems?: DashboardPlugin[] }): {
    state: Readonly<DashboardNavigationState>;
    resolvedPageComponent: Readonly<ShallowRef<Component | null>>;
    dashboardItems: ComputedRef<DashboardPlugin[]>;
    landingPages: ComputedRef<DashboardPluginPage[]>;
    headerPluginLabel: ComputedRef<string>;
    activePageTitle: ComputedRef<string>;
    openPlugin(pluginId: string): Promise<DashboardNavigationResult>;
    openPage(pluginId: string, pageId: string): Promise<DashboardNavigationResult>;
    goBack(): void;
    reset(): void;
};
```

### Capability helpers

```ts
hasCapability(pluginId: string, capability: string): boolean;
getPluginCapabilities(pluginId: string): string[];
hasAllCapabilities(pluginId: string, capabilities: string[]): boolean;
hasAnyCapability(pluginId: string, capabilities: string[]): boolean;
```

---

## Under the hood

1. **Global registries** — Uses `globalThis` slots so plugins survive HMR and SSR boundary crossings without duplicate registration.
2. **Reactive projections** — Keeps `reactiveList` and `reactivePages` mirrors for Vue consumers, ensuring computed getters remain responsive.
3. **Ordering** — Applies `DEFAULT_ORDER` (200) when no explicit order is set, making plugin placement predictable.
4. **Component caching** — Memoises resolved page components, clears caches on unregister, and marks resolved objects with `markRaw` to preserve Vue perf.
5. **Navigation state** — A singleton runtime tracks view mode, active plugin/page ids, loading state, and errors while exposing read-only refs to the UI.

---

## Edge cases & tips

-   **Duplicate IDs**: In dev, re-registering a plugin logs a warning but still replaces it—handy during HMR but avoid in production.
-   **Lazy pages**: If an async page loader returns a non-component, dev mode warns and the nav surfaces a `resolve-error` result.
-   **Single-page plugins**: `openPlugin()` auto-opens the lone page, simplifying button handlers.
-   **Error handling**: `openPlugin`/`openPage` return `{ ok: false, error }` with codes (`missing-plugin`, `missing-page`, `handler-error`, `resolve-error`) for structured UI reactions.
-   **Capability checks**: All capability helpers safely return `false` when the plugin is absent or declarations are missing—no need for extra guards.

---

## Related

-   `~/composables/dashboard` — home for dashboard-specific extensions.
-   `~/core/hooks` — hook system often used by plugins during registration.
-   `~/app/components/dashboard` — grid and page host components that consume `useDashboardNavigation`.
</file>

<file path="composables/useDefaultPrompt.md">
# useDefaultPrompt

Central helper for tracking the default system prompt across chat panes. It wraps the `kv` table, keeps a singleton ref of the active prompt ID, and fires hooks when the default changes so other modules can react.

---

## Overview

`useDefaultPrompt` gives you a reactive `defaultPromptId` alongside helpers to set or clear it. Behind the scenes it reads from Dexie on first use, stores the value in `kv` under `default_system_prompt_id`, and triggers a hook so panes refresh their copy.

-   Loads once per session (client-side) and caches the id in a shared ref
-   Keeps mutations synced to IndexedDB + in-memory state
-   Exposes `clearDefaultPrompt()` and `ensureLoaded()` helpers
-   Provides a `getDefaultPromptId()` utility for low-level access

---

## Quick start

```ts
import { useDefaultPrompt } from '~/composables/chat/useDefaultPrompt';

const { defaultPromptId, setDefaultPrompt, clearDefaultPrompt } =
    useDefaultPrompt();

watch(defaultPromptId, (id) => {
    console.log('Default prompt is now', id ?? 'not set');
});

await setDefaultPrompt('prompt-123');
// ... later
await clearDefaultPrompt();
```

---

## API

| Member                 | Type                                    | Description                                                           |
| ---------------------- | --------------------------------------- | --------------------------------------------------------------------- |
| `defaultPromptId`      | `ReadonlyRef<string \| null>`           | Reactive id for the default system prompt (or `null`).                |
| `setDefaultPrompt(id)` | `(id: string \| null) => Promise<void>` | Persist a new default prompt id (or `null`) and broadcast hook event. |
| `clearDefaultPrompt()` | `() => Promise<void>`                   | Convenience alias for `setDefaultPrompt(null)`.                       |
| `ensureLoaded()`       | `() => Promise<void>`                   | Force-load the cached value (useful during SSR guards).               |

### Standalone helper

| Function               | Description                                                                                                   |
| ---------------------- | ------------------------------------------------------------------------------------------------------------- |
| `getDefaultPromptId()` | Async function that reads directly from Dexie and returns the stored id without touching the singleton store. |

---

## How it works

1. **Singleton state** — The ref `_defaultPromptId` lives at module scope, so every caller shares the same reactive value.
2. **Lazy load** — `loadOnce()` reads `kv` only the first time a browser caller uses the composable. On SSR it no-ops because Dexie isn’t available.
3. **Updates** — `setDefaultPrompt()` updates the ref, persists via `setKvByName`, then fires `chat.systemPrompt.default:action:update` with the new id so listeners refresh.
4. **Clearing** — `clearDefaultPrompt()` simply calls `setDefaultPrompt(null)`.
5. **Direct access** — `getDefaultPromptId()` is exported for non-reactive flows (e.g. server actions) that just need the value once.

---

## Usage patterns

### Create a settings toggle

```ts
const { defaultPromptId, setDefaultPrompt } = useDefaultPrompt();

async function applyPrompt(promptId: string) {
    await setDefaultPrompt(promptId);
}
```

### Guard before loading prompt content

```ts
const { ensureLoaded, defaultPromptId } = useDefaultPrompt();

await ensureLoaded();
if (defaultPromptId.value) {
    await loadPrompt(defaultPromptId.value);
}
```

### Server-side lookup

```ts
import { getDefaultPromptId } from '~/composables/chat/useDefaultPrompt';

const promptId = await getDefaultPromptId();
if (promptId) {
    // fetch prompt details from db
}
```

---

## Edge cases & notes

-   **Client-only loading** — The composable guards on `import.meta.client`; SSR imports will see `defaultPromptId` remain `null` until the client hydrates.
-   **Missing record** — If the key isn’t present, the ref is set to `null` and no errors bubble up.
-   **Hook listeners** — Consumers can subscribe with `useHooks().addAction('chat.systemPrompt.default:action:update', handler)` to respond whenever the default changes.
-   **Error handling** — Storage read/write operations are wrapped in try/catch; failures simply keep the ref at `null`.

---

## Related references

-   `useActivePrompt` — to manage prompt details once you have the id.
-   `~/db/kv` — utility wrapping Dexie’s key-value store.
-   `chat.systemPrompt.default:action:update` — hook dispatched after every update.
</file>

<file path="composables/useDocumentHistoryActions.md">
# useDocumentHistoryActions

Registry composable that lets plugins inject extra actions into the document history sidebar menu. Keeps a global list of action buttons, sorts them, and survives HMR so dashboard add-ons can extend the UI safely.

---

## What does it do?

`useDocumentHistoryActions` powers the dropdown on each document history item:

-   `registerDocumentHistoryAction()` adds or replaces an action definition.
-   `useDocumentHistoryActions()` returns a sorted, reactive array of actions for rendering.
-   `unregisterDocumentHistoryAction()` removes actions during cleanup to avoid duplicates.
-   `listRegisteredDocumentHistoryActionIds()` helps authors inspect what’s already registered.

Because the registry lives on `globalThis`, the set of actions persists across hot reloads and SSR hydration.

---

## Basic Example

```ts
import {
    registerDocumentHistoryAction,
    unregisterDocumentHistoryAction,
    useDocumentHistoryActions,
} from '~/composables/documents/useDocumentHistoryActions';

registerDocumentHistoryAction({
    id: 'export-pdf',
    icon: 'i-ph-file-pdf',
    label: 'Export as PDF',
    order: 210,
    async handler({ document }) {
        await exportDocumentToPdf(document.id);
    },
});

const actions = useDocumentHistoryActions();

onScopeDispose(() => {
    unregisterDocumentHistoryAction('export-pdf');
});
```

---

## How to use it

### 1. Register on startup or inside a hook

Call `registerDocumentHistoryAction()` when your plugin initialises. Use `useHookEffect()` if you need automatic cleanup on HMR/unmount.

### 2. Provide a unique ID and icon

-   Prefix IDs with your namespace (`my-plugin:download`) to avoid conflicts.
-   Supply an Iconify name that fits the retro UI.

### 3. Handle the click

The handler receives `{ document }` where `document` is the Dexie `Post` record. Perform async work freely; the dropdown stays responsive.

### 4. Render the actions

Components like the document sidebar call `useDocumentHistoryActions()` to read the current list. You can do the same to inject actions into custom UIs or tests.

---

## What you get back

`useDocumentHistoryActions()` returns a computed ref sorted by `order` (default 200), so lower numbers appear first.

| Property  | Type                                                 | Description                        |
| --------- | ---------------------------------------------------- | ---------------------------------- |
| `id`      | `string`                                             | Unique identifier for the action.  |
| `icon`    | `string`                                             | Iconify name rendered in the menu. |
| `label`   | `string`                                             | Button text shown in the dropdown. |
| `order`   | `number \| undefined`                                | Placement hint (defaults to 200).  |
| `handler` | `(ctx: { document: Post }) => void \| Promise<void>` | Click callback.                    |

---

## API

```ts
registerDocumentHistoryAction(action: DocumentHistoryAction): void;
unregisterDocumentHistoryAction(id: string): void;
useDocumentHistoryActions(): ComputedRef<DocumentHistoryAction[]>;
listRegisteredDocumentHistoryActionIds(): string[];
```

---

## Under the hood

1. **Global map** – Stores actions on `globalThis.__or3DocumentHistoryActionsRegistry` to persist across reloads.
2. **Reactive mirror** – Maintains `reactiveList.items` so Vue can track changes without making the map reactive.
3. **Sorting** – Consumers sort by `order` on every read, ensuring deterministic menus.
4. **HMR-safe** – Re-registering an existing ID simply replaces the entry; dev mode can warn upstream.

---

## Edge cases & tips

-   **Duplicate IDs**: Later registrations replace earlier ones. If that’s unintentional, inspect `listRegisteredDocumentHistoryActionIds()`.
-   **Order gaps**: You don’t need consecutive numbers—stick to buckets (100 built-ins, 200 extensions, etc.).
-   **Cleanup**: Always unregister on scope dispose to avoid stale actions when HMR tears down modules.
-   **Error handling**: Wrap handler logic in try/catch and surface toast notifications yourself; the registry doesn’t swallow errors.

---

## Related

-   `useHookEffect` — ideal for registering/unregistering actions inside plugin lifecycles.
-   `~/app/components/sidebar/DocumentHistory.vue` — renders the menu that consumes this registry.
-   `~/db/posts` — source type for the `document` payload.

---

## TypeScript

```ts
interface DocumentHistoryAction {
    id: string;
    icon: string;
    label: string;
    order?: number;
    handler: (ctx: { document: Post }) => void | Promise<void>;
}
```
</file>

<file path="composables/useDocumentsList.md">
# useDocumentsList

Lightweight fetch-and-refresh composable for the documents sidebar. Loads recent Dexie `documents` entries, trims heavy fields, and keeps the list fresh when database hooks fire.

---

## What does it do?

`useDocumentsList(limit?)` gives you:

-   A `docs` ref with up to `limit` lightweight document summaries.
-   A `loading` flag optimised for SSR → client hydration.
-   An `error` ref populated when Dexie calls fail.
-   A `refresh()` function to reload on demand.
-   Automatic refresh when `db.documents.*` hook events fire on the client.

By trimming `content`, the sidebar avoids storing huge TipTap JSON strings in memory.

---

## Basic Example

```ts
import { useDocumentsList } from '~/composables/documents/useDocumentsList';

const { docs, loading, error, refresh } = useDocumentsList(100);

onMounted(() => {
    if (!loading.value && !docs.value.length) refresh();
});
```

---

## How to use it

### 1. Call the composable in setup

Optionally pass a `limit` (default `200`) to cap results. The first run sets `loading` to `true` so SSR and client HTML match.

### 2. Render the list

`docs.value` contains objects with metadata (`id`, `title`, `postType`, timestamps, `deleted`, `meta`). Bind them into your sidebar or dashboards.

### 3. Handle loading & errors

-   Show spinners while `loading.value` is `true`.
-   Read `error.value` when a fetch fails; a toast is already fired with "Document: list failed".

### 4. Refresh when needed

Call `refresh()` after bulk operations or when server-triggered changes need to propagate. On the client, the composable already listens for:

-   `db.documents.create:action:after`
-   `db.documents.update:action:after`
-   `db.documents.delete:action:*:after`

Those hooks come from the central `$hooks` engine via `useHookEffect` and ensure the list stays current.

---

## What you get back

| Property  | Type                  | Description                                       |
| --------- | --------------------- | ------------------------------------------------- |
| `docs`    | `Ref<Document[]>`     | Array of trimmed document records (no `content`). |
| `loading` | `Ref<boolean>`        | `true` while fetching from Dexie.                 |
| `error`   | `Ref<unknown>`        | Error value if the last fetch failed.             |
| `refresh` | `() => Promise<void>` | Reload the list manually.                         |

The returned `Document` objects keep `content: ''` to satisfy the type while staying lightweight.

---

## Under the hood

1. **Dexie fetch** – Uses `listDocuments(limit)` to query the `documents` store.
2. **Field pruning** – Maps results to a slimmer object before storing in the ref.
3. **Error handling** – Catches failures, stamps `error.value`, and raises a toast.
4. **Hook subscriptions** – Registers `useHookEffect` listeners on the client to refresh after create/update/delete actions.
5. **SSR friendly** – Leaves `loading` true during SSR so hydration sees the same markup.

---

## Edge cases & tips

-   **Server-only usage**: On the server, the hook listeners don’t run. Call `refresh()` manually if you render on the server and stream updates.
-   **Limit tuning**: Adjust `limit` depending on sidebar performance; the query already caps the results client-side.
-   **Custom toasts**: If you need custom messaging, catch `error.value` in your component and display additional context.
-   **Deleted docs**: Entries include a `deleted` flag so you can filter out soft-deleted documents if desired.

---

## Related

-   `~/db/documents` — Dexie helpers used under the hood.
-   `useDocumentsStore` — full document state with content + autosave.
-   `usePaneDocuments` — orchestrates pane-specific document selection.

---

## TypeScript

```ts
function useDocumentsList(limit?: number): {
    docs: Ref<Document[]>;
    loading: Ref<boolean>;
    error: Ref<unknown>;
    refresh: () => Promise<void>;
};
```
</file>

<file path="composables/useDocumentsStore.md">
# useDocumentsStore

Stateful document manager that loads Dexie records, stages edits, debounces autosaves, and coordinates pane-level hooks. It is the backbone for rich text documents in OR3’s multi-pane UI.

---

## What does it do?

`useDocumentsStore` exposes a suite of helpers around a shared `documentsMap` cache:

-   Loads documents via `loadDocument()` and caches them per ID.
-   Tracks pending title/content changes and auto-flushes after 750 ms of inactivity.
-   Sends toast notifications when create/load/save actions fail.
-   Emits `$hooks` events (`ui.pane.doc:action:saved`, `:changed`, etc.) so panes stay in sync.
-   Provides low-level helpers like `releaseDocument()` to drop heavy TipTap JSON from memory.

The map lives in module scope, so every component shares the same live state.

---

## Basic Example

```ts
import {
    newDocument,
    loadDocument,
    setDocumentTitle,
    setDocumentContent,
    useDocumentState,
} from '~/composables/documents/useDocumentsStore';

const doc = await newDocument({ title: 'Untitled doc' });

await loadDocument(doc.id);

setDocumentTitle(doc.id, 'My Notes');
setDocumentContent(doc.id, editorStateJSON);

const state = useDocumentState(doc.id);
watch(
    () => state.status,
    (status) => {
        if (status === 'saved') console.log('Document persisted');
    }
);
```

---

## How to use it

### 1. Create or load records

-   Use `newDocument(initial?)` to create a Dexie record and seed the store.
-   Call `loadDocument(id)` to fetch an existing record into memory. The function resolves to the record (or `null` if missing) and surfaces toasts for not-found errors.

### 2. Stage edits

-   `setDocumentTitle(id, title)` and `setDocumentContent(id, content)` mark changes as pending and schedule a save.
-   Saves batch after 750 ms (configurable via `scheduleSave`’s default).

### 3. Flush explicitly when needed

-   Invoke `flush(id)` to force an immediate save, e.g., before navigation.
-   Pass `{ flush: false }` into `releaseDocument()` if you’ve already flushed.

### 4. Observe status

-   `useDocumentState(id)` returns the shared `DocState` (record, status, pending fields, last error).
-   Status cycles through `'loading' → 'idle' → 'saving' → 'saved'` (or `'error'`).

### 5. Release heavy content

Call `releaseDocument(id, { flush?: boolean, deleteEntry?: boolean })` when you leave a pane to reclaim memory. This clears timers, optional flushes, and drops the record reference so the GC can free the TipTap payload.

---

## What you get back

| Helper                            | Description                                                          |
| --------------------------------- | -------------------------------------------------------------------- |
| `newDocument(initial?)`           | Creates a document and primes the store; emits toast on failure.     |
| `loadDocument(id)`                | Fetches from Dexie, updates cache, and returns the record or `null`. |
| `setDocumentTitle(id, title)`     | Marks a new title and schedules a save.                              |
| `setDocumentContent(id, content)` | Stages TipTap JSON and schedules a save.                             |
| `flush(id)`                       | Persists pending fields immediately.                                 |
| `releaseDocument(id, opts?)`      | Clears timers, optionally flushes, and removes cached state.         |
| `useDocumentState(id)`            | Returns the `DocState` entry for reactive inspection.                |
| `useAllDocumentsState()`          | Gives you the reactive map (for debugging tooling).                  |
| `__hasPendingDocumentChanges(id)` | Internal helper to check for staged edits.                           |
| `__peekDocumentStatus(id)`        | Internal helper to read status without touching reactivity.          |

`DocState` looks like:

```ts
interface DocState {
    record: Document | null;
    status: 'idle' | 'saving' | 'saved' | 'error' | 'loading';
    lastError?: any;
    pendingTitle?: string;
    pendingContent?: any;
    timer?: any;
}
```

---

## Under the hood

1. **Shared map** – `documentsMap` (reactive `Map<string, DocState>`) ensures every component edits the same instance.
2. **Debounced saves** – `scheduleSave()` coalesces rapid edits into a single `flush()` invocation.
3. **Dexie helpers** – Uses `createDocument`, `updateDocument`, and `getDocument` from `~/db/documents`.
4. **Toast feedback** – Failures call `useToast().add()` with consistent retro styling.
5. **Pane events** – After `flush()`, the store locates open document panes via the global multi-pane API and triggers `ui.pane.doc:action:saved` events through `$hooks`.
6. **Memory hygiene** – `releaseDocument()` clears timers, removes `content`, and optionally deletes the map entry.

---

## Edge cases & tips

-   **Missing record**: `loadDocument()` returns `null` and shows a toast; callers should handle the `null` case.
-   **Autosave race**: Multiple rapid edits reset the same timer, so only the final state flushes.
-   **Manual flush before unload**: Call `await flush(id)` in route guards/modals to guarantee persistence.
-   **Pane hooks**: Tests or integrations can call `__hasPendingDocumentChanges()` to decide whether to force a save before closing a pane.
-   **Deleting entries**: After releasing with `{ deleteEntry: true }`, calling `useDocumentState(id)` recreates a fresh placeholder.

---

## Related

-   `usePaneDocuments` — orchestrates pane switching on top of this store.
-   `~/composables/core/useMultiPane` — pane runtime referenced when emitting hook actions.
-   `~/db/documents` — Dexie CRUD implementation backing all operations.

---

## TypeScript

```ts
function useDocumentState(id: string): DocState;
function useAllDocumentsState(): Map<string, DocState>;
async function loadDocument(id: string): Promise<Document | null>;
async function newDocument(initial?: {
    title?: string;
    content?: any;
}): Promise<Document>;
function setDocumentTitle(id: string, title: string): void;
function setDocumentContent(id: string, content: any): void;
async function flush(id: string): Promise<void>;
async function releaseDocument(
    id: string,
    opts?: { flush?: boolean; deleteEntry?: boolean }
): Promise<void>;
```
</file>

<file path="composables/useEditorNodes.md">
# useEditorNodes

Registry trio that lets plugins add TipTap nodes, marks, and extensions to the OR3 editor without patching the core component. Maintains global maps, keeps ordering stable, and plays nicely with HMR.

---

## What does it do?

`useEditorNodes` exports helpers that manage three registries:

-   `registerEditorNode` / `listEditorNodes` for TipTap `Node` extensions.
-   `registerEditorMark` / `listEditorMarks` for TipTap `Mark` extensions.
-   `registerEditorExtension` / `listEditorExtensions` for generic TipTap extensions.

Each registry sorts entries by `order` (default 200) and stores them on `globalThis` so reloads don’t duplicate items.

---

## Basic Example

```ts
import BulletList from '@tiptap/extension-bullet-list';
import Italic from '@tiptap/extension-italic';
import CharacterCount from '@tiptap/extension-character-count';
import {
    registerEditorNode,
    registerEditorMark,
    registerEditorExtension,
    unregisterEditorNode,
} from '~/composables/editor/useEditorNodes';

registerEditorNode({
    id: 'custom:bullet-list',
    extension: BulletList,
    order: 180,
});

registerEditorMark({
    id: 'custom:italic',
    extension: Italic,
});

registerEditorExtension({
    id: 'custom:char-count',
    extension: CharacterCount.configure({ limit: 2000 }),
});

onScopeDispose(() => {
    unregisterEditorNode('custom:bullet-list');
});
```

---

## How to use it

### 1. Pick the right registry

-   Use `registerEditorNode()` for block/inline nodes (paragraphs, lists, embeds).
-   Use `registerEditorMark()` for text marks (bold, italic, highlights).
-   Use `registerEditorExtension()` for plugins that don’t fit either bucket (history, collaboration, etc.).

### 2. Provide a unique ID

Namespace IDs (e.g., `your-plugin:node`) so duplicate registrations override intentionally.

### 3. Set ordering if needed

-   Built-ins typically occupy the <200 range. Lower values appear earlier when the editor component iterates.
-   Leave `order` undefined to slot your extension after core ones.

### 4. Clean up on dispose

Call the matching `unregister*` helper during HMR or component teardown to prevent stale entries.

### 5. Consume from the editor shell

`listEditorNodes()`, `listEditorMarks()`, and `listEditorExtensions()` return sorted arrays—`DocumentEditor.vue` reads them to build the TipTap instance.

---

## API

```ts
registerEditorNode(node: EditorNode): void;
unregisterEditorNode(id: string): void;
listEditorNodes(): EditorNode[];
listRegisteredEditorNodeIds(): string[];

registerEditorMark(mark: EditorMark): void;
unregisterEditorMark(id: string): void;
listEditorMarks(): EditorMark[];
listRegisteredEditorMarkIds(): string[];

registerEditorExtension(ext: EditorExtension): void;
unregisterEditorExtension(id: string): void;
listEditorExtensions(): EditorExtension[];
listRegisteredEditorExtensionIds(): string[];
```

---

## Under the hood

1. **Global maps** – Registries live on `globalThis.__or3Editor*Registry`, so multiple imports share the same data and HMR doesn’t double-register.
2. **Reactive mirrors** – `reactiveList` objects mirror each map so Vue can track changes when lists are recomputed.
3. **Stable sorting** – Items sort by `order` with a secondary `id` tie-breaker for deterministic output.
4. **Dev warnings** – In dev mode, double registration logs a warning to help catch collisions early.

---

## Edge cases & tips

-   **Duplicate IDs**: Later registrations replace earlier ones. Use this intentionally for overrides, otherwise rename your extension.
-   **Mark vs extension**: Some TipTap packages export both mark + helper. Register whichever type your editor setup expects.
-   **SSR safety**: Registries initialise lazily and don’t touch browser-only APIs, so they’re safe during server rendering.
-   **Cleanup**: Forgetting to unregister during HMR can leave stale marks that break tests; wrap registrations in `useHookEffect` to automate cleanup.

---

## Related

-   `useEditorToolbar` — complementary registry for toolbar buttons.
-   `~/app/components/editor/DocumentEditor.vue` — consumes these lists when building the TipTap instance.
-   `~/utils/editor/` — shared helpers for configuring extensions.

---

## TypeScript

```ts
interface EditorNode {
    id: string;
    extension: Node;
    order?: number;
}

interface EditorMark {
    id: string;
    extension: Mark;
    order?: number;
}

interface EditorExtension {
    id: string;
    extension: Extension;
    order?: number;
}
```
</file>

<file path="composables/useEditorToolbar.md">
# useEditorToolbar

Toolbar registry for the TipTap editor. Lets plugins add buttons, toggles, or dropdowns to the retro editor header while keeping the UI reactive and order-aware.

---

## What does it do?

`useEditorToolbar` exposes helpers to manage toolbar buttons:

-   `registerEditorToolbarButton()` adds or replaces a button definition.
-   `useEditorToolbarButtons(editorRef)` returns a computed, filtered, and sorted array of buttons ready to render.
-   `unregisterEditorToolbarButton()` cleans up during teardown/HMR.
-   `listRegisteredEditorToolbarButtonIds()` lets authors inspect the registry.

Buttons can customise visibility, active state, icons, ordering, and click behaviour.

---

## Basic Example

```ts
import Bold from '@tiptap/extension-bold';
import {
    registerEditorToolbarButton,
    unregisterEditorToolbarButton,
    useEditorToolbarButtons,
} from '~/composables/editor/useEditorToolbar';
import { registerEditorMark } from '~/composables/editor/useEditorNodes';

registerEditorMark({ id: 'custom:bold', extension: Bold });

registerEditorToolbarButton({
    id: 'custom:bold-toggle',
    icon: 'i-ph-text-b',
    tooltip: 'Bold (⌘B)',
    order: 150,
    isActive: (editor) => editor.isActive('bold'),
    onClick: (editor) => editor.chain().focus().toggleBold().run(),
});

const buttons = useEditorToolbarButtons(editorRef);

onScopeDispose(() => {
    unregisterEditorToolbarButton('custom:bold-toggle');
});
```

---

## How to use it

### 1. Register buttons during setup

Call `registerEditorToolbarButton()` inside a plugin or component. Namespace IDs to avoid clashes (`my-plugin:bold`).

### 2. Implement handlers

-   `onClick` receives the live TipTap editor instance—chain commands, toggle marks, etc.
-   `isActive` marks buttons as pressed (useful for toggles).
-   `visible` hides buttons conditionally (e.g., based on editor capabilities).

Wrap logic in try/catch if the command could fail; errors bubble to the console in dev but won’t break rendering.

### 3. Consume in the toolbar component

Pass a ref to the current `Editor` instance into `useEditorToolbarButtons()`. The computed result auto-updates when visibility changes (e.g., selection context).

### 4. Order buttons

-   Built-ins generally occupy <200 slots.
-   Set `order` to insert before/after core controls; ties fall back to `id` alphabetical order.

### 5. Clean up for HMR

Call `unregisterEditorToolbarButton()` during teardown to avoid duplicates when modules hot reload.

---

## What you get back

`useEditorToolbarButtons(editorRef)` returns a `ComputedRef<EditorToolbarButton[]>`. Each button contains:

| Property   | Type                          | Description                                          |
| ---------- | ----------------------------- | ---------------------------------------------------- | ------------------------------------ |
| `id`       | `string`                      | Unique identifier.                                   |
| `icon`     | `string`                      | Iconify name shown in the retro toolbar.             |
| `tooltip`  | `string \| undefined`         | Hover hint.                                          |
| `order`    | `number \| undefined`         | Controls placement (default 200).                    |
| `isActive` | `(editor: Editor) => boolean` | Optional active state tester.                        |
| `onClick`  | `(editor: Editor) => void     | Promise<void>`                                       | Executes when the button is clicked. |
| `visible`  | `(editor: Editor) => boolean` | Optional visibility predicate; hidden on exceptions. |

---

## API

```ts
registerEditorToolbarButton(button: EditorToolbarButton): void;
unregisterEditorToolbarButton(id: string): void;
useEditorToolbarButtons(editorRef: Ref<Editor | null>): ComputedRef<EditorToolbarButton[]>;
listRegisteredEditorToolbarButtonIds(): string[];
```

---

## Under the hood

1. **Global map** – Buttons live on `globalThis.__or3EditorToolbarRegistry`, preventing duplicate registrations across imports/HMR.
2. **Reactive mirror** – A reactive list mirrors the map so Vue recomputes consumer arrays automatically.
3. **Visibility guard** – `useEditorToolbarButtons` filters buttons through their `visible` callback inside a try/catch; errors default to hiding the button.
4. **Stable sort** – Buttons sort by `order` with a secondary `id` tie-breaker for deterministic output.

---

## Edge cases & tips

-   **No editor yet**: When `editorRef.value` is `null`, the computed array is empty—render guards should handle this gracefully.
-   **Async handlers**: Returning a promise is supported; UI code can await if needed (e.g., to show loading states).
-   **Keyboard shortcuts**: Pair buttons with TipTap commands bound via `editor.registerPlugin` or external shortcut handlers.
-   **Testing**: In Vitest, provide a mocked editor object with the minimal API (`chain`, `isActive`) to test your buttons.

---

## Related

-   `useEditorNodes` — register complementary nodes/marks.
-   `~/app/components/editor/DocumentEditorToolbar.vue` — consumes the toolbar registry.
-   `@tiptap/vue-3` — TipTap editor integration referenced by button handlers.

---

## TypeScript

```ts
interface EditorToolbarButton {
    id: string;
    icon: string;
    tooltip?: string;
    order?: number;
    isActive?: (editor: Editor) => boolean;
    onClick: (editor: Editor) => void | Promise<void>;
    visible?: (editor: Editor) => boolean;
}
```
</file>

<file path="composables/useHeaderActions.md">
# useHeaderActions

Sidebar header action registry that powers the icon buttons in the chrome header (new thread, toggle layout, etc.). Lets plugins contribute actions that react to route, breakpoint, or custom context.

---

## What does it do?

`useHeaderActions` wraps the shared registry factory to provide:

-   `registerHeaderAction()` / `unregisterHeaderAction()` for lifecycle management.
-   `useHeaderActions(contextFn)` to compute filtered, ordered buttons with disabled state applied.
-   `listRegisteredHeaderActionIds()` for debugging.

Actions can adjust styling via `color`, display tooltips, and opt into mobile-only/desktop-only modes.

---

## Basic Example

```ts
import {
    registerHeaderAction,
    unregisterHeaderAction,
    useHeaderActions,
} from '~/composables/sidebar/useHeaderActions';

registerHeaderAction({
    id: 'custom:toggle-projects',
    icon: 'i-ph-folders',
    tooltip: 'Toggle projects',
    order: 160,
    visible: ({ isMobile }) => !isMobile,
    handler: () => emitToggleProjects(),
});

const actions = useHeaderActions(() => ({ route: useRoute(), isMobile }));

onScopeDispose(() => unregisterHeaderAction('custom:toggle-projects'));
```

---

## How to use it

### 1. Register actions on startup

-   Namespace IDs to avoid clobbering built-ins.
-   Provide `icon`, optional `tooltip`, `label`, `color`, and `order`.

### 2. Feed context into `useHeaderActions`

`contextFn` should return whatever inputs your predicates need (e.g., current `route`, `isMobile` flag from `useBreakpoints`). The computed list recalculates whenever the returned values change.

### 3. Control visibility and disabled state

-   `visible(ctx)` returns `false` to hide the button entirely.
-   `disabled(ctx)` greys out the button but keeps tooltip + layout.

### 4. Handle clicks

`handler(ctx)` can perform sync or async work. Manage your own loading indicators—you can combine with `disabled` toggles if necessary.

### 5. Cleanup during teardown

Call `unregisterHeaderAction()` (or use `useHookEffect`) to avoid duplicates under HMR.

---

## What you get back

`useHeaderActions(contextFn)` returns a `ComputedRef<HeaderActionEntry[]>` where each entry includes the original action plus evaluated `disabled` state.

| Property   | Type                                | Description                                  |
| ---------- | ----------------------------------- | -------------------------------------------- | -------------- |
| `id`       | `string`                            | Unique identifier.                           |
| `icon`     | `string`                            | Iconify name for the header button.          |
| `tooltip`  | `string \| undefined`               | Hover/focus hint.                            |
| `label`    | `string \| undefined`               | Optional text label beside the icon.         |
| `order`    | `number \| undefined`               | Sort order (default 200).                    |
| `color`    | `ChromeActionColor \| undefined`    | Styling hint passed to the button component. |
| `handler`  | `(ctx: HeaderActionContext) => void | Promise<void>`                               | Click handler. |
| `visible`  | `(ctx) => boolean`                  | Optional visibility predicate.               |
| `disabled` | `(ctx) => boolean`                  | Optional disabled predicate.                 |

---

## API

```ts
registerHeaderAction(action: HeaderAction): void;
unregisterHeaderAction(id: string): void;
useHeaderActions(context?: () => HeaderActionContext): ComputedRef<HeaderActionEntry[]>;
listRegisteredHeaderActionIds(): string[];
```

---

## Under the hood

1. **Registry factory** – Uses `createRegistry('__or3HeaderActionsRegistry')` which already handles dedupe, sorting, and reactivity.
2. **Default ordering** – Applies `order ?? 200` so plugin buttons usually land after built-ins unless you specify otherwise.
3. **Context-driven filtering** – Runs `visible`/`disabled` functions for every render; errors aren’t caught here, so write defensive code if predicates touch optional fields.
4. **Shared list** – All imports share the same global registry, making it safe to register from multiple modules.

---

## Edge cases & tips

-   **Mobile-only actions**: Pair `visible` with your responsive breakpoints to hide controls on smaller layouts.
-   **Route-dependent actions**: Use `route.name` or `route.path` inside predicates to only show actions on relevant pages.
-   **Async state**: If a handler triggers network work, consider disabling the button until the promise resolves.
-   **Testing**: Mock `createRegistry` or inject a fake registry when writing unit tests to keep them deterministic.

---

## Related

-   `useComposerActions` — handles composer button row.
-   `useSidebarSections` — adds custom sidebar panels and footer actions.
-   `~/composables/_registry` — shared factory powering these registries.

---

## TypeScript

```ts
interface HeaderActionContext {
    route?: RouteLocationNormalizedLoaded | null;
    isMobile?: boolean;
}

interface HeaderAction extends RegistryItem {
    id: string;
    icon: string;
    tooltip?: string;
    label?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: HeaderActionContext) => void | Promise<void>;
    visible?: (ctx: HeaderActionContext) => boolean;
    disabled?: (ctx: HeaderActionContext) => boolean;
}
```
</file>

<file path="composables/useHookEffect.md">
# useHookEffect

Typed helper for subscribing to the internal hook bus. It registers a callback, cleans up automatically on component unmount and during hot-module reload, and returns a disposer if you need manual control.

---

## What does it do?

`useHookEffect` wraps the hook engine (`useHooks()`) with lifecycle-aware registration. Whenever a component mounts, it attaches your callback to a named hook and guarantees cleanup so you never leak listeners.

-   Supports every hook name with full TypeScript inference
-   Lets you override hook kind (`action` / `filter`) and priority
-   Auto-detaches on `onBeforeUnmount`
-   Handles Vite/Nuxt HMR disposal for local development

---

## Basic Example

```ts
import { useHookEffect } from '~/composables/core/useHookEffect';

useHookEffect('ui.chat.message:filter:outgoing', async (message) => {
    if (message.content.includes('restricted')) {
        return false; // veto send
    }
    return message;
});
```

---

## How to use it

### 1. Import and register

Call `useHookEffect(name, callback)` in `setup()`. The callback signature is inferred from the hook name, so TypeScript will keep you honest.

### 2. Optionally tweak behavior

Pass an `opts` object to set a specific hook kind or priority:

```ts
useHookEffect('ui.pane.switch:action', handler, {
    kind: 'action',
    priority: 50,
});
```

### 3. Manually dispose if needed

The function returns a disposer. You rarely need it, but it can be helpful when toggling listeners in response to reactive state.

```ts
const dispose = useHookEffect('ai.chat.send:action:after', onComplete);

watch(enabled, (next) => {
    if (!next) dispose();
});
```

---

## API

```ts
function useHookEffect<K extends HookName>(
    name: K,
    fn: InferHookCallback<K>,
    opts?: {
        kind?: HookKind;
        priority?: number;
    }
): () => void;
```

| Parameter       | Type                               | Description                                                                 |
| --------------- | ---------------------------------- | --------------------------------------------------------------------------- |
| `name`          | `HookName`                         | The hook identifier (strongly typed to known strings).                      |
| `fn`            | `InferHookCallback<K>`             | Listener invoked when the hook fires.                                       |
| `opts.kind`     | `'action' \| 'filter' \| HookKind` | Override the resolved kind when the name is ambiguous.                      |
| `opts.priority` | `number`                           | Smaller numbers run first; defaults to the hook engine’s standard priority. |

Returns the disposer you can call to unregister immediately.

---

## Under the hood

1. Fetches the shared hook engine with `useHooks()`.
2. Registers the callback with `hooks.on`, capturing the disposer.
3. Subscribes to `onBeforeUnmount` to `hooks.off(disposer)`.
4. During HMR, listens for `import.meta.hot.dispose` and calls the disposer.

Because of that lifecycle tie-in, you can safely register listeners in any component without worrying about stale callbacks.

---

## Edge cases & tips

-   **SSR**: Safe to import; hooks execute client-side where the engine lives.
-   **Multiple registrations**: Each call returns its own disposer—store them if you plan to toggle listeners dynamically.
-   **Kind inference**: If a hook name ends with `:filter:*`, the kind defaults to `filter`; same for `:action:*`. Override `opts.kind` only when absolutely necessary.
-   **Priorities**: Use lower numbers to ensure your filter runs before default ones (e.g., set to `25` to beat default `50`).

---

## Related

-   `useHooks()` — exposes the raw hook API if you need advanced control.
-   `docs/core-hook-map.md` — catalog of built-in hook names.
-   `useChat` / `useMultiPane` — major composables that emit the hooks you’ll most often tap into.
</file>

<file path="composables/useMessageActions.md">
# useMessageActions

Extensible action registry for chat messages. Lets core UI and plugins add contextual buttons (copy, retry, favorite, etc.) in a consistent order with minimal wiring.

---

## What it does

`useMessageActions` maintains a global list of action descriptors keyed by an id. Components register their actions once, and when rendering an individual message you can pull the filtered, sorted list for that message’s role.

-   Stores actions in a singleton Map (survives HMR)
-   Exposes helpers to register/unregister actions
-   Provides a computed list scoped to user or assistant messages
-   Supports ordering via an optional `order` property (default 200)

---

## Registering an action

```ts
import { registerMessageAction } from '~/composables/chat/useMessageActions';

registerMessageAction({
    id: 'copy-text',
    icon: 'i-heroicons-clipboard-document',
    tooltip: 'Copy to clipboard',
    showOn: 'assistant',
    order: 150,
    async handler({ message }) {
        await navigator.clipboard.writeText(message.text);
    },
});
```

Built-in actions from core components typically use orders below 200. Plugins can pick `order >= 200` to appear after defaults unless they intentionally override.

---

## API

| Export                             | Type                                                                             | Description                                                           |
| ---------------------------------- | -------------------------------------------------------------------------------- | --------------------------------------------------------------------- |
| `registerMessageAction(action)`    | `(action: ChatMessageAction) => void`                                            | Add or replace an action descriptor in the registry.                  |
| `unregisterMessageAction(id)`      | `(id: string) => void`                                                           | Remove an action by id (optional cleanup).                            |
| `useMessageActions(message)`       | `(message: { role: 'user' \| 'assistant' }) => ComputedRef<ChatMessageAction[]>` | Get a computed, role-filtered, ordered list for a specific message.   |
| `listRegisteredMessageActionIds()` | `() => string[]`                                                                 | Return all registered ids (useful for debugging or collision checks). |

### `ChatMessageAction`

```ts
interface ChatMessageAction {
    id: string;
    icon: string;
    tooltip: string;
    showOn: 'user' | 'assistant' | 'both';
    order?: number; // defaults to 200
    handler: (ctx: { message: any; threadId?: string }) => void | Promise<void>;
}
```

---

## Using in a component

```vue
<template>
    <div class="message-actions">
        <UButton
            v-for="action in actions"
            :key="action.id"
            :icon="action.icon"
            variant="ghost"
            size="xs"
            :aria-label="action.tooltip"
            @click="action.handler({ message, threadId })"
        />
    </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useMessageActions } from '~/composables/chat/useMessageActions';

const props = defineProps<{
    message: { role: 'user' | 'assistant'; id: string };
}>();
const threadId = useCurrentThreadId();

const actionsComputed = useMessageActions(props.message);
const actions = computed(() => actionsComputed.value);
</script>
```

---

## Internals

1. **Registry Map** — Stored on `globalThis` so repeated imports share data even with HMR.
2. **Reactive mirror** — A `reactiveList` array mirrors the Map contents so Vue can track changes. Every register/unregister call re-syncs the array.
3. **Computed filtering** — `useMessageActions` filters `reactiveList.items` based on `showOn` and sorts by `order ?? 200`.
4. **Cleanup** — `unregisterMessageAction` helps modules remove actions when disabled or disposed.

---

## Tips & edge cases

-   **ID collisions**: registering with an existing `id` overwrites the previous action; use `listRegisteredMessageActionIds()` to audit.
-   **Async handlers**: You can return promises; the caller decides whether to await or fire-and-forget.
-   **Context object**: `handler` receives `{ message, threadId }`; extend as needed but keep the shape consistent for plugin compatibility.
-   **Role filtering**: Use `showOn: 'both'` for universal actions (e.g., “pin”), otherwise scope to `user` or `assistant`.

---

## Related modules

-   `ChatMessage.vue` — built-in consumer that renders the buttons.
-   `useMessageEditing` — often paired to expose “Edit message” action.
-   `pane plugin API` — natural spot to add custom actions when a plugin activates.
</file>

<file path="composables/useMessageEditing.md">
# useMessageEditing

Encapsulates the UI + persistence flow for editing a chat message. Handles toggling edit mode, keeping a draft buffer, and writing the updated content back to Dexie.

---

## What it handles

`useMessageEditing` wraps all state required for an inline message editor:

-   Tracks whether the message is currently being edited
-   Keeps a draft copy of the text with undo (cancel) support
-   Persists the change to the `messages` table via `upsert`
-   Works with plain objects or `Ref`-wrapped messages (streaming tail vs finalized)

---

## Quick example

```ts
import { useMessageEditing } from '~/composables/chat/useMessageEditing';

const props = defineProps<{ message: UiChatMessage }>();
const editing = useMessageEditing(props.message);

function onSave() {
    editing.saveEdit();
}
```

In a template you can wire the state like this:

```vue
<template>
    <div v-if="editing.editing.value" class="message-editor">
        <textarea v-model="editing.draft.value" rows="3" class="retro-input" />
        <div class="flex gap-2 mt-2">
            <button
                class="retro-btn"
                :disabled="editing.saving.value"
                @click="editing.saveEdit"
            >
                Save
            </button>
            <button
                class="retro-btn"
                :disabled="editing.saving.value"
                @click="editing.cancelEdit"
            >
                Cancel
            </button>
        </div>
    </div>
    <div v-else>
        {{ props.message.text }}
        <button class="retro-btn" @click="editing.beginEdit">Edit</button>
    </div>
</template>
```

---

## API

| Property / Method | Type                  | Description                                                             |
| ----------------- | --------------------- | ----------------------------------------------------------------------- |
| `editing`         | `Ref<boolean>`        | `true` while the UI is in edit mode.                                    |
| `draft`           | `Ref<string>`         | Draft text bound to the editor input.                                   |
| `original`        | `Ref<string>`         | Snapshot of the message content before editing (used for cancel).       |
| `saving`          | `Ref<boolean>`        | `true` while the composable is persisting the update.                   |
| `beginEdit()`     | `() => void`          | Initialise draft/original values and switch to edit mode.               |
| `cancelEdit()`    | `() => void`          | Exit edit mode without saving, resetting buffers.                       |
| `saveEdit()`      | `() => Promise<void>` | Persist trimmed draft text to Dexie and update the live message object. |

### Message input contract

The `message` argument can be:

-   A `UiChatMessage` object with `text` and/or `content`
-   A `Ref` wrapping such an object (useful when the message swaps underneath, e.g., streaming tail to stored message)

`saveEdit()` writes the new text to both `content` and `text` if present so renderers stay in sync.

---

## Under the hood

1. **Message accessor** — `getMessage()` unwraps refs and returns the latest object before each action.
2. **Draft prep** — `beginEdit()` pulls the existing content from `message.content` or falls back to `message.text`.
3. **Persistence** — `saveEdit()` fetches the stored record via `db.messages.get(id)` and calls `upsert.message(...)` with the updated text and `updated_at` timestamp.
4. **State updates** — After persistence, it updates the in-memory message object so the UI reflects the new content immediately.
5. **Guard rails** — Empty drafts short-circuit to `cancelEdit()`. Missing IDs abort silently.

---

## Tips & edge cases

-   **Streaming messages**: Because it accepts refs, you can start editing a message that transitions from “tail” to finalized without losing the editor state.
-   **Concurrent edits**: `saving` prevents duplicate writes; external overrides should listen for `saving.value` before issuing new edits.
-   **No-op on blank**: Saving trims whitespace; if the result is empty it cancels instead of writing an empty record.
-   **Error handling**: Errors during persistence are caught by the `try/finally` block—state resets `saving` back to `false`, but you might want to wrap `saveEdit()` in a try/catch to display UI feedback.

---

## Related composables

-   `useMessageActions` — expose an “Edit” action that toggles this composable.
-   `useChat` — source of `UiChatMessage` records this composable edits.
-   `~/db/upsert` — the Dexie helper invoked during `saveEdit()`.
</file>

<file path="composables/useModelStore.md">
# useModelStore

Shared catalog + favorites manager for OpenRouter models. Centralises fetching, caching, and filtering so every pane sees the same list without repeated network hits.

---

## Responsibilities

`useModelStore` exposes reactive state for the model catalog, favorites, search query, and filters. It layers three cache tiers (memory → Dexie → network) and dedupes concurrent fetches. Consumers can refresh, invalidate, or persist favorites with a single call.

-   Hydrates catalog from memory, Dexie (`kv` table), or network
-   Persists the catalog in Dexie for 48 hours by default
-   Dedupes in-flight fetches across callers
-   Manages favorites with persistence to `kv`
-   Exposes helper refs for search/filter UI

---

## Quick start

```ts
import { useModelStore } from '~/composables/chat/useModelStore';

const {
    catalog,
    favoriteModels,
    fetchModels,
    addFavoriteModel,
    removeFavoriteModel,
    searchQuery,
    filters,
} = useModelStore();

await fetchModels();
searchQuery.value = 'claude';
await addFavoriteModel(catalog.value[0]);
```

---

## API

| Export                       | Type                                                                                                             | Description                                                       |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `catalog`                    | `Ref<OpenRouterModel[]>`                                                                                         | Reactive catalog of models.                                       |
| `favoriteModels`             | `Ref<OpenRouterModel[]>`                                                                                         | Models the user has favorited (persisted).                        |
| `searchQuery`                | `Ref<string>`                                                                                                    | Shared search string for UI components.                           |
| `filters`                    | `Ref<{ input?: string[]; output?: string[]; minContext?: number; parameters?: string[]; price?: PriceBucket; }>` | Reactive filter state.                                            |
| `lastLoadedAt`               | `Ref<number \| undefined>`                                                                                       | Timestamp (ms) of the most recent catalog load.                   |
| `fetchModels(opts?)`         | `(opts?: { force?: boolean; ttlMs?: number }) => Promise<OpenRouterModel[]>`                                     | Populate catalog using cache layers; respects TTL unless `force`. |
| `refreshModels()`            | `() => Promise<OpenRouterModel[]>`                                                                               | Shortcut for `fetchModels({ force: true })`.                      |
| `invalidate()`               | `() => Promise<void>`                                                                                            | Clear memory cache and delete Dexie entry.                        |
| `getFavoriteModels()`        | `() => Promise<OpenRouterModel[]>`                                                                               | Load favorites from `kv` into memory.                             |
| `addFavoriteModel(model)`    | `(model: OpenRouterModel) => Promise<void>`                                                                      | Append to favorites (deduped) and persist.                        |
| `removeFavoriteModel(model)` | `(model: OpenRouterModel) => Promise<void>`                                                                      | Remove favorite and persist.                                      |
| `clearFavoriteModels()`      | `() => Promise<void>`                                                                                            | Remove all favorites and persist.                                 |

Constants:

```ts
MODELS_CACHE_KEY = 'MODELS_CATALOG';
MODELS_TTL_MS = 48 * 60 * 60 * 1000; // 48 hours
```

---

## Usage patterns

### Populate a model picker

```ts
const { catalog, fetchModels, searchQuery, filters } = useModelStore();

await fetchModels();

const filteredModels = computed(() => {
    return catalog.value.filter((model) => {
        if (searchQuery.value && !model.id.includes(searchQuery.value)) {
            return false;
        }
        if (
            filters.value.price &&
            model.price?.bucket !== filters.value.price
        ) {
            return false;
        }
        return true;
    });
});
```

### Sync favorites to UI

```ts
const {
    favoriteModels,
    addFavoriteModel,
    removeFavoriteModel,
    getFavoriteModels,
} = useModelStore();

await getFavoriteModels();

function toggleFavorite(model: OpenRouterModel) {
    if (favoriteModels.value.some((m) => m.id === model.id)) {
        removeFavoriteModel(model);
    } else {
        addFavoriteModel(model);
    }
}
```

### Force-refreshing the catalog

```ts
const { refreshModels } = useModelStore();

await refreshModels(); // bypasses cache and hits the network
```

---

## Internals

1. **Singleton refs** — `catalog`, `favoriteModels`, `filters`, etc. live at module scope so every caller shares the same reactive data.
2. **Cache layers** — `fetchModels` tries memory first, then Dexie (if supported), then network. TTL is configurable per call.
3. **Dexie persistence** — Catalog is stored via `kv.set(MODELS_CACHE_KEY, JSON.stringify(list))`; timestamps come from `rec.updated_at` (seconds) and are compared against the TTL.
4. **In-flight dedupe** — Network fetches share a module-level `inFlight` promise so parallel callers await the same request.
5. **Favorites persistence** — Favorites use a separate `kv` key (`favorite_models`) and are stored as JSON.
6. **Error handling** — On network failure it attempts to serve stale Dexie data; JSON parse failures purge the corrupt record.

---

## Tips & edge cases

-   **IndexedDB availability**: `canUseDexie()` guards against SSR and private modes that block IndexedDB. If Dexie is unavailable, caching falls back to memory only.
-   **TTL overrides**: Pass `fetchModels({ ttlMs: 15 * 60 * 1000 })` to tighten freshness requirements for specific views.
-   **Favorites dedupe**: `addFavoriteModel` ignores duplicates by `model.id`.
-   **Invalidation**: After calling `invalidate()`, make sure to call `fetchModels()` again to repopulate memory.
-   **Persistent filters/search**: Since refs are shared, updating `searchQuery` in one component immediately affects others (intended for synchronized UI).

---

## Related modules

-   `models-service` — underlying fetcher for OpenRouter models.
-   `kv` helpers — Dexie-backed storage used for both catalog and favorites.
-   `useAiSettings` — may use this store to pick the default model.
</file>

<file path="composables/useMultiPane.md">
# useMultiPane

State manager that powers OR3’s multi-pane chat/document workspace. It keeps the active pane list, loads messages on demand, enforces pane limits, and fires hook events so plugins can react to pane lifecycle changes.

---

## What does it do?

`useMultiPane` centralises all window management logic outside the UI layer:

-   Creates, focuses, and closes panes with automatic fallback when the last pane would disappear
-   Loads chat message history for each pane (with Dexie-backed fallback)
-   Tracks the active pane index, preventing focus bugs
-   Emits hook events for pane open/close/switch so extensions stay in sync
-   Supports a configurable pane cap, custom message loaders, and document flush callbacks

---

## Basic Example

```ts
import { useMultiPane } from '~/composables/core/useMultiPane';

const multiPane = useMultiPane({ initialThreadId: 'thread-123', maxPanes: 4 });

multiPane.addPane();
await multiPane.setPaneThread(1, 'thread-456');
multiPane.setActive(1);
```

---

## How to use it

### 1. Create the store

```ts
const multiPane = useMultiPane({
    initialThreadId: '',
    maxPanes: 3,
    onFlushDocument: async (docId) => {
        await saveDraft(docId);
    },
});
```

### 2. Bind to UI

Use `multiPane.panes` to render your pane tabs and `multiPane.activePaneIndex` to highlight the current one. Buttons can call `addPane`, `closePane(i)`, or `setActive(i)`.

### 3. Load or switch chats

Hook `setPaneThread(index, threadId)` to any thread picker.

```ts
await multiPane.setPaneThread(activeIndex.value, selectedThreadId);
```

### 4. Keyboard shortcuts

`focusPrev(current)` and `focusNext(current)` make it easy to wire ⌥← / ⌥→ navigation.

### 5. Keep at least one pane alive

Call `ensureAtLeastOne()` if you manipulate `panes` directly (rare, but handy in dev tools).

---

## API

```ts
const multiPane = useMultiPane(options?: UseMultiPaneOptions);
```

| Option            | Type                                                | Description                                                      |
| ----------------- | --------------------------------------------------- | ---------------------------------------------------------------- |
| `initialThreadId` | `string`                                            | Starting thread for the first pane (empty string for new chat).  |
| `maxPanes`        | `number`                                            | Maximum simultaneous panes (default `3`).                        |
| `onFlushDocument` | `(id: string) => void \| Promise<void>`             | Called before closing a document pane so you can persist drafts. |
| `loadMessagesFor` | `(threadId: string) => Promise<MultiPaneMessage[]>` | Override message loader (defaults to Dexie query).               |

### Returned object

| Property / Method                | Type                                                 | Purpose                                                                 |
| -------------------------------- | ---------------------------------------------------- | ----------------------------------------------------------------------- |
| `panes`                          | `Ref<PaneState[]>`                                   | Reactive list of panes in open order.                                   |
| `activePaneIndex`                | `Ref<number>`                                        | Index of the currently focused pane.                                    |
| `canAddPane`                     | `ComputedRef<boolean>`                               | `true` when below `maxPanes`.                                           |
| `newWindowTooltip`               | `ComputedRef<string>`                                | Pre-baked tooltip text for “new pane” buttons.                          |
| `addPane()`                      | `() => void`                                         | Append a blank pane and focus it.                                       |
| `closePane(index)`               | `(index: number) => Promise<void> \| void`           | Close a pane; never removes the last one.                               |
| `setActive(index)`               | `(index: number) => void`                            | Mark a pane as focused, firing switch hooks.                            |
| `focusPrev(current)`             | `(current: number) => void`                          | Focus the previous pane if available.                                   |
| `focusNext(current)`             | `(current: number) => void`                          | Focus the next pane if available.                                       |
| `setPaneThread(index, threadId)` | `(index: number, threadId: string) => Promise<void>` | Load messages for a chat and attach it to the pane. Pass `''` to clear. |
| `loadMessagesFor`                | `(threadId: string) => Promise<MultiPaneMessage[]>`  | Exposed loader (useful for tests).                                      |
| `ensureAtLeastOne()`             | `() => void`                                         | Guarantees at least one pane exists.                                    |

`PaneState` consists of:

```ts
interface PaneState {
    id: string;
    mode: 'chat' | 'doc';
    threadId: string;
    documentId?: string;
    messages: MultiPaneMessage[];
    validating: boolean;
}
```

---

## Under the hood

1. **Pane creation** — `createEmptyPane()` generates a UUID (via `crypto.randomUUID` fallback) and seeds a blank chat pane.
2. **Message loading** — The default loader queries Dexie for non-deleted messages, normalises content/reasoning text, and returns a lightweight list suited for pane previews.
3. **Hooks integration** — Every major action (`open`, `close`, `switch`, `active`, `blur`, thread changes) dispatches hook events so plugins and side panels can respond.
4. **Focus logic** — `setActive` handles focus order, blur hooks, and ensures active index stays in range when panes close.
5. **Global exposure** — Stores the API on `globalThis.__or3MultiPaneApi` so extensions or devtools can orchestrate panes externally.

---

## Edge cases & tips

-   **Thread veto**: Filters registered on `ui.pane.thread:filter:select` can return `false` to block a thread switch.
-   **Document panes**: When `mode === 'doc'` and `documentId` is set, `closePane` calls `onFlushDocument` before removing the pane—use it to save unsaved edits.
-   **Pane limit**: `addPane()` silently no-ops once `maxPanes` is reached; pair with `canAddPane` to disable UI affordances.
-   **Hot reload**: On HMR the latest instance overwrites `__or3MultiPaneApi`, so developer tooling always hits the freshest store.
-   **Testing**: Pass `loadMessagesFor` to inject fixtures without touching Dexie.

---

## Related

-   `usePanePrompt` — tracks pending system prompts per pane.
-   `useChat` — main consumer of pane message state.
-   Hooks: `ui.pane.*` actions/filters documented in `docs/core-hook-map.md`.
</file>

<file path="composables/usePaneDocuments.md">
# usePaneDocuments

Pane-aware controller that lets the dashboard create or switch documents inside the multi-pane workspace. It glues `useDocumentsStore`, pane state, and hook events into two ergonomic methods.

---

## What does it do?

`usePaneDocuments({ panes, activePaneIndex, createNewDoc, flushDocument })` returns helpers that:

-   Create a fresh document in the active pane while flushing/releasing the previous one.
-   Switch the active pane to a different document, honouring hook vetoes and autosave semantics.
-   Emit `$hooks` actions (`ui.pane.doc:action:saved`, `:changed`) so listeners react to transitions.
-   Reuse `useDocumentState` + `releaseDocument` to keep autosave + memory management consistent.

---

## Basic Example

```ts
import { usePaneDocuments } from '~/composables/documents/usePaneDocuments';
import { useMultiPane } from '~/composables/core/useMultiPane';
import { newDocument, flush } from '~/composables/documents/useDocumentsStore';

const { panes, activePaneIndex } = useMultiPane();

const { newDocumentInActive, selectDocumentInActive } = usePaneDocuments({
    panes,
    activePaneIndex,
    createNewDoc: (initial) => newDocument(initial),
    flushDocument: (id) => flush(id),
});

await newDocumentInActive({ title: 'Meeting notes' });
await selectDocumentInActive(existingDocId);
```

---

## How to use it

### 1. Supply pane + document dependencies

-   `panes` / `activePaneIndex` come from `useMultiPane`.
-   `createNewDoc` should return `{ id }` for the newly created record.
-   `flushDocument` flushes staged changes for a given ID (usually `flush()` from `useDocumentsStore`).

### 2. Create a document in the active pane

`await newDocumentInActive(initial?)`:

-   Flushes + releases the currently bound doc (if any), emitting `ui.pane.doc:action:saved` when staged changes existed.
-   Creates the new record via `createNewDoc`.
-   Runs `ui.pane.doc:filter:select` filters, allowing plugins to veto/redirect.
-   Updates the pane (`mode = 'doc'`, sets `documentId`, clears chat state) and fires `ui.pane.doc:action:changed` with `{ created: true }` metadata.

### 3. Switch the active pane to another document

`await selectDocumentInActive(id)`:

-   Applies the same select filter to allow vetoes.
-   Flushes + saves pending edits on the current doc when switching away and emits the saved action if needed.
-   Releases the previous document state to free memory.
-   Updates the pane bindings and emits `ui.pane.doc:action:changed` with `reason: 'select'`.

### 4. Respect hook vetoes

If any filter returns `false`, both helpers abort without changing the pane. Use this to block navigation when validations fail.

---

## What you get back

| Method                          | Returns                                | Description                                                                                  |
| ------------------------------- | -------------------------------------- | -------------------------------------------------------------------------------------------- |
| `newDocumentInActive(initial?)` | `Promise<{ id: string } \| undefined>` | Creates a doc in the active pane; returns the record summary or `undefined` on failure/veto. |
| `selectDocumentInActive(id)`    | `Promise<void>`                        | Switches the active pane to `id`; no-op if vetoed or invalid.                                |

Both methods run asynchronously and should be awaited to ensure flushes complete before continuing.

---

## Under the hood

1. **Pane lookup** – Reads the current pane via `panes.value[activePaneIndex.value]`.
2. **Pending change detection** – Uses `useDocumentState()` to check `pendingTitle`/`pendingContent` before emitting saved events.
3. **Hooks integration** – Utilises `useHooks()` to call `applyFilters('ui.pane.doc:filter:select', ...)` and `doAction('ui.pane.doc:action:changed' | '...:saved')`.
4. **Memory cleanup** – Calls `releaseDocument(id, { flush: false })` after switching to avoid lingering TipTap trees.
5. **Resets chat state** – Clears `threadId` and `messages` when moving panes back to document mode.

---

## Edge cases & tips

-   **Null pane**: If no pane exists at the active index, helpers exit early.
-   **Duplicate select**: Selecting the already-active doc short-circuits after reset; no extra hook events fire.
-   **Error suppression**: Internal `try { ... } catch {}` blocks ensure hook misbehaviour doesn’t crash the UX—but you should still log within your own filters/actions.
-   **Testing**: You can stub `createNewDoc` / `flushDocument` to use in Vitest without hitting Dexie.

---

## Related

-   `useDocumentsStore` — provides `flush`, `releaseDocument`, and state inspection.
-   `useMultiPane` — pane state machine consumed by this helper.
-   `~/core/hooks/useHooks` — hook engine used for filters/actions.

---

## TypeScript

```ts
interface UsePaneDocumentsOptions {
    panes: Ref<MultiPaneState[]>;
    activePaneIndex: Ref<number>;
    createNewDoc: (initial?: { title?: string }) => Promise<{ id: string }>;
    flushDocument: (id: string) => Promise<void> | void;
}

interface UsePaneDocumentsApi {
    newDocumentInActive(initial?: {
        title?: string;
    }): Promise<{ id: string } | undefined>;
    selectDocumentInActive(id: string): Promise<void>;
}
```
</file>

<file path="composables/usePanePrompt.md">
# usePanePrompt

Tiny helper that tracks a “pending system prompt” per pane. It lets the UI stage a prompt that will be applied when the user creates their next thread in that pane.

---

## What does it do?

`usePanePrompt` exposes three functions backed by a reactive map:

-   `setPanePendingPrompt(paneId, promptId)` — stage a prompt identifier
-   `getPanePendingPrompt(paneId)` — read the pending prompt (if any)
-   `clearPanePendingPrompt(paneId)` — forget the association once it’s used

Because the backing store is reactive, other consumers can watch it for UI hints, and HMR/devtools expose the map for inspection.

---

## Basic Example

```ts
import {
    setPanePendingPrompt,
    getPanePendingPrompt,
    clearPanePendingPrompt,
} from '~/composables/core/usePanePrompt';

setPanePendingPrompt('pane-1', 'prompt-active-user');

const pending = getPanePendingPrompt('pane-1');
// => 'prompt-active-user'

clearPanePendingPrompt('pane-1');
```

---

## How to use it

### 1. Stage a prompt when the user picks one

When the prompt selector changes, call `setPanePendingPrompt(paneId, promptId)` so the next thread creation uses it.

### 2. Read before creating a thread

Inside your thread creation flow, read `getPanePendingPrompt(paneId)` and pass the ID to the chat builder if it exists.

### 3. Clear after applying

Once the system prompt is attached to the thread, call `clearPanePendingPrompt(paneId)` to avoid reusing it accidentally.

---

## API

```ts
setPanePendingPrompt(paneId: string, promptId: string | null): void;
getPanePendingPrompt(paneId: string): string | null | undefined;
clearPanePendingPrompt(paneId: string): void;
```

| Function                 | Description                                                                             |
| ------------------------ | --------------------------------------------------------------------------------------- |
| `setPanePendingPrompt`   | Store the prompt ID (or `null` to explicitly clear it).                                 |
| `getPanePendingPrompt`   | Return the stored ID, `null` if explicitly cleared, or `undefined` if it was never set. |
| `clearPanePendingPrompt` | Remove the key entirely from the map.                                                   |

The underlying map lives in a `reactive({})`, so Vue watchers/computed values respond to changes.

---

## Under the hood

1. Keeps a module-level reactive object `pendingByPane` keyed by pane ID.
2. Exported helpers mutate or read that map directly.
3. In dev mode, the map is exposed on `globalThis.__or3PanePendingPrompts` for debugging.

There’s no persistence; entries reset on full reload.

---

## Edge cases & tips

-   **`null` vs `undefined`**: A stored `null` means “explicitly cleared”, while `undefined` means nothing was ever set for that pane.
-   **No SSR concerns**: The composable uses in-memory state only; safe to import anywhere.
-   **Pane lifecycle**: When a pane closes, remember to call `clearPanePendingPrompt` if you want to drop staged prompts immediately.

---

## Related

-   `useMultiPane` — orchestrates pane state and is a natural place to call these helpers.
-   `useActivePrompt` — resolves prompt details once you have the ID.
-   Hooks `ui.pane.thread:action:changed` — good trigger for clearing pending prompts.
</file>

<file path="composables/usePreviewCache.md">
# usePreviewCache

In-memory LRU-ish cache for preview assets (images, PDFs, etc.). It wraps blob URL creation, tracks byte usage, exposes metrics, and handles eviction with pinning so priority previews stick around.

---

## What does it do?

`usePreviewCache` gives you a reusable cache instance that:

-   Normalises preview options via `resolvePreviewCacheOptions`
-   Provides `ensure()` to fetch or reuse cached URLs
-   Tracks hits/misses/evictions for telemetry
-   Supports pinning entries to avoid eviction while in view
-   Offers helpers to promote, release, drop, and flush entries

An additional `useSharedPreviewCache` exposes a singleton cache shared across the app.

---

## Basic Example

```ts
import { usePreviewCache } from '~/composables/core/usePreviewCache';

const cache = usePreviewCache({ maxUrls: 50, maxBytes: 50 * 1024 * 1024 });

const url = await cache.ensure('file:123', async () => {
    const blob = await fetchPreviewBlob();
    return { url: URL.createObjectURL(blob), bytes: blob.size };
});

img.src = url;
```

---

## How to use it

### 1. Create or grab the cache

```ts
const cache = useSharedPreviewCache();
// or
const cache = usePreviewCache({ maxUrls: 100, maxBytes: 80 * 1024 * 1024 });
```

### 2. Ensure previews exist

Call `ensure(key, loader, pin?)` to fetch or reuse a preview URL.

```ts
const url = await cache.ensure(hash, () => buildPreview(hash), 1);
```

### 3. Manage lifecycle

-   `promote(key)` when a preview becomes visible
-   `release(key)` when it scrolls off-screen
-   `drop(key)` or `flushAll()` to manually clear

### 4. Monitor usage

`cache.metrics()` reports counts and total bytes; `cache.logMetrics(stage)` dumps them to the console in dev builds.

---

## API

```ts
const cache = usePreviewCache(options?: Partial<PreviewCacheOptions>);
```

| Method          | Signature                                             | Description                                                                               |
| --------------- | ----------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| `ensure`        | `(key, loader, pin?) => Promise<string \| undefined>` | Return cached URL or call `loader()` to create one. Updates LRU data and enforces limits. |
| `promote`       | `(key, pin?) => void`                                 | Bump access counter and raise pin weight.                                                 |
| `release`       | `(key) => void`                                       | Lower pin count after a preview is no longer critical.                                    |
| `drop`          | `(key) => boolean`                                    | Remove a single entry and revoke the blob URL.                                            |
| `flushAll`      | `() => string[]`                                      | Remove every entry, returning the keys dropped.                                           |
| `evictIfNeeded` | `(stage?) => string[]`                                | Enforce `maxUrls`/`maxBytes`; returns evicted keys.                                       |
| `metrics`       | `() => PreviewCacheMetrics`                           | Snapshot of cache size, bytes, hits, misses, evictions.                                   |
| `logMetrics`    | `(stage) => void`                                     | Console log (dev only).                                                                   |
| `peek`          | `(key) => string \| undefined`                        | Read URL without mutating access counters.                                                |
| `options`       | `PreviewCacheOptions`                                 | Resolved options (max counts, etc.).                                                      |

`useSharedPreviewCache(overrides?)` returns a singleton instance; overrides only apply to the first call (later overrides warn in dev). `resetSharedPreviewCache()` flushes and clears the singleton reference.

---

## Under the hood

1. **Options resolution** — Merges partial overrides with defaults via `resolvePreviewCacheOptions`.
2. **Map storage** — Maintains a `Map<key, CacheEntry>` with metadata (`bytes`, `pin`, `lastAccess`).
3. **LRU eviction** — When limits are exceeded, entries sort by pin weight then `lastAccess`; unpinned, least-recent entries fall out first.
4. **Blob revocation** — `remove()` revokes object URLs via `URL.revokeObjectURL` to avoid leaks.
5. **Metrics** — Hits/misses/evictions counters increment inside `ensure()`/`evictIfNeeded()`; `metrics()` packages them for dashboards.

---

## Edge cases & tips

-   **Pinning**: `pin` is additive—pass higher numbers to make an item harder to evict (e.g., 2 for hero previews). Remember to `release`.
-   **Loader bytes**: If the loader omits `bytes`, the cache assumes `0`. Supplying the blob size keeps eviction accurate.
-   **Shared cache overrides**: Only the first call to `useSharedPreviewCache` respects overrides; later calls log a warning when options differ.
-   **Server-side rendering**: Safe to import, but loaders should guard against browser-only APIs (e.g., `URL.createObjectURL`).
-   **Diagnostics**: Call `logMetrics('stage-name')` in dev to trace eviction behavior.

---

## Related

-   `preview-cache` config (`~/config/preview-cache.ts`) — default limits and resolver.
-   `useWorkspaceBackup` — another heavy I/O composable that benefits from previews for status screens.
-   `useSharedPreviewCache` / `resetSharedPreviewCache` — exported alongside this composable for global cache reuse.
</file>

<file path="composables/useProjectsCrud.md">
# useProjectsCrud

Project CRUD toolkit that wraps Dexie helpers with validation, timestamping, and data normalisation for OR3 project records.

---

## What does it do?

`useProjectsCrud()` returns methods to create, rename, delete, and update projects:

-   `createProject` builds a new record with generated IDs, timestamps, and trimmed input.
-   `renameProject` validates titles and upserts updates.
-   `deleteProject` supports soft and hard delete flows.
-   `updateProjectEntries` replaces the project’s `data` array with normalised entries.
-   `syncProjectEntryTitle` propagates entry title/kind updates across every project reference.

Each helper uses the shared Dexie `db` instance under the hood.

---

## Basic Example

```ts
import { useProjectsCrud } from '~/composables/projects/useProjectsCrud';

const {
    createProject,
    renameProject,
    deleteProject,
    updateProjectEntries,
    syncProjectEntryTitle,
} = useProjectsCrud();

const projectId = await createProject({
    name: 'Design Sprint',
    description: 'Week-long challenge',
});

await renameProject(projectId, 'Design Sprint Q3');

await updateProjectEntries(projectId, [
    { id: 'doc-1', name: 'Brief', kind: 'doc' },
    { id: 'chat-8', name: 'AI brainstorm', kind: 'chat' },
]);

await deleteProject(projectId, { soft: true });
```

---

## How to use it

### 1. Instantiate once per setup

Call `const api = useProjectsCrud()` in composables or components. The returned methods are stateless and can be reused across calls.

### 2. Create projects

-   `createProject({ name, description?, id? })` trims input, generates defaults, and writes via `create.project`.
-   Returns the new project ID so you can navigate or open panes immediately.

### 3. Update metadata

-   `renameProject(id, name)` trims the new name and ensures the project exists before upserting.
-   `updateProjectEntries(id, entries)` clones the array before persisting to avoid mutating callers.

### 4. Delete projects

-   Soft delete (default) marks the record via `del.soft.project`.
-   Hard delete (`{ soft: false }`) removes it entirely via `del.hard.project`.

### 5. Sync linked entry titles

`syncProjectEntryTitle(entryId, kind, title)` iterates every project, normalises `data`, and updates matching entries—useful when a document/chat is renamed elsewhere.

---

## What you get back

`useProjectsCrud()` returns:

| Method                                        | Description                                                                           |
| --------------------------------------------- | ------------------------------------------------------------------------------------- |
| `createProject(input)`                        | Creates a project; throws if name missing. Returns new ID.                            |
| `renameProject(id, name)`                     | Renames an existing project; throws if not found or name empty.                       |
| `deleteProject(id, options?)`                 | Soft or hard deletes a project.                                                       |
| `updateProjectEntries(id, entries)`           | Replaces the project’s `data` array after cloning entries.                            |
| `syncProjectEntryTitle(entryId, kind, title)` | Updates matching entry names across all projects; returns number of projects touched. |

---

## Under the hood

1. **Dexie helpers** – Calls `create.project`, `upsert.project`, `del.soft.project`, `del.hard.project`, and `db.projects.bulkPut`.
2. **Timestamps** – Uses `nowSec()` for `created_at`/`updated_at`, ensuring consistent epoch seconds throughout the app.
3. **ID generation** – Defaults to `newId()` when callers omit `id`.
4. **Normalisation** – Clones entry objects and relies on `normalizeProjectData` to accommodate legacy formats.
5. **Bulk updates** – `syncProjectEntryTitle` batches writes with `bulkPut` to minimise Dexie transactions.

---

## Edge cases & tips

-   **Empty names**: Helpers throw if the provided name is blank after trimming—handle errors in your UI.
-   **Missing project**: `renameProject` and `updateProjectEntries` throw when `db.projects.get` can’t find the ID.
-   **Concurrent edits**: `clock` isn’t mutated here; if you rely on CRDT syncs, adjust the payload before calling `upsert`.
-   **Entry kind**: `syncProjectEntryTitle` supplies `kind` when missing so downstream UIs can rely on it.
-   **Soft delete recovery**: Soft-deleted records still exist; build admin tooling to restore if required.

---

## Related

-   `useProjectTreeActions` — UI actions for projects and their entries.
-   `~/utils/projects/normalizeProjectData` — ensures project `data` arrays follow the latest schema.
-   `~/db/projects` — Dexie schema and helper exports referenced here.

---

## TypeScript

```ts
interface CreateProjectInput {
    name: string;
    description?: string | null;
    id?: string;
}

interface DeleteProjectOptions {
    soft?: boolean;
}

type ProjectEntry = {
    id: string;
    name: string;
    kind?: ProjectEntryKind;
    [key: string]: any;
};

function useProjectsCrud(): {
    createProject(input: CreateProjectInput): Promise<string>;
    renameProject(id: string, name: string): Promise<void>;
    deleteProject(id: string, options?: DeleteProjectOptions): Promise<void>;
    updateProjectEntries(id: string, entries: ProjectEntry[]): Promise<void>;
    syncProjectEntryTitle(
        entryId: string,
        kind: ProjectEntryKind,
        title: string
    ): Promise<number>;
};
```
</file>

<file path="composables/useProjectTreeActions.md">
# useProjectTreeActions

Extensible action registry for the project tree sidebar. Lets plugins add context buttons to project rows or child entries (documents, chats) with ordering and visibility controls.

---

## What does it do?

`useProjectTreeActions` builds on the generic `createRegistry` utility to provide:

-   `registerProjectTreeAction()` to add or replace project tree actions.
-   `useProjectTreeActions()` to retrieve a reactive, sorted list of actions.
-   `unregisterProjectTreeAction()` for cleanup.
-   `listRegisteredProjectTreeActionIds()` to inspect current registrations.

Actions can target project roots, all rows, or specific child kinds (`chat`, `doc`) via `showOn` filters.

---

## Basic Example

```ts
import {
    registerProjectTreeAction,
    unregisterProjectTreeAction,
    useProjectTreeActions,
} from '~/composables/projects/useProjectTreeActions';

registerProjectTreeAction({
    id: 'custom:open-in-new-pane',
    icon: 'i-ph-squares-four',
    label: 'Open in new pane',
    order: 180,
    showOn: ['doc', 'chat'],
    async handler({ treeRow }) {
        if ('parentId' in treeRow) {
            await openEntryInFreshPane(treeRow.value);
        }
    },
});

const actions = useProjectTreeActions();

onScopeDispose(() => {
    unregisterProjectTreeAction('custom:open-in-new-pane');
});
```

---

## How to use it

### 1. Register an action

Call `registerProjectTreeAction()` when your plugin starts. Provide a unique `id`, Iconify `icon`, `label`, optional `order`, `showOn`, and an async-compatible `handler`.

### 2. Target specific rows

-   Omitting `showOn` shows the action everywhere.
-   Include `['root']` to limit to project rows.
-   Use `['doc']` or `['chat']` to target children representing documents or chat threads.

### 3. Handle the click

The handler receives `{ treeRow, child, root }`:

-   `treeRow` is always present and can be root or child.
-   `child` and `root` remain for legacy shapes—prefer `treeRow` moving forward.

### 4. Consume from the UI

`useProjectTreeActions()` returns a reactive array used by components like `SidebarProjectTree.vue`. You rarely call it yourself unless you render a custom tree UI.

### 5. Clean up

Call `unregisterProjectTreeAction()` during dispose to keep the registry tidy across HMR.

---

## API

```ts
registerProjectTreeAction(action: ProjectTreeAction): void;
unregisterProjectTreeAction(id: string): void;
useProjectTreeActions(): ComputedRef<ProjectTreeAction[]>;
listRegisteredProjectTreeActionIds(): string[];
```

---

## Under the hood

1. **Registry factory** – Uses `createRegistry('__or3ProjectTreeActionsRegistry')`, which already handles sorting, deduping, and reactivity.
2. **Ordering** – `createRegistry` sorts by `order` (default 200); ties fall back to registration order.
3. **HMR safe** – The registry lives on `globalThis`, so multiple imports share the same entries.
4. **Visibility filtering** – Consumers apply `showOn` checks before rendering buttons, ensuring minimal logic in handlers.

---

## Edge cases & tips

-   **Unknown `treeRow` shape**: Some legacy callers might pass `child`/`root`; guard your handler accordingly.
-   **Async errors**: Return promises and handle errors inside the handler—UI components don’t catch them automatically.
-   **Order collisions**: Use different `order` buckets to cluster your plugin’s actions together.
-   **Testing**: In Jest/Vitest, stub `createRegistry` with a local implementation if you want to isolate actual Dexie usage.

---

## Related

-   `useProjectsCrud` — manages the underlying Dexie project records.
-   `~/app/components/sidebar/SidebarProjectTree.vue` — consumes this registry to render contextual menus.
-   `~/utils/projects/normalizeProjectData` — helps keep tree rows consistent with stored data.

---

## TypeScript

```ts
type ProjectTreeKind = 'chat' | 'doc';
type ShowOnKind = 'root' | 'all' | 'chat' | 'doc';

interface ProjectTreeChild {
    value: string;
    label: string;
    icon?: string;
    kind?: ProjectTreeKind;
    parentId?: string;
    onSelect?: (e: Event) => void;
}

interface ProjectTreeRoot {
    value: string;
    label: string;
    defaultExpanded?: boolean;
    children?: ProjectTreeChild[];
    onSelect?: (e: Event) => void;
}

interface ProjectTreeAction {
    id: string;
    icon: string;
    label: string;
    order?: number;
    showOn?: ShowOnKind[];
    handler: (ctx: ProjectTreeHandlerCtx) => void | Promise<void>;
}
```
</file>

<file path="composables/useSidebarSearch.md">
# useSidebarSearch

Unified search composable that indexes threads, projects, and documents for the sidebar search bar. Uses Orama for fast client-side search with a substring fallback to guarantee results.

---

## What does it do?

`useSidebarSearch(threads, projects, documents)` returns reactive state and helpers that:

-   Build (and rebuild) a shared Orama index when underlying data changes.
-   Debounce queries (120 ms) and return results grouped by type.
-   Provide a substring fallback if Orama throws or returns zero hits.
-   Track readiness/busy states and expose a manual `rebuild()` + `runSearch()` API.

The composable mirrors the pattern established in `useThreadSearch` but spans multiple datasets.

---

## Basic Example

```ts
import { useSidebarSearch } from '~/composables/sidebar/useSidebarSearch';

const threads = useThreads();
const projects = useProjects();
const documents = useDocuments();

const { query, threadResults, projectResults, documentResults, ready, busy } =
    useSidebarSearch(threads, projects, documents);

watch(query, (value) => console.debug('Searching for', value));
```

---

## How to use it

### 1. Pass in reactive sources

Provide `Ref<Thread[]>`, `Ref<Project[]>`, and `Ref<Post[]>`. The composable watches for changes and rebuilds the index only when counts or `updated_at` signatures change.

### 2. Bind the query input

`query` is a writable `ref<string>`. Watch or v-model it in your search input. Typing triggers a debounced search.

### 3. Render grouped results

Use `threadResults`, `projectResults`, and `documentResults` to populate search dropdowns or grouped lists.

### 4. Handle readiness/loading

-   `ready` flips to `true` after the first successful index build.
-   `busy` reports when the index rebuild is in progress.

### 5. Manual maintenance

-   Call `rebuild()` to force an index rebuild (e.g., after external imports).
-   Call `runSearch()` to re-run the query without changing `query.value`.

---

## What you get back

`useSidebarSearch` returns:

| Property          | Type                  | Description                                        |
| ----------------- | --------------------- | -------------------------------------------------- |
| `query`           | `Ref<string>`         | Current search string.                             |
| `threadResults`   | `Ref<Thread[]>`       | Matching threads.                                  |
| `projectResults`  | `Ref<Project[]>`      | Matching projects.                                 |
| `documentResults` | `Ref<Post[]>`         | Matching documents (filtered to non-deleted docs). |
| `ready`           | `Ref<boolean>`        | `true` once the Orama index is built.              |
| `busy`            | `Ref<boolean>`        | `true` while rebuilding.                           |
| `rebuild`         | `() => Promise<void>` | Forces index rebuild.                              |
| `runSearch`       | `() => Promise<void>` | Runs search against current query.                 |

---

## Under the hood

1. **Document signature** – `computeSignature()` combines dataset counts + latest `updated_at` to decide when to rebuild.
2. **Orama index** – Builds a schema with `id`, `kind`, `title`, `updated_at`, and indexes all eligible records.
3. **ID maps** – Maintains `id → entity` dictionaries per kind for quick result mapping.
4. **Search pipeline** – Runs Orama search with limit 500. If no hits or an error occurs, falls back to case-insensitive substring matching.
5. **Debounce** – Uses a `setTimeout` to delay searches by 120 ms, mirroring other search composables.

---

## Edge cases & tips

-   **Empty query**: Returns full datasets (threads, projects, docs) instead of empty results.
-   **Deleted docs**: Filters out posts with `postType !== 'doc'` or `deleted === true` in both index build and fallback.
-   **Index rebuild storms**: The signature guard prevents redundant rebuilds even when watchers fire frequently.
-   **Fallback warning**: Logs a warning once (`[useSidebarSearch] fallback substring search used`) to aid debugging.
-   **Stale searches**: Uses incremental `lastQueryToken` to discard results from outdated async calls.

---

## Related

-   `useThreadSearch` — single-domain search the pattern was based on.
-   `~/core/search/orama` — shared Orama helpers (`createDb`, `buildIndex`, `searchWithIndex`).
-   `~/composables/sidebar/useSidebarSections` — consumer of the search results to display grouped lists.

---

## TypeScript

```ts
function useSidebarSearch(
    threads: Ref<Thread[]>,
    projects: Ref<Project[]>,
    documents: Ref<Post[]>
): {
    query: Ref<string>;
    threadResults: Ref<Thread[]>;
    projectResults: Ref<Project[]>;
    documentResults: Ref<Post[]>;
    ready: Ref<boolean>;
    busy: Ref<boolean>;
    rebuild: () => Promise<void>;
    runSearch: () => Promise<void>;
};
```
</file>

<file path="composables/useSidebarSections.md">
# useSidebarSections

Sidebar chrome registry that lets plugins add new panels (top/main/bottom stacks) and footer actions to the OR3 sidebar. Provides ordering, placement, visibility, and disabled control.

---

## What does it do?

`useSidebarSections` exposes two registries via the shared `_registry` factory:

-   Section registry: `registerSidebarSection()` / `useSidebarSections()` groups components by placement (`top`, `main`, `bottom`).
-   Footer action registry: `registerSidebarFooterAction()` / `useSidebarFooterActions()` manages button-style actions rendered in the sidebar footer.

Both registries share ordering semantics and dedupe logic.

---

## Basic Example

```ts
import {
    registerSidebarSection,
    unregisterSidebarSection,
    useSidebarSections,
    registerSidebarFooterAction,
    unregisterSidebarFooterAction,
} from '~/composables/sidebar/useSidebarSections';

registerSidebarSection({
    id: 'custom:tips',
    component: () => import('~/components/sidebar/TipsPanel.vue'),
    placement: 'bottom',
    order: 210,
});

registerSidebarFooterAction({
    id: 'custom:new-project',
    icon: 'i-ph-plus-circle',
    label: 'New Project',
    color: 'primary',
    handler: () => openNewProjectModal(),
});

const sections = useSidebarSections();
const footerActions = useSidebarFooterActions(() => ({
    activeThreadId: currentThreadId.value,
}));

onScopeDispose(() => {
    unregisterSidebarSection('custom:tips');
    unregisterSidebarFooterAction('custom:new-project');
});
```

---

## How to use it

### 1. Register sections

-   Provide a unique `id`, a Vue component (sync or async factory), optional `order`, and `placement`.
-   Default placement is `'main'`, which renders inside the primary scroll stack.
-   Sections are rendered as-is, so handle loading states internally for async components.

### 2. Register footer actions

-   Define Iconify `icon`, optional `label`, `tooltip`, `color`, and `order`.
-   `visible(ctx)` and `disabled(ctx)` let you tailor actions to the active thread/document or collapsed sidebar state.

### 3. Consume registries

-   `useSidebarSections()` returns a computed object `{ top, main, bottom }`, each sorted by `order`.
-   `useSidebarFooterActions(contextFn)` returns a computed array of `{ action, disabled }` entries based on the latest context.

### 4. Clean up

Call the matching `unregister*` helpers during scope disposal/HMR to prevent duplicates.

---

## What you get back

### Sections

`useSidebarSections()` → `ComputedRef<{ top: SidebarSection[]; main: SidebarSection[]; bottom: SidebarSection[] }>`

### Footer actions

`useSidebarFooterActions(contextFn)` → `ComputedRef<SidebarFooterActionEntry[]>`

Each `SidebarFooterActionEntry` contains the original action and `disabled` boolean.

---

## Under the hood

1. **Registry factory** – Uses `createRegistry('__or3SidebarSectionsRegistry')` and `createRegistry('__or3SidebarFooterActionsRegistry')`, which handle reactivity, sorting, and deduping.
2. **Default ordering** – Applies `order ?? 200` for deterministic placement relative to built-ins.
3. **Placement split** – The `useSidebarSections()` computed buckets entries by `placement` before sorting.
4. **Context evaluation** – Footer actions evaluate `visible`/`disabled` with the provided context function each render.

---

## Edge cases & tips

-   **Async components**: When `component` is a lazy import, Nuxt handles suspense; consider showing an internal loading indicator for better UX.
-   **Collapsed sidebar**: Use the `isCollapsed` flag inside footer action predicates to hide text-heavy buttons.
-   **Multiple registrations**: Re-registering with the same `id` replaces the previous entry—handy for overrides.
-   **Testing**: Mock `createRegistry` for deterministic unit tests.

---

## Related

-   `useHeaderActions` — header button registry sharing the same pattern.
-   `useComposerActions` — controls the chat composer quick actions.
-   `~/composables/_registry` — factory implementing the registry mechanics.

---

## TypeScript

```ts
type SidebarSectionPlacement = 'top' | 'main' | 'bottom';

interface SidebarSection extends RegistryItem {
    id: string;
    component: Component | (() => Promise<any>);
    order?: number;
    placement?: SidebarSectionPlacement;
}

type ChromeActionColor =
    | 'neutral'
    | 'primary'
    | 'secondary'
    | 'success'
    | 'warning'
    | 'error'
    | 'info'
    | 'inverse-primary'
    | (string & {});

interface SidebarFooterAction extends RegistryItem {
    id: string;
    icon: string;
    label?: string;
    tooltip?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: SidebarFooterActionContext) => void | Promise<void>;
    visible?: (ctx: SidebarFooterActionContext) => boolean;
    disabled?: (ctx: SidebarFooterActionContext) => boolean;
}
```
</file>

<file path="composables/useStreamAccumulator.md">
# useStreamAccumulator

Frame-batched accumulator for AI streaming tokens. It receives partial text/reasoning deltas, buffers them, and flushes at most once per animation frame so the UI stays smooth.

---

## Purpose

`useStreamAccumulator` replaces ad-hoc refs for building assistant responses. It normalises streaming flow with a single API:

-   `append()` collects text or reasoning deltas without immediate DOM churn
-   `finalize()` seals the stream and records errors/abort state
-   `reset()` prepares for the next stream
-   `state` exposes reactive fields (`text`, `reasoningText`, `isActive`, etc.) any component can watch

The accumulator automatically batches writes via `requestAnimationFrame` when available, falling back to microtasks in environments without rAF (tests, SSR stubs).

---

## Quick example

```ts
import { useStreamAccumulator } from '~/composables/chat/useStreamAccumulator';

const stream = useStreamAccumulator();

// Stream chunks coming from OpenRouter
stream.append('Hello', { kind: 'text' });
stream.append(', world!', { kind: 'text' });
stream.append('Considering user intent...', { kind: 'reasoning' });

// When the stream completes:
stream.finalize();

console.log(stream.state.text); // "Hello, world!"
```

---

## API

| Member                   | Type                                                                | Description                                                                                            |
| ------------------------ | ------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| `state`                  | `Readonly<StreamingState>`                                          | Reactive state object (see below).                                                                     |
| `append(delta, options)` | `(delta: string, options: { kind: 'text' \| 'reasoning' }) => void` | Queue a delta chunk for batching. Empty strings are ignored.                                           |
| `finalize(opts?)`        | `(opts?: { error?: Error; aborted?: boolean }) => void`             | Flush any pending chunks, mark the stream inactive/finalized, optionally capture an error. Idempotent. |
| `reset()`                | `() => void`                                                        | Cancel pending frames, clear buffers, and return the state to its initial active state.                |

### `StreamingState`

```ts
interface StreamingState {
    text: string;
    reasoningText: string;
    isActive: boolean;
    finalized: boolean;
    error: Error | null;
    version: number; // increments each flush for lightweight watchers
}
```

The composable exports `type UnifiedStreamingState = StreamingState` for consumers migrating from legacy code.

---

## Usage patterns

### Wiring into a stream handler

```ts
const accumulator = useStreamAccumulator();

async function handleChunk(chunk: StreamChunk) {
    if (chunk.type === 'text-delta') {
        accumulator.append(chunk.text, { kind: 'text' });
    } else if (chunk.type === 'reasoning-delta') {
        accumulator.append(chunk.reasoning, { kind: 'reasoning' });
    }
}

function handleComplete(error?: Error) {
    accumulator.finalize(error ? { error } : undefined);
}
```

### Reacting to flushes

```ts
watch(
    () => accumulator.state.version,
    () => {
        latestText.value = accumulator.state.text;
    }
);
```

### Reusing for multiple responses

```ts
accumulator.reset();
// start next stream by calling append() again
```

---

## Internals

1. **Batching** — Deltas are stored in `pendingMain` / `pendingReasoning` arrays until `flush()` concatenates and appends to `state`. `flush()` runs via rAF; if unavailable, a cancelable microtask is used.
2. **Idempotent finalize** — Calls after the first are no-ops (with dev warnings). `finalize()` cancels scheduled frames, flushes remaining buffers, flips `isActive` false, marks `finalized`, and sets `error` when provided.
3. **Reset logic** — Cancels pending frames/microtasks, clears buffers, resets state values, and bumps `version` so watchers notice the reset.
4. **Empty delta guard** — Ignores empty strings and warns (up to three times in dev) to highlight upstream tokenization issues.
5. **Environment-safe** — `getRAF()` / `getCAF()` resolve lazily so tests can stub them; SSR falls back to `setTimeout`.

---

## Tips & edge cases

-   **Multiple consumers**: `state` is reactive; share it across components without additional refs.
-   **Abort semantics**: Pass `finalize({ aborted: true })` if the stream was cancelled. Downstream UI can infer this from `state.isActive === false && state.finalized === true` plus the `aborted` flag you track externally.
-   **Error path**: Provide `finalize({ error })` to surface issues; UI can render the error based on `state.error`.
-   **Reset before reuse**: Always call `reset()` before starting another stream on the same accumulator.
-   **Performance**: Because flushing happens ≤ once per frame, high-frequency streams won’t thrash the DOM even when chunks arrive rapidly.

---

## Related modules

-   `useChat` — consumes this accumulator to build assistant messages.
-   Legacy `useTailStream` — superseded by this composable.
-   Streaming infrastructure in `~/core` — responsible for turning OpenRouter SSE events into `append()` calls.
</file>

<file path="composables/useThreadHistoryActions.md">
# useThreadHistoryActions

Registry for adding custom actions to the thread history sidebar dropdown. Mirrors the document history registry but targets threads, letting plugins inject export, share, or workflow buttons.

---

## What does it do?

`useThreadHistoryActions` exposes:

-   `registerThreadHistoryAction()` / `unregisterThreadHistoryAction()` to manage action lifecycle.
-   `useThreadHistoryActions()` to read a sorted, reactive list of actions for rendering.
-   `listRegisteredThreadHistoryActionIds()` for debugging or collision checks.

Actions are stored globally on `globalThis`, so they persist across HMR and shared imports.

---

## Basic Example

```ts
import {
    registerThreadHistoryAction,
    unregisterThreadHistoryAction,
    useThreadHistoryActions,
} from '~/composables/threads/useThreadHistoryActions';

registerThreadHistoryAction({
    id: 'custom:export-thread',
    icon: 'i-ph-cloud-arrow-down',
    label: 'Export Thread',
    order: 210,
    async handler({ document }) {
        await exportThread(document.id);
    },
});

const actions = useThreadHistoryActions();

onScopeDispose(() => {
    unregisterThreadHistoryAction('custom:export-thread');
});
```

---

## How to use it

### 1. Register actions when your plugin loads

-   Namespace IDs (`my-plugin:action`) to avoid collisions.
-   Provide `icon`, `label`, optional `order`, and a `handler` receiving `{ document: Thread }`.

### 2. Consume the computed list

-   Components like `SidebarThreadHistory.vue` call `useThreadHistoryActions()` to obtain sorted actions.
-   The returned array is already sorted by `order` (default 200) so you can render directly.

### 3. Cleanup for HMR

-   Call `unregisterThreadHistoryAction()` (or wrap registration in `useHookEffect`) to keep the registry tidy during hot reloads.

### 4. Handle async operations

-   `handler` can be async; manage toasts/loading in your own logic.

---

## What you get back

`useThreadHistoryActions()` → `ComputedRef<ThreadHistoryAction[]>` where each action includes:

| Property  | Type                                 | Description                              |
| --------- | ------------------------------------ | ---------------------------------------- | --------------- |
| `id`      | `string`                             | Unique identifier.                       |
| `icon`    | `string`                             | Iconify name to display in the dropdown. |
| `label`   | `string`                             | Action text shown next to the icon.      |
| `order`   | `number \| undefined`                | Sorting hint (default 200).              |
| `handler` | `(ctx: { document: Thread }) => void | Promise<void>`                           | Click callback. |

---

## Under the hood

1. **Global registry** – Uses `globalThis.__or3ThreadHistoryActionsRegistry` so multiple imports share the same entries.
2. **Reactive mirror** – Maintains `reactiveList.items` for Vue to track updates without making the map reactive.
3. **Sorting** – The computed accessor sorts by `order` each time, keeping render order deterministic.
4. **HMR-safe** – Overwriting the same ID just replaces the entry; dev warnings can be added similarly to other registries if needed.

---

## Edge cases & tips

-   **Duplicate IDs**: Last registration wins. Use `listRegisteredThreadHistoryActionIds()` to inspect the registry.
-   **Missing thread**: Ensure components pass the correct `Thread` to handlers; the registry doesn’t enforce schema.
-   **Async errors**: Catch and surface toast messages yourself—the registry doesn’t handle failure reporting.
-   **Order buckets**: Follow the convention (built-ins ~100–150, extensions ≥200) for predictable placement.

---

## Related

-   `useDocumentHistoryActions` — sister registry for documents.
-   `useThreadSearch` — locate threads for history UI.
-   `~/app/components/sidebar/ThreadHistory.vue` — consumes this registry to render dropdown actions.

---

## TypeScript

```ts
interface ThreadHistoryAction {
    id: string;
    icon: string;
    label: string;
    order?: number;
    handler: (ctx: { document: Thread }) => void | Promise<void>;
}
```
</file>

<file path="composables/useThreadSearch.md">
# useThreadSearch

Thread-specific search composable that powers the sidebar query field. Builds a small Orama index over thread titles, debounces input, and falls back to substring matching when required.

---

## What does it do?

`useThreadSearch(threads)` delivers:

-   A writable `query` ref bound to the search input.
-   A reactive `results` list kept in sync with Orama hits or substring fallback.
-   Automatic index rebuilds when the thread collection grows or shrinks.
-   Debounced searches (120 ms) to avoid excessive recomputation.
-   Convenience helpers (`rebuild`, `runSearch`) plus ready/busy flags.

---

## Basic Example

```ts
import { useThreadSearch } from '~/composables/threads/useThreadSearch';

const threads = useThreads(); // Ref<Thread[]>

const { query, results, ready, busy, rebuild } = useThreadSearch(threads);

watch(results, (list) => console.debug('Thread matches', list.length));

// Force rebuild after an import
await rebuild();
```

---

## How to use it

### 1. Pass a reactive thread array

Provide a `Ref<Thread[]>`. The composable rebuilds the index whenever the array length changes. For title-only edits, call `rebuild()` manually.

### 2. Bind `query`

Use `v-model="query.value"` (or simply `v-model="query"`) on your search input. Typing triggers debounced searches; clearing it restores the full thread list.

### 3. Render `results`

Loop over `results.value` to render matches ordered by relevance or fallback order.

### 4. Observe status

-   `ready.value` becomes `true` after the first successful index build.
-   `busy.value` is `true` while an index rebuild is in flight.

### 5. Control manually when needed

Call `await rebuild()` before heavy operations, or `await runSearch()` to refresh results after custom filters.

---

## What you get back

| Property    | Type                  | Description                        |
| ----------- | --------------------- | ---------------------------------- |
| `query`     | `Ref<string>`         | Current search string.             |
| `results`   | `Ref<Thread[]>`       | Matching threads.                  |
| `ready`     | `Ref<boolean>`        | Indicates the index is built.      |
| `busy`      | `Ref<boolean>`        | `true` when rebuilding the index.  |
| `rebuild`   | `() => Promise<void>` | Forces index rebuild.              |
| `runSearch` | `() => Promise<void>` | Runs search for the current query. |

---

## Under the hood

1. **Index build** — Uses `createDb`/`buildIndex` from `~/core/search/orama` with schema `{ id, title, updated_at }`.
2. **ID map** — Maintains an `id → Thread` dictionary for quick hit resolution.
3. **Debounce** — Delays `runSearch()` by 120 ms after each query change via `setTimeout`.
4. **Fallback** — If Orama returns zero hits or throws, filters by `title.toLowerCase().includes(query)` and logs a warning once.
5. **Stale guard** — Uses `lastQueryToken` to ignore late async responses when queries change quickly.

---

## Edge cases & tips

-   **Untitled threads**: Empty titles default to `'Untitled Thread'` before indexing, so they still appear.
-   **Empty query**: Returns the full thread list to mirror the sidebar UX.
-   **Large datasets**: Increase the search limit in the composed call if you need more than 200 hits.
-   **SSR**: Safe to import on the server; the index only builds on the client when watchers run.

---

## Related

-   `useSidebarSearch` — multi-entity search that also covers projects and documents.
-   `useThreadHistoryActions` — companion registry for thread dropdown actions.
-   `~/core/search/orama` — shared Orama helpers used throughout the app.

---

## TypeScript

```ts
function useThreadSearch(threads: Ref<Thread[]>): {
    query: Ref<string>;
    results: Ref<Thread[]>;
    ready: Ref<boolean>;
    busy: Ref<boolean>;
    rebuild: () => Promise<void>;
    runSearch: () => Promise<void>;
};
```
</file>

<file path="composables/useWorkspaceBackup.md">
# useWorkspaceBackup

Full-featured workspace export/import controller for OR3. It coordinates Dexie exports, streaming backups, progress reporting, hook telemetry, and error handling so the UI can offer reliable backup workflows.

---

## What does it do?

`useWorkspaceBackup` manages every stage of backing up and restoring the local database:

-   Streams workspace exports to the File System Access API or StreamSaver fallback
-   Peeks backup files to surface metadata before import (format, table counts, etc.)
-   Imports backups in “replace” or “append” modes, with optional value overwrites
-   Tracks progress, step state, and errors in reactive refs for real-time UI updates
-   Dispatches hook events for extension telemetry and clean integrations

---

## Basic Example

```ts
import { useWorkspaceBackup } from '~/composables/core/useWorkspaceBackup';

const backup = useWorkspaceBackup();

async function exportNow() {
    await backup.exportWorkspace();
}

async function importFile(file: File) {
    await backup.peekBackup(file); // show metadata & ask user
    await backup.importWorkspace(file);
}
```

---

## How to use it

### 1. Create the composable

```ts
const backup = useWorkspaceBackup();
const { state } = backup;
```

`state` contains refs for loading indicators, progress bars, metadata, and errors—bind them straight into your component.

### 2. Export workflow

1. Call `backup.exportWorkspace()` in response to “Export” action.
2. Observe `state.isExporting`, `state.progress`, and `state.currentStep` for UI feedback.
3. On success, `currentStep` becomes `'done'`; reset the form with `backup.reset()` if you want to start fresh.

### 3. Inspect a backup file

1. Prompt the user for a file.
2. Call `await backup.peekBackup(file)`.
3. Read `state.backupMeta` (tables, counts) and `state.backupFormat` (`'stream'` or `'dexie'`).
4. Let the user choose `state.importMode` (`'replace' | 'append'`) and `state.overwriteValues` if appending.

### 4. Import workflow

1. Call `await backup.importWorkspace(file)`.
2. Watch `state.isImporting`, `state.progress`, and `state.currentStep`.
3. On completion, the composable fires `workspace:reloaded` hook so downstream stores can refresh.

### 5. Error handling

If any step fails, `state.error` holds an `AppError`. Show `state.currentStep === 'error'` to display a retry prompt. `backup.reset()` clears the state.

---

## API

```ts
const backup = useWorkspaceBackup();
```

### Returned object

| Property / Method       | Type                            | Description                                             |
| ----------------------- | ------------------------------- | ------------------------------------------------------- |
| `state`                 | `WorkspaceBackupState`          | Reactive refs for UI (see table below).                 |
| `exportWorkspace()`     | `() => Promise<void>`           | Streams the database to disk. No-op if already running. |
| `peekBackup(file)`      | `(file: Blob) => Promise<void>` | Reads metadata and sets `backupMeta`/`backupFormat`.    |
| `importWorkspace(file)` | `(file: Blob) => Promise<void>` | Imports according to `importMode`/`overwriteValues`.    |
| `reset()`               | `() => void`                    | Clears status flags, metadata, and errors.              |

### `WorkspaceBackupState`

| Ref               | Type                | Purpose                                              |
| ----------------- | ------------------- | ---------------------------------------------------- | ----------------------------------------------- | ------------------------------------------- | ----------- | ------ | --------- | -------------------------- |
| `isExporting`     | `Ref<boolean>`      | `true` while an export is in progress.               |
| `isImporting`     | `Ref<boolean>`      | `true` while an import is running.                   |
| `progress`        | `Ref<number>`       | 0–100 progress percentage.                           |
| `currentStep`     | `Ref<'idle'         | 'peeking'                                            | 'confirm'                                       | 'importing'                                 | 'exporting' | 'done' | 'error'>` | High-level step indicator. |
| `importMode`      | `Ref<'replace'      | 'append'>`                                           | Import strategy the user selected.              |
| `overwriteValues` | `Ref<boolean>`      | When appending, whether to replace conflicting rows. |
| `backupMeta`      | `Ref<ImportMetadata | null>`                                               | Metadata discovered during `peekBackup`.        |
| `backupFormat`    | `Ref<'stream'       | 'dexie'                                              | null>`                                          | Format derived from peek or auto-detection. |
| `error`           | `Ref<AppError       | null>`                                               | Last failure captured for UI display/reporting. |

`ImportMetadata` contains the Dexie database name/version plus table stats so you can present them to the user.

---

## Under the hood

1. **Module-level loaders** — Lazily imports `dexie-export-import` and `streamsaver` the first time they’re needed, caching promises for reuse.
2. **Export path** — Prefers the File System Access API (`showSaveFilePicker`) when available; otherwise falls back to StreamSaver with service worker shim. Progress is tracked by table/row counts from `streamWorkspaceExport` helpers.
3. **Peek** — Detects backup format by sniffing the file header. Dexie backups use `dexie-export-import`’s `peakImportFile`; stream backups parse the header line for metadata validation.
4. **Import** — Chooses between streaming import (`importWorkspaceStream`) and Dexie import (`importInto`). Appends respect `overwriteValues`; replace mode wipes tables first.
5. **Hooks** — Emits `workspace.backup.*` actions (`before`, `after`, `error`, `cancelled`) at each stage, plus `workspace:reloaded` after a successful import so other stores can resync.
6. **Error handling** — Wraps failures in `asAppError`, logs via `reportError`, and stores them in `state.error` with domain/action tags.

---

## Edge cases & tips

-   **Browser-only**: Every major action checks for `window`. In SSR contexts the composable will set an error explaining the limitation.
-   **Abort handling**: If the user cancels a save picker, the export resets to idle without surfacing an error.
-   **Version checks**: Both Dexie and stream imports validate database name/version; importing something from a newer schema raises a clear error.
-   **Chunk sizing**: Streaming exports use `STREAM_CHUNK_SIZE = 500` rows; Dexie imports default to ~1 MB chunks (`DEFAULT_KILOBYTES_PER_CHUNK`). Adjust in utilities if you need different throughput.
-   **Overwrite semantics**: In append mode, `overwriteValues` lets you merge data without wiping tables—set it via UI toggle before calling `importWorkspace`.
-   **Cleanup**: Call `reset()` after successful operations if you want to start a new flow without refreshing the page.

---

## Related

-   `~/utils/workspace-backup-stream.ts` — Implements the streaming codec used here.
-   `usePreviewCache` — Pair with this composable to manage heavy preview blobs alongside exports.
-   Hook reference in `docs/core-hook-map.md` — Lists the backup-related hooks emitted during each stage.
</file>

<file path="database/attachments.md">
# attachments

Attachment table helpers for creating, updating, and deleting upload metadata with full hook coverage.

---

## What does it do?

-   Validates attachment payloads against `AttachmentCreateSchema`/`AttachmentSchema`.
-   Pipes all mutations through `dbTry` so quota and Dexie errors surface with contextual toasts.
-   Fires hook filters/actions around create, upsert, soft delete, hard delete, and reads.
-   Provides `nowSec()` driven soft delete flagging so rows stay recoverable until hard-deleted.

---

## Data shape

| Field        | Type      | Notes                                                |
| ------------ | --------- | ---------------------------------------------------- |
| `id`         | `string`  | Primary key supplied by caller.                      |
| `type`       | `string`  | Attachment type tag (image/pdf/etc).                 |
| `name`       | `string`  | Display name.                                        |
| `url`        | `string`  | Blob/object URL or remote link. Must be a valid URL. |
| `created_at` | `number`  | Unix timestamp (sec). Auto-defaulted by schema.      |
| `updated_at` | `number`  | Unix timestamp (sec). Auto-defaulted by schema.      |
| `deleted`    | `boolean` | Soft delete flag toggled by `softDeleteAttachment`.  |
| `clock`      | `number`  | Monotonic revision counter.                          |

---

## API surface

| Function               | Signature                                          | Description                                              |
| ---------------------- | -------------------------------------------------- | -------------------------------------------------------- | ----------------------------------------------------- |
| `createAttachment`     | `(input: AttachmentCreate) => Promise<Attachment>` | Filter + validate + insert new attachment row.           |
| `upsertAttachment`     | `(value: Attachment) => Promise<void>`             | Filter + validate + replace existing attachment.         |
| `softDeleteAttachment` | `(id: string) => Promise<void>`                    | Marks an attachment as deleted and bumps `updated_at`.   |
| `hardDeleteAttachment` | `(id: string) => Promise<void>`                    | Removes the row outright (no blob storage handled here). |
| `getAttachment`        | `(id: string) => Promise<Attachment                | undefined>`                                              | Reads a single attachment and applies output filters. |

---

## Hook points

-   `db.attachments.create:filter:input` → mutate incoming payloads before validation.
-   `db.attachments.create:action:before/after`
-   `db.attachments.upsert:filter:input` + matching before/after actions.
-   `db.attachments.delete:action:soft:*` and `db.attachments.delete:action:hard:*` fire during deletes.
-   `db.attachments.get:filter:output` lets consumers normalize read results.

---

## Usage tips

-   Always supply a `clock` increment when calling `upsertAttachment`; schema enforces numeric clocks.
-   Soft deletes keep the blob data available; schedule `hardDeleteAttachment` when you want to reclaim disk.
-   Extend hooks to inject signed URLs or sanitize file names before persistence.
</file>

<file path="database/branching.md">
# branching

Utilities for forking threads, retry-branching assistant replies, and building merged conversation contexts across Dexie tables.

---

## What does it do?

-   Provides `forkThread`, `retryBranch`, and `buildContext` helpers that run inside Dexie transactions.
-   Normalizes branch modes (`reference` vs `copy`) and message roles for consistent downstream handling.
-   Clones ancestor messages when in copy mode and keeps indexes dense.
-   Merges ancestor + local messages for context building while respecting hook-driven filtering.

---

## Key types

| Type                             | Description                                                                 |
| -------------------------------- | --------------------------------------------------------------------------- |
| `ForkMode`                       | Alias of `BranchMode` (either `'reference'` or `'copy'`).                   |
| `ForkThreadParams`               | Required `sourceThreadId`, `anchorMessageId`, optional mode/title override. |
| `RetryBranchParams`              | Assistant message to branch from plus optional mode/title.                  |
| `BranchForkBeforePayload`        | Hook payload describing source thread, anchor message, and options.         |
| `MessageEntity` / `ThreadEntity` | Lightweight shapes passed through the hook engine.                          |

---

## API surface

| Function       | Signature                                                                                   | Description                                                                           |
| -------------- | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| `forkThread`   | `({ sourceThreadId, anchorMessageId, mode, titleOverride }) => Promise<{ thread, anchor }>` | Forks a thread at a specific message, optionally copying ancestor messages.           |
| `retryBranch`  | `({ assistantMessageId, mode, titleOverride }) => Promise<{ thread, anchor }>`              | Finds the preceding user message and delegates to `forkThread`.                       |
| `buildContext` | `({ threadId }) => Promise<Message[]>`                                                      | Builds the playable context for a thread, stitching ancestors for reference branches. |

---

## Hook integration

-   `branch.fork:filter:options` to mutate incoming fork parameters.
-   `branch.fork:action:before/after` around thread creation.
-   `branch.retry:*` sequence around retry-based forks.
-   `branch.context:filter:messages` lets extensions rewrite the merged entity list before final merging.

---

## Implementation notes

1. **Transactions** — Forking and context building happen within Dexie transactions touching `threads` and `messages` tables to avoid race conditions.
2. **Indexing** — Copied messages normalize indexes starting at `0` to keep order stable in fresh forks.
3. **Role normalization** — Any non-assistant/system role becomes `user` so AI context stays predictable.
4. **Perf** — `buildContext` batches ancestor and local queries in parallel and dedupes via `Map` before merging.

---

## Usage tips

-   Use `mode: 'copy'` when you need historical messages physically duplicated for offline tweaks; otherwise the cheaper reference mode keeps storage down.
-   Customize `branch.fork:filter:options` to auto-name forks (e.g., prepend emoji or include anchor timestamp).
-   When building custom prompts, call `buildContext` to get the exact message list that the composer expects.
</file>

<file path="database/client.md">
# client

Dexie database client that defines the `Or3DB` schema, typed tables, and versioning rules.

---

## What does it do?

-   Establishes the single IndexedDB database named `or3-db`.
-   Declares typed `Dexie.Table` instances for every entity (projects, threads, messages, etc.).
-   Collapses historical migrations into version `5` so existing installs stay compatible without upgrade churn.

---

## Tables & indexes

| Table         | Primary key | Secondary indexes                                                                                                                                                       |
| ------------- | ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `projects`    | `id`        | `name`, `clock`, `created_at`, `updated_at`                                                                                                                             |
| `threads`     | `id`        | `[project_id+updated_at]`, `parent_thread_id`, `[parent_thread_id+anchor_index]`, `status`, `pinned`, `deleted`, `last_message_at`, `clock`, `created_at`, `updated_at` |
| `messages`    | `id`        | `[thread_id+index]`, `thread_id`, `index`, `role`, `deleted`, `stream_id`, `clock`, `created_at`, `updated_at`                                                          |
| `kv`          | `id`        | `&name`, `clock`, `created_at`, `updated_at`                                                                                                                            |
| `attachments` | `id`        | `type`, `name`, `clock`, `created_at`, `updated_at`                                                                                                                     |
| `file_meta`   | `hash`      | `[kind+deleted]`, `mime_type`, `clock`, `created_at`, `updated_at`                                                                                                      |
| `file_blobs`  | `hash`      | (none)                                                                                                                                                                  |
| `posts`       | `id`        | `title`, `postType`, `deleted`, `created_at`, `updated_at`                                                                                                              |

> ℹ️ `file_blobs` stores raw Binary Large Objects; the rest are JSON-like metadata rows.

---

## Usage

```ts
import { db } from '~/app/db';

await db.open();
const allThreads = await db.threads.toArray();
```

-   Prefer the higher-level modules (`threads.ts`, `messages.ts`, etc.) for business logic and hook coverage.
-   Only change the schema via `this.version(<next>).stores({...})` and bump the version number; ensure you migrate existing data when necessary.

---

## Versioning tips

-   Keep version pegged at `5` until you add columns or indexes. When you bump, implement Dexie upgrade paths to migrate data.
-   Since older migrations were consolidated, new changes should avoid breaking existing user stores—plan upgrades carefully.
</file>

<file path="database/dbTry.md">
# dbTry

Thin error-handling wrapper around Dexie calls that surfaces quota issues and standardizes error metadata.

---

## What does it do?

-   Executes a provided function and traps IndexedDB quota exceptions.
-   Emits toast-friendly `ERR_DB_QUOTA_EXCEEDED` errors with guidance text.
-   Tags all other failures as `ERR_DB_READ_FAILED`/`ERR_DB_WRITE_FAILED` and forwards them to `reportError`.
-   Optionally rethrows after logging when `opts.rethrow` is true.

---

## API

```ts
dbTry<T>(fn: () => Promise<T> | T, tags: DbTryTags, opts?: { rethrow?: boolean }): Promise<T | undefined>
```

| Parameter      | Type                | Notes                                                          |
| -------------- | ------------------- | -------------------------------------------------------------- | ------------------------------------------- |
| `fn`           | `() => Promise<T>  | T`                                                             | Database action to execute.                 |
| `tags`         | `{ op: 'read'       | 'write'; entity?: string; ... }`                               | Required tags used for logging/diagnostics. |
| `opts.rethrow` | `boolean`           | When `true`, the original exception is rethrown after logging. |

Returns the function result (possibly `undefined` when suppressed) or `undefined` if an error was swallowed.

---

## Constants

-   `DB_QUOTA_GUIDANCE` — UI-friendly message instructing users to clear space when storage quota is exceeded.

---

## When to use

-   Wrap all Dexie reads/writes that could hit quota or data corruption.
-   Pair with `{ rethrow: true }` when the caller cannot recover (e.g., creation flows) so upstream can surface precise failures.

---

## Error tagging

-   Adds `domain: 'db'` and `rw: tags.op` so hooks/devtools can filter DB-related errors.
-   Quota failures set `retryable: false`; other failures remain retryable to allow user retriggering.
</file>

<file path="database/documents.md">
# documents

Document storage built on the shared `posts` table (`postType: 'doc'`) with TipTap JSON payloads and hook integration.

---

## What does it do?

-   Serializes rich-text documents into the `posts` table without introducing a new Dexie store.
-   Surfaces CRUD helpers that parse/merge content and titles through hook filters.
-   Provides soft- and hard-delete paths, plus a small `ensureDbOpen` helper used by feature modules.

---

## Data structures

| Row              | Field              | Meaning                                                  |
| ---------------- | ------------------ | -------------------------------------------------------- |
| `DocumentRow`    | `content: string`  | Raw JSON string persisted in Dexie.                      |
|                  | `postType`         | Always `'doc'`; used to discriminate from prompts/posts. |
|                  | `deleted: boolean` | Soft delete flag toggled via `softDeleteDocument`.       |
| `DocumentRecord` | `content: any`     | Parsed TipTap JSON returned to callers.                  |

---

## API surface

| Function                    | Description                                                                                |
| --------------------------- | ------------------------------------------------------------------------------------------ |
| `createDocument(input?)`    | Validates title/content, runs hooks, writes a new row, returns parsed record.              |
| `getDocument(id)`           | Loads a single document, applies output filters, returns parsed record.                    |
| `listDocuments(limit?)`     | Fetches non-deleted docs, sorts by `updated_at` desc, slices to limit, applies filters.    |
| `updateDocument(id, patch)` | Re-resolves titles/content, fires before/after hooks, persists and returns updated record. |
| `softDeleteDocument(id)`    | Marks `deleted: true` and bumps `updated_at`.                                              |
| `hardDeleteDocument(id)`    | Removes the row entirely.                                                                  |
| `ensureDbOpen()`            | Opens Dexie when closed (no-op if already open).                                           |

---

## Hooks

-   `db.documents.title:filter` — customize title normalization per phase.
-   `db.documents.<stage>:filter:input/output` — mutate entities before persistence or after reads.
-   `db.documents.delete:action:*` — observe both soft and hard deletes.

---

## Implementation notes

1. **Title normalization** — `normalizeTitle` trims empty strings to `'Untitled'`, then passes through hook filters.
2. **Content safety** — `parseContent` guards against malformed JSON, returning an empty doc structure on error.
3. **Update payloads** — Build `DbUpdatePayload` objects so hooks receive full `existing`, `updated`, and `patch` context.

---

## Usage tips

-   Use `listDocuments()` for sidebar listings; it already caps results and filters deleted rows.
-   Call `updateDocument` with partial patches—passing `content` as TipTap JSON automatically serializes to string.
-   Write hook extensions to auto-tag docs or enforce title casing.
</file>

<file path="database/files-select.md">
# files-select

Read-only helpers for paging `file_meta` rows when browsing uploads or the recycle bin.

---

## What does it do?

-   Exposes lightweight list queries scoped to image-like files.
-   Applies simple paging (`offset`, `limit`) over an `updated_at` index.
-   Provides a rename helper that bumps `updated_at` for sorting freshness.

---

## API surface

| Function                     | Signature                                         | Description                                         |
| ---------------------------- | ------------------------------------------------- | --------------------------------------------------- |
| `listImageMetasPaged`        | `(offset = 0, limit = 50) => Promise<FileMeta[]>` | Returns newest-first non-deleted image meta rows.   |
| `listDeletedImageMetasPaged` | `(offset = 0, limit = 50) => Promise<FileMeta[]>` | Returns soft-deleted image meta rows for bin views. |
| `updateFileName`             | `(hash: string, name: string) => Promise<void>`   | Renames a file (if found) and updates `updated_at`. |

---

## Filtering rules

-   Images are detected via `kind === 'image'` or `mime_type` prefix `image/`.
-   Deleted and non-deleted lists are separated to simplify UI logic.

---

## Usage tips

-   Combine with `createOrRefFile` / `softDeleteFile` from `files.ts` for lifecycle actions.
-   Use `offset`/`limit` for infinite scroll; Dexie performs the filtering client-side so keep limits small (<= 100) for snappy results.
</file>

<file path="database/files-util.md">
# files-util

Utility helpers for enforcing message file limits and serializing file hash arrays.

---

## What does it do?

-   Resolves `MAX_FILES_PER_MESSAGE` from `NUXT_PUBLIC_MAX_MESSAGE_FILES` (bounded 1–12).
-   Provides JSON parse/serialize helpers for the `file_hashes` message column.
-   Dedupes hashes and preserves insertion order when serializing.

---

## Constants

| Constant                  | Description                                            |
| ------------------------- | ------------------------------------------------------ |
| `MAX_FILES_PER_MESSAGE`   | Runtime cap on attachments per message (default 6).    |
| `MAX_MESSAGE_FILE_HASHES` | Deprecated alias retained for backwards compatibility. |

---

## API surface

| Function              | Signature                      | Description                                      |
| --------------------- | ------------------------------ | ------------------------------------------------ | ---------------------------------------------------------------------- |
| `parseFileHashes`     | `(serialized?: string          | null) => string[]`                               | Safely parses JSON array, strips invalid entries, enforces max length. |
| `serializeFileHashes` | `(hashes: string[]) => string` | Dedupes, bounds to max, and returns JSON string. |

---

## Usage tips

-   Always run message updates through these helpers before writing to Dexie to avoid oversized rows.
-   When increasing the limit via env, remember it caps at 12 to avoid UI abuse.
</file>

<file path="database/files.md">
# files

File storage layer that deduplicates blobs by hash, keeps metadata in Dexie, and exposes hook-friendly lifecycle helpers.

---

## What does it do?

-   Generates content hashes (`computeFileHash`) to reuse existing uploads.
-   Stores binary blobs in `file_blobs` and metadata in `file_meta` with ref counting.
-   Emits numerous hooks so extensions can validate, annotate, or track file usage.
-   Supports soft delete, restore, hard delete, and reference counting operations.

---

## Data structures

| Field            | Description                                                     |
| ---------------- | --------------------------------------------------------------- |
| `hash`           | MD5 hash used as primary key for both metadata and blob tables. |
| `name`           | Display name supplied by uploader.                              |
| `mime_type`      | MIME type (defaults to `application/octet-stream`).             |
| `kind`           | `'image'` or `'pdf'` (auto-detected).                           |
| `size_bytes`     | Blob size in bytes; enforced against 20 MB cap.                 |
| `width`/`height` | Optional image dimensions extracted via object URL.             |
| `ref_count`      | Number of referencing entities (messages).                      |
| `deleted`        | Soft delete flag set by `softDeleteFile`/`softDeleteMany`.      |

---

## API surface

| Function                           | Description                                                                             |
| ---------------------------------- | --------------------------------------------------------------------------------------- |
| `createOrRefFile(file, name)`      | Dedupes by hash, increments ref count, stores blob + metadata, runs before/after hooks. |
| `getFileMeta(hash)`                | Loads metadata and applies output filters.                                              |
| `getFileBlob(hash)`                | Returns the stored `Blob` (or `undefined`).                                             |
| `softDeleteFile(hash)`             | Marks a single file as deleted.                                                         |
| `softDeleteMany(hashes)`           | Batch soft delete inside a transaction.                                                 |
| `restoreMany(hashes)`              | Clears `deleted` flag for multiple files.                                               |
| `hardDeleteMany(hashes)`           | Removes metadata and blob entries entirely.                                             |
| `derefFile(hash)`                  | Decrements ref count (never below zero).                                                |
| `changeRefCount(hash, delta)`      | Internal helper exported for testing/hooks (invokes `db.files.refchange`).              |
| `fileDeleteError(message, cause?)` | Convenience error factory with tags for delete flows.                                   |

---

## Hooks

-   `db.files.create:filter:input` and `db.files.create:action:(before|after)`
-   `db.files.get:filter:output`
-   `db.files.refchange:action:after`
-   `db.files.delete:action:(soft|hard):(before|after)`
-   `db.files.restore:action:(before|after)`

These make it easy to inject custom validation, analytics, or audit trails around file lifecycle events.

---

## Implementation notes

1. **Perf markers** — In dev mode the module records `performance.measure` spans for create/ref operations.
2. **Image metadata** — Uses an object URL to resolve dimensions without full decode; errors are swallowed gracefully.
3. **Transactions** — Critical write operations run inside Dexie transactions covering both metadata and blob tables to keep state consistent.

---

## Usage tips

-   Always call `derefFile` when removing file references from messages to keep ref counts accurate.
-   Hook into `db.files.create:filter:input` to enforce custom size caps or rename files.
-   When batch deleting, prefer `softDeleteMany` first; run `hardDeleteMany` during periodic cleanups to reclaim storage.
</file>

<file path="database/index.md">
# index

Barrel exports for the database layer, re-exporting the Dexie client, CRUD helpers, and common type aliases.

---

## What does it do?

-   Centralizes imports so callers can `import { create, queries, del } from '~/app/db'`.
-   Groups helpers into semantic objects: `create`, `upsert`, `queries`, `del`, `tx`, and `kv`.
-   Re-exports schema types (`Thread`, `Project`, `Document`, etc.) for consumer convenience.

---

## Aggregated namespaces

| Namespace  | Contents                                                                 |
| ---------- | ------------------------------------------------------------------------ |
| `create`   | `thread`, `message`, `kv`, `attachment`, `project`, `post`, `document`.  |
| `upsert`   | Sibling upsert helpers; note `document` maps to `updateDocument`.        |
| `queries`  | Read/query helpers spanning threads, messages, KV, posts, documents.     |
| `del.soft` | Soft-delete functions per entity.                                        |
| `del.hard` | Hard-delete counterparts (including KV helpers).                         |
| `tx`       | Transactional utilities (`appendMessage`, `moveMessage`, `copyMessage`). |
| `kv`       | Shorthand `get`, `set`, `delete` wrappers around name-based KV helpers.  |

---

## Usage example

```ts
import { create, queries, del } from '~/app/db';

const thread = await create.thread({ title: 'New chat' });
const messages = await queries.messagesByThread(thread.id);
await del.soft.thread(thread.id);
```

-   Prefer this barrel when wiring feature modules to keep import paths short and consistent.
</file>

<file path="database/kv.md">
# kv

Key-value helpers for storing small preference or credential blobs in the Dexie `kv` table.

---

## What does it do?

-   Validates KV payloads with `KvCreateSchema`/`KvSchema`.
-   Wraps reads/writes in `dbTry` with detailed error tagging.
-   Integrates with the hook system for before/after actions and output filters.
-   Provides name-based helpers for common flows like OpenRouter token storage.

---

## Data shape

| Field        | Type     | Notes                                                        |
| ------------ | -------- | ------------------------------------------------------------ | ----------------------------------------- |
| `id`         | `string` | Primary key. Name-based helpers use `kv:${name}` convention. |
| `name`       | `string` | Logical key.                                                 |
| `value`      | `string  | null`                                                        | Serialized payload (often JSON or token). |
| `clock`      | `number` | Monotonic counter incremented on `setKvByName`.              |
| `created_at` | `number` | Unix seconds.                                                |
| `updated_at` | `number` | Unix seconds.                                                |

---

## API surface

| Function                   | Description                                                                      |
| -------------------------- | -------------------------------------------------------------------------------- |
| `createKv(input)`          | Inserts a new KV row after filtering and validation.                             |
| `upsertKv(value)`          | Full-row upsert with before/after hooks.                                         |
| `hardDeleteKv(id)`         | Removes a row by primary key.                                                    |
| `getKv(id)`                | Fetches by primary key and applies output filters.                               |
| `getKvByName(name)`        | Finds first row matching `name`.                                                 |
| `setKvByName(name, value)` | Creates or updates a row using `kv:${name}` ids, increments `clock`, runs hooks. |
| `hardDeleteKvByName(name)` | Deletes by `name` with before/after hooks.                                       |

---

## Hooks

-   `db.kv.create:filter:input` / `db.kv.create:action:(before|after)`
-   `db.kv.upsert:filter:input`
-   `db.kv.get:filter:output` and `db.kv.getByName:filter:output`
-   `db.kv.upsertByName:filter:input` / `:action:after`
-   `db.kv.delete(:action:hard:* )` + `db.kv.deleteByName:action:hard:*`

---

## Usage tips

-   Store encrypted or user-provided tokens by name; `setKvByName` will generate IDs automatically.
-   Use hooks to redact values before logging or to enforce naming conventions.
-   Keep payloads tiny (<10 KB) to avoid IndexedDB quota pressure.
</file>

<file path="database/message-files.md">
# message-files

Helpers for attaching/detaching files to chat messages while maintaining ref counts and serialized hash lists.

---

## What does it do?

-   Resolves `file_hashes` arrays from messages and returns their metadata.
-   Adds files to messages either by Blob (new upload) or by existing hash.
-   Ensures Dexie transactions update messages and file tables atomically.
-   Dereferences files when hashes are removed.

---

## Types

| Type          | Description                                                                      |
| ------------- | -------------------------------------------------------------------------------- |
| `AddableFile` | Discriminated union `{ type: 'blob'; blob; name? }` or `{ type: 'hash'; hash }`. |

---

## API surface

| Function                                 | Description                                                                        |
| ---------------------------------------- | ---------------------------------------------------------------------------------- |
| `filesForMessage(messageId)`             | Loads `FileMeta[]` for the hashes stored on a message.                             |
| `addFilesToMessage(messageId, files)`    | Uploads or references files, merges hashes, applies hooks, writes serialized list. |
| `removeFileFromMessage(messageId, hash)` | Removes a hash, saves new list, decrements ref count.                              |

---

## Implementation notes

1. **Transactions** — All mutating functions run inside Dexie transactions touching `messages`, `file_meta`, and `file_blobs` to ensure consistency.
2. **Hooks** — `db.messages.files.validate:filter:hashes` lets extensions prune or reorder hash lists before persistence.
3. **Serialization** — Uses `serializeFileHashes` so limits/deduping stay consistent with message creation flows.

---

## Usage tips

-   Pass Blobs when users drop files; the helper will call `createOrRefFile` and reuse existing hashes.
-   For quick attach of already-uploaded media, pass `{ type: 'hash', hash }` to avoid re-computation.
-   Always call `removeFileFromMessage` (not manual mutation) so ref counts stay accurate.
</file>

<file path="database/messages.md">
# messages

Thread message CRUD utilities with hook integration, sparse indexing, and attachment support.

---

## What does it do?

-   Creates, upserts, and queries messages with schema validation.
-   Manages sparse indexes (`index` field) to support fast insertion and ordered retrieval.
-   Exposes transactional helpers for append/move/copy/insert operations that also update thread timestamps.
-   Provides normalization tools like `normalizeThreadIndexes`.

---

## Key data fields

| Field         | Description                                                     |
| ------------- | --------------------------------------------------------------- |
| `id`          | Message UUID (auto-generated for create flows).                 |
| `thread_id`   | Foreign key to the parent thread.                               |
| `role`        | `'user' \| 'assistant' \| 'system'` (validated via schema).     |
| `data`        | Arbitrary payload (serialized JSON) used by renderers.          |
| `index`       | Sparse ordering integer (default increments by 1000).           |
| `file_hashes` | Serialized JSON array of file hashes; use `files-util` helpers. |
| `clock`       | Revision counter.                                               |

---

## API surface

| Function                                          | Description                                                                                 |
| ------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| `createMessage(input)`                            | Validates payload (including array → string conversion for `file_hashes`) and writes a row. |
| `upsertMessage(value)`                            | Validates and replaces a row.                                                               |
| `messagesByThread(threadId)`                      | Fetches ordered messages, applying output filters.                                          |
| `getMessage(id)` / `messageByStream(streamId)`    | Targeted lookups with output filters.                                                       |
| `softDeleteMessage(id)` / `hardDeleteMessage(id)` | Delete flows with before/after hook actions.                                                |
| `appendMessage(input)`                            | Transactionally inserts at end of thread and updates timestamps.                            |
| `moveMessage(messageId, toThreadId)`              | Moves a message to another thread and reindexes.                                            |
| `copyMessage(messageId, toThreadId)`              | Duplicates a message into another thread with new ID.                                       |
| `insertMessageAfter(afterId, input)`              | Inserts between two messages, normalizing indexes as needed.                                |
| `normalizeThreadIndexes(threadId, start?, step?)` | Reassigns sequential indexes (default 1000 spacing).                                        |

---

## Hooks

-   `db.messages.create:filter:input` / `:action:before/after`
-   `db.messages.upsert`, `db.messages.byThread:filter:output`, `db.messages.get:filter:output`
-   Action hooks for delete, append, move, copy, insert, and normalize operations.

These hooks allow feature modules to enrich messages (e.g., auto-tagging, analytics) and react to lifecycle changes.

---

## Sparse indexing strategy

-   New messages default to increments of `1000`, leaving gaps for future inserts.
-   `insertMessageAfter` uses midpoint spacing; when no gap remains it calls `normalizeThreadIndexes` to re-sequence.
-   Dexie compound index `[thread_id+index]` keeps ordering queries fast.

---

## Usage tips

-   Always feed `file_hashes` as string arrays; the module serializes and bounds automatically.
-   Use `appendMessage` rather than manual `createMessage` when you need thread timestamps updated.
-   Call `normalizeThreadIndexes` after bulk edits to keep indexes tidy.
</file>

<file path="database/posts.md">
# posts

Generic post storage built on the `posts` Dexie table; used for lightweight CMS data like release notes or docs.

---

## What does it do?

-   Validates posts with `PostCreateSchema`/`PostSchema` before persistence.
-   Normalizes optional `meta` payloads to JSON strings for compact storage.
-   Exposes CRUD helpers plus simple search utilities.
-   Integrates with hook filters/actions at every lifecycle step.

---

## Data shape

| Field      | Description                                                      |
| ---------- | ---------------------------------------------------------------- |
| `id`       | Primary key (auto-generated if omitted).                         |
| `title`    | Required, trimmed string.                                        |
| `content`  | Arbitrary string content (often Markdown).                       |
| `postType` | Logical discriminator (e.g., `'markdown'`, `'doc'`, `'prompt'`). |
| `meta`     | JSON string or structured object/array; normalized upstream.     |
| `deleted`  | Soft delete flag.                                                |

---

## API surface

| Function             | Description                                        |
| -------------------- | -------------------------------------------------- |
| `createPost(input)`  | Filters, normalizes meta/title, writes a new post. |
| `upsertPost(value)`  | Replaces an existing post with validation.         |
| `getPost(id)`        | Fetches a post by id with output filters.          |
| `allPosts()`         | Returns all posts (unfiltered); hook can prune.    |
| `searchPosts(term)`  | Case-insensitive title search using Dexie filter.  |
| `softDeletePost(id)` | Marks `deleted: true` and updates timestamp.       |
| `hardDeletePost(id)` | Removes the row entirely.                          |

---

## Hooks

-   `db.posts.create:filter:input` / `:action:(before|after)`
-   `db.posts.upsert:filter:input`
-   `db.posts.get/all/search:filter:output`
-   `db.posts.delete:action:(soft|hard):(before|after)`

---

## Usage tips

-   Use `postType` to segment content (e.g., `'doc'` and `'prompt'` reuse this table via other modules).
-   Normalize heavily structured `meta` objects before calling `createPost`; the helper will serialize for you but invalid JSON becomes `undefined`.
-   Hooks are the right place to inject slug generation or analytics side effects.
</file>

<file path="database/projects.md">
# projects

CRUD helpers for project metadata stored in the `projects` Dexie table.

---

## What does it do?

-   Validates incoming project objects with `ProjectSchema`.
-   Wraps persistence in `dbTry` for consistent error handling.
-   Emits hook actions/filters for create, upsert, delete, and read flows.

---

## Data shape

| Field                       | Description                                        |
| --------------------------- | -------------------------------------------------- |
| `id`                        | Project ID (string).                               |
| `name`                      | Display name.                                      |
| `description`               | Optional string (nullable).                        |
| `data`                      | Arbitrary JSON payload scoped to project features. |
| `clock`                     | Revision counter.                                  |
| `deleted`                   | Soft delete flag updated via `softDeleteProject`.  |
| `created_at` / `updated_at` | Unix seconds timestamps.                           |

---

## API surface

| Function                | Description                                       |
| ----------------------- | ------------------------------------------------- |
| `createProject(input)`  | Filters + validates + writes a new project.       |
| `upsertProject(value)`  | Filters + validates + replaces the row.           |
| `softDeleteProject(id)` | Marks project deleted within a Dexie transaction. |
| `hardDeleteProject(id)` | Removes the project entirely.                     |
| `getProject(id)`        | Reads a project by id and applies output filters. |

---

## Hooks

-   `db.projects.create:filter:input` / `:action:(before|after)`
-   `db.projects.upsert:filter:input`
-   `db.projects.delete:action:(soft|hard):(before|after)`
-   `db.projects.get:filter:output`

---

## Usage tips

-   Store structured per-project state inside `data`; use hooks to enforce schema or migrate old versions.
-   Soft delete keeps history for undo flows—run hard deletes during cleanup tasks only.
</file>

<file path="database/prompts.md">
# prompts

Prompt library built on the shared `posts` table (`postType: 'prompt'`) with TipTap JSON payloads.

---

## What does it do?

-   Adds CRUD helpers for saved prompt templates.
-   Normalizes titles (allowing empty strings when updating) and serializes content.
-   Reuses hook payload conventions (`DbCreatePayload`, `DbUpdatePayload`, `DbDeletePayload`).
-   Supports soft/hard delete flows plus a simple `ensureDbOpen` helper.

---

## Data structures

| Row            | Field             | Meaning                          |
| -------------- | ----------------- | -------------------------------- |
| `PromptRow`    | `content: string` | Raw JSON string stored in Dexie. |
|                | `postType`        | Always `'prompt'`.               |
|                | `deleted`         | Soft delete flag.                |
| `PromptRecord` | `content: any`    | Parsed JSON returned to callers. |

---

## API surface

| Function                  | Description                                                                               |
| ------------------------- | ----------------------------------------------------------------------------------------- |
| `createPrompt(input?)`    | Generates an id, normalizes title/content, runs hooks, writes row, returns parsed record. |
| `getPrompt(id)`           | Loads a single prompt with output filters.                                                |
| `listPrompts(limit?)`     | Lists non-deleted prompts ordered by `updated_at` desc, capped to limit.                  |
| `updatePrompt(id, patch)` | Applies patches through hooks, persists, and returns updated record.                      |
| `softDeletePrompt(id)`    | Sets `deleted: true` and bumps `updated_at`.                                              |
| `hardDeletePrompt(id)`    | Deletes row from the posts table.                                                         |
| `ensureDbOpen()`          | Opens Dexie if closed.                                                                    |

---

## Hooks

-   `db.prompts.create:filter:input` / `:action:(before|after)`
-   `db.prompts.update:filter:input` (receives full payload context)
-   `db.prompts.list:filter:output`
-   `db.prompts.delete:action:(soft|hard):(before|after)`

---

## Usage tips

-   Leverage `normalizeTitle`’s `allowEmpty` option to let users save blank-titled prompts while still providing fallbacks.
-   Store structured prompt metadata inside hook filters instead of extending Dexie schema—`PromptEntity` supports custom fields.
-   Call `ensureDbOpen` before large migrations or offline flows to avoid lazy-open delays.
</file>

<file path="database/schema.md">
# schema

Central Zod schemas and generated TypeScript types for all Dexie tables.

---

## What does it do?

-   Defines runtime validation for every entity (`Project`, `Thread`, `Message`, etc.).
-   Supplies create-specific schemas that auto-populate IDs/timestamps via transforms.
-   Exports inferred TypeScript types to keep DB modules strongly typed.

---

## Schemas overview

| Schema                                        | Highlights                                                                 |
| --------------------------------------------- | -------------------------------------------------------------------------- |
| `ProjectSchema`                               | Basic metadata with optional description/data and `clock` counter.         |
| `ThreadSchema`                                | Supports branching fields (`parent_thread_id`, `anchor_*`, `branch_mode`). |
| `ThreadCreateSchema`                          | Optional fields with defaults for `id`, `clock`, timestamps.               |
| `MessageSchema`                               | Includes `file_hashes` string column, `stream_id`, sparse `index`.         |
| `MessageCreateSchema`                         | Auto-generates `id`, `clock`, timestamps; leaves `index` optional.         |
| `PostSchema` / `PostCreateSchema`             | Covers generic posts plus normalized title/meta logic.                     |
| `KvSchema` / `KvCreateSchema`                 | Simple key-value store with optional `value`.                              |
| `AttachmentSchema` / `AttachmentCreateSchema` | Enforces URL+type/name, optional `deleted`.                                |
| `FileMetaSchema` / `FileMetaCreateSchema`     | Metadata for blobs, defaulting `ref_count` and `clock`.                    |

---

## Helpers

-   `newId()` — Returns `crypto.randomUUID()` when available, fallback to timestamp string.
-   `nowSec()` — Unix timestamp (seconds) used as default for timestamps.

---

## Usage tips

-   Always run incoming data through `parseOrThrow(schema, value)` to catch invalid shapes before writing to Dexie.
-   When extending schema fields, update both the base schema and any related create schema so defaults stay aligned.
-   Compose new derived types via `z.infer<typeof Schema>` to keep type safety consistent across modules.
</file>

<file path="database/threads.md">
# threads

Thread CRUD and query helpers with hook integration, branching support, and system prompt utilities.

---

## What does it do?

-   Creates and upserts thread rows with full schema validation.
-   Provides soft/hard delete flows that coordinate with message cleanup.
-   Offers search helpers and child-thread queries for branching UIs.
-   Implements a simple fork helper for cloning threads (optionally copying messages).
-   Stores per-thread system prompt references.

---

## Key fields

| Field                                | Description                                             |
| ------------------------------------ | ------------------------------------------------------- |
| `parent_thread_id`                   | Links branches back to their source thread.             |
| `anchor_message_id` / `anchor_index` | Track branching anchor points.                          |
| `branch_mode`                        | `'reference'` or `'copy'`; controls fork behavior.      |
| `forked`                             | Boolean flag marking branched threads.                  |
| `system_prompt_id`                   | Optional prompt reference stored with helper functions. |

---

## API surface

| Function                                       | Description                                                  |
| ---------------------------------------------- | ------------------------------------------------------------ |
| `createThread(input)`                          | Filters input, applies defaults, validates, persists thread. |
| `upsertThread(value)`                          | Validates and writes thread updates.                         |
| `threadsByProject(projectId)`                  | Returns threads scoped to a project (hook-filtered).         |
| `searchThreadsByTitle(term)`                   | Case-insensitive title filter using Dexie.                   |
| `getThread(id)`                                | Fetches a thread by id with output filters.                  |
| `childThreads(parentThreadId)`                 | Lists direct branch children.                                |
| `softDeleteThread(id)`                         | Marks deleted flag and updates timestamp inside transaction. |
| `hardDeleteThread(id)`                         | Deletes thread and cascades delete to messages.              |
| `forkThread(sourceId, overrides?, options?)`   | Clones thread metadata, optionally copies messages.          |
| `updateThreadSystemPrompt(threadId, promptId)` | Stores/clears prompt reference.                              |
| `getThreadSystemPrompt(threadId)`              | Reads stored prompt id (hook-filtered).                      |

---

## Hooks

-   `db.threads.create|upsert:filter:input` + before/after actions.
-   `db.threads.delete:action:(soft|hard)`
-   `db.threads.fork:action:(before|after)`
-   `db.threads.updateSystemPrompt:action:(before|after)`
-   Output filters for query helpers (`byProject`, `searchByTitle`, `get`, `children`, `getSystemPrompt`).

---

## Implementation notes

1. **Transactions** — Delete/fork flows run inside Dexie transactions touching both `threads` and `messages` to stay consistent.
2. **Forking** — New thread IDs generated via `newId()`. When copying messages the helper duplicates rows and optionally updates thread metadata timestamps.
3. **Search** — Title search uses Dexie filter; pair with Orama-based composables for better ranking when needed.

---

## Usage tips

-   Use `forkThread` (from this module) for quick clones, or the richer branching utilities in `app/db/branching.ts` when you need anchor-aware forks.
-   Always go through `updateThreadSystemPrompt` to change prompts so hooks and timestamps stay aligned.
-   When cleaning up, call `softDeleteThread` first so UI consumers can offer undo before executing destructive `hardDeleteThread`.
</file>

<file path="database/util.md">
# util

Shared helpers for parsing with Zod, generating IDs, and producing Unix timestamps.

---

## What does it do?

-   Wraps `schema.safeParse` to throw readable errors when validation fails (`parseOrThrow`).
-   Exposes `nowSec()` for consistent second-based timestamps across modules.
-   Provides `newId()` that prefers `crypto.randomUUID()` with a safe fallback.

---

## API surface

| Function       | Signature                       | Description                                                           |
| -------------- | ------------------------------- | --------------------------------------------------------------------- |
| `parseOrThrow` | `(schema, data) => ZodInfer<T>` | Validates data against a Zod schema; throws on failure.               |
| `nowSec`       | `() => number`                  | Returns `Math.floor(Date.now() / 1000)`.                              |
| `newId`        | `() => string`                  | Generates a UUID v4 or timestamp-based ID when crypto is unavailable. |

---

## Usage tips

-   Always use `parseOrThrow` before writing to Dexie to catch client-side shape regressions early.
-   `nowSec()` keeps timestamps compact (seconds vs milliseconds); align any server sync logic accordingly.
-   The timestamp fallback in `newId()` keeps IDs unique even in legacy browsers—no extra seeding required.
</file>

<file path="hooks/hook-catalog.md">
# hook-catalog

Authoritative catalog of available hooks with their argument shapes and return values. This is derived from the codebase (hook keys, payload types, and call sites) so developers don’t have to console.log.

---

## How to read this

-   Kind: action vs filter. Actions return void; filters must return the next value in the chain.
-   Args: tuple passed to your handler. Use `typedOn(hooks).on(key, fn)` for editor inference.
-   Returns: concrete return type for filters. Veto-capable filters allow `false` (or `''`) to cancel/clear.

See also: `hooks.md` for engine API, `hook-keys.md` and `hook-types.md` for detailed payload types.

---

## Chat and AI

| Key                               | Kind   | Args (tuple)                                     | Returns                            |
| --------------------------------- | ------ | ------------------------------------------------ | ---------------------------------- |
| `ui.chat.message:filter:outgoing` | filter | `[text: string]`                                 | `string \| false` (veto to cancel) |
| `ui.chat.message:filter:incoming` | filter | `[text: string, threadId?: string]`              | `string`                           |
| `ai.chat.model:filter:select`     | filter | `[modelId: string]`                              | `string` (new model id)            |
| `ai.chat.messages:filter:input`   | filter | `[messages: any[]]`                              | `any[]`                            |
| `ai.chat.send:action:before`      | action | `[payload: AiSendBeforePayload]`                 | —                                  |
| `ai.chat.send:action:after`       | action | `[payload: AiSendAfterPayload]`                  | —                                  |
| `ai.chat.stream:action:delta`     | action | `[chunk: string, ctx: AiStreamDeltaPayload]`     | —                                  |
| `ai.chat.stream:action:reasoning` | action | `[chunk: string, ctx: AiStreamReasoningPayload]` | —                                  |
| `ai.chat.stream:action:complete`  | action | `[ctx: AiStreamCompletePayload]`                 | —                                  |
| `ai.chat.stream:action:error`     | action | `[ctx: AiStreamErrorPayload]`                    | —                                  |
| `ai.chat.retry:action:before`     | action | `[payload: AiRetryBeforePayload]`                | —                                  |
| `ai.chat.retry:action:after`      | action | `[payload: AiRetryAfterPayload]`                 | —                                  |

---

## Pane lifecycle

| Key                             | Kind   | Args (tuple)                                                 | Returns                 |
| ------------------------------- | ------ | ------------------------------------------------------------ | ----------------------- |
| `ui.pane.active:action`         | action | `[payload: UiPaneActivePayload]`                             | —                       |
| `ui.pane.blur:action`           | action | `[payload: UiPaneBlurPayload]`                               | —                       |
| `ui.pane.switch:action`         | action | `[payload: UiPaneSwitchPayload]`                             | —                       |
| `ui.pane.thread:filter:select`  | filter | `[requestedId: string, pane: PaneState, previousId: string]` | `string \| '' \| false` |
| `ui.pane.thread:action:changed` | action | `[payload: UiPaneThreadChangedPayload]`                      | —                       |
| `ui.pane.doc:filter:select`     | filter | `[requestedId: string, pane: PaneState, previousId: string]` | `string \| '' \| false` |
| `ui.pane.doc:action:changed`    | action | `[payload: UiPaneDocChangedPayload]`                         | —                       |
| `ui.pane.doc:action:saved`      | action | `[payload: UiPaneDocChangedPayload]`                         | —                       |
| `ui.pane.msg:action:sent`       | action | `[payload: UiPaneMsgSentPayload]`                            | —                       |
| `ui.pane.msg:action:received`   | action | `[payload: UiPaneMsgReceivedPayload]`                        | —                       |

Notes

-   The `select` filters support veto (`false`) and clear (`''`). See `useMultiPane.ts` and `usePaneDocuments.ts`.

---

## Files and uploads

| Key                         | Kind   | Args (tuple)                                  | Returns                            |
| --------------------------- | ------ | --------------------------------------------- | ---------------------------------- |
| `files.attach:filter:input` | filter | `[payload: FilesAttachInputPayload \| false]` | `FilesAttachInputPayload \| false` |

Notes

-   Returning `false` cancels the attachment. See `components/chat/file-upload-utils.ts`.

---

## Branching

| Key                              | Kind   | Args (tuple)                                                                                                       | Returns             |
| -------------------------------- | ------ | ------------------------------------------------------------------------------------------------------------------ | ------------------- |
| `branch.fork:action:before`      | action | `[payload: BranchForkBeforePayload]`                                                                               | —                   |
| `branch.fork:action:after`       | action | `[payload: ThreadEntity]`                                                                                          | —                   |
| `branch.retry:filter:options`    | filter | `[opts: { assistantMessageId: string; mode?: BranchMode; titleOverride?: string }]`                                | same shape as input |
| `branch.retry:action:before`     | action | `[payload: { assistantMessageId: string; precedingUserId: string; mode: BranchMode }]`                             | —                   |
| `branch.retry:action:after`      | action | `[payload: { assistantMessageId: string; precedingUserId: string; newThreadId: string; mode: BranchMode }]`        | —                   |
| `branch.context:filter:messages` | filter | `[messages: MessageEntity[], threadId: string, mode: BranchMode]`                                                  | `MessageEntity[]`   |
| `branch.context:action:after`    | action | `[payload: { threadId: string; mode: BranchMode; ancestorCount: number; localCount: number; finalCount: number }]` | —                   |

Notes

-   See `app/db/branching.ts` and `hook-types.ts` for the `Branch*` payloads.

---

## Database families (patterns)

Families: `messages | documents | files | threads | projects | posts | prompts | attachments | kv`

Actions

-   Before/after hooks per operation: `db.<family>.<op>:action:before|after`
-   Delete also emits `soft|hard` phases: `db.<family>.delete:action:soft|hard:before|after`

Filters

-   Input validators/transformers: `db.<family>.<op>:filter:input` — returns the (possibly transformed) input payload
-   Output mappers: `db.<family>.<op>:filter:output` — returns the (possibly transformed) result value

Common ops per family (varies by module; see each `app/db/*.ts`):

-   `create`, `upsert`, `update`, `delete`, `get`, `byThread`/`byProject`/`children`, `search`, specialized ops like `append`, `insertAfter`, `normalize`, `fork`, `updateSystemPrompt`.

Special cases

-   `db.files.refchange:action:after`
-   `db.kv.upsertByName:action:after`
-   `db.kv.deleteByName:action:hard:before|after`

Returns quick-reference

-   Action hooks: `void \| Promise<void>`
-   Filter input hooks: return the validated/transformed input shape
-   Filter output hooks: return the transformed entity/array being output

---

## App and errors (observed in code)

| Key                                       | Kind   | Args (tuple)                              | Returns               |
| ----------------------------------------- | ------ | ----------------------------------------- | --------------------- | --- |
| `app.init:action:after`                   | action | `[nuxtApp: any]`                          | —                     |
| `error:raised`                            | action | `[error: unknown]`                        | —                     |
| `error:<domain>`                          | action | `[error: unknown]`                        | —                     |
| `ai.chat.error:action`                    | action | `[payload: { error: unknown }]`           | —                     |
| `chat.systemPrompt.select:action:after`   | action | `[payload: { id: string; content: any }]` | —                     |
| `chat.systemPrompt.default:action:update` | action | `[id: string]`                            | —                     |
| `ui.sidebar.select:action:before`         | action | `[payload: { kind: 'chat'                 | 'doc'; id: string }]` | —   |
| `ui.sidebar.select:action:after`          | action | `[payload: { kind: 'chat'                 | 'doc'; id: string }]` | —   |
| `ui.chat.new:action:after`                | action | `[payload: {}]`                           | —                     |
| `editor.created:action:after`             | action | `[payload: { editor: any }]`              | —                     |
| `editor.updated:action:after`             | action | `[payload: { editor: any }]`              | —                     |

Notes

-   These are gathered from call sites across `app/**` and may evolve; prefer wildcard listeners for families like `error:*`.

---

## DX tips

-   Use `typedOn(hooks)` from `hook-keys` to get argument inference for known keys.
-   Filters: always return the next value. For veto-capable filters, return `false` to cancel and `''` to clear where supported.
-   For DB hooks, check the specific module under `app/db/` to see exactly which ops emit hooks and with which shapes.
</file>

<file path="hooks/hook-keys.md">
# hook-keys

Catalog of high-signal hook keys and typed helpers for ergonomically registering listeners.

---

## What does it do?

-   Defines string literal unions for well-known UI/AI/DB hook names.
-   Provides the `typedOn` helper, returning a type-safe `on()` wrapper around the hook engine.
-   Exposes utility return types to clarify filter semantics.

---

## Key unions

| Type           | Description                                                                  |
| -------------- | ---------------------------------------------------------------------------- |
| `KnownHookKey` | Enumerated list of frequently-used hooks (chat, pane, files).                |
| `DbFamily`     | Union of DB entity families (`'messages'`, `'documents'`, …).                |
| `DbHookKey`    | Template literal `db.${DbFamily}.${string}` covering table-specific hooks.   |
| `HookKey`      | Final public union combining known keys, DB hooks, and open string fallback. |

These unions power editor autocomplete while remaining permissive for plugin authors.

---

## Hook payload mapping

`HookPayloads` maps each `KnownHookKey` to a tuple of arguments expected by handlers. Examples:

-   `'ai.chat.stream:action:delta'` → `[requestId: string, payload: AiStreamDeltaPayload]`
-   `'ui.pane.thread:filter:select'` → `[threadId, pane, previousId]`
-   `'files.attach:filter:input'` → `[FilesAttachInputPayload | false]`

This mapping feeds the `typedOn` helper.

---

## `typedOn(hooks)`

```ts
import { typedOn } from '~/core/hooks/hook-keys';

const on = typedOn(useHooks()._engine);
on('ui.pane.msg:action:sent', (payload) => {
    console.log(payload.message.length);
});
```

-   Narrows `key` to `KnownHookKey` entries.
-   Infers callback parameters from `HookPayloads`.
-   Delegates to the underlying `hooks.on` and returns its disposer.

---

## Utility return types

-   `ChatOutgoingFilterReturn` — `string | false` (veto sending by returning `false`).
-   `ChatIncomingFilterReturn` — Always `string`.
-   `FilesAttachFilterReturn` — `FilesAttachInputPayload | false`.

Use these aliases in docs and tests to clarify expectations.

---

## Usage tips

-   Add new hooks by extending `KnownHookKey`/`HookPayloads` incrementally to keep compile times low.
-   Prefer `typedOn` in modules that need maximum inference but still interact with the untyped engine instance.
-   For custom plugin hooks, rely on `HookKey`’s permissiveness and extend via `hook-types` global augmentation.
</file>

<file path="hooks/hook-types.md">
# hook-types

TypeScript toolkit describing hook names, payload interfaces, and inference helpers for the OR3 hook engine.

---

## What does it do?

-   Defines structured payload interfaces for AI, UI panes, sidebar, branching, DB entities, and more.
-   Exposes string literal unions for action/filter hook names, including DB template literals.
-   Derives argument tuples and return types for every hook via `HookPayloadMap`.
-   Provides utility types for plugins to validate hook names and callback signatures.

---

## Payload interfaces

Notable groups:

-   **AI** — `AiSendBeforePayload`, `AiStreamDeltaPayload`, `AiRetryAfterPayload`.
-   **Pane/UI** — `UiPaneActivePayload`, `UiPaneMsgSentPayload`, `UiSidebarSelectPayload`.
-   **Branching** — `BranchForkOptions`, `BranchContextAfterPayload`.
-   **DB entities** — Lightweight mirror types (`MessageEntity`, `FileEntity`, `PromptEntity`, …).
-   **Utility** — `DbCreatePayload<T>`, `DbUpdatePayload<T>`, `DbDeletePayload<T>`.

These interfaces power typed composables, doc tables, and hook filters.

---

## Hook name unions

| Type               | Description                                                                                                               |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------- |
| `ActionHookName`   | Literal union matching `*:action:*` hooks (core + DB + extensions).                                                       |
| `FilterHookName`   | Literal union matching `*:filter:*` hooks (core + DB + extensions).                                                       |
| `HookName`         | Combined action + filter union used across the app.                                                                       |
| `DbActionHookName` | Template literal union for DB action hooks, including delete phases and custom cases (`db.files.refchange:action:after`). |
| `DbFilterHookName` | Template literal union for DB filters, including specialized titles/hash validators.                                      |

Plugin authors can augment `Or3ActionHooks` / `Or3FilterHooks` globally to extend these unions.

---

## Inference utilities

| Type                          | Purpose                                                                      |
| ----------------------------- | ---------------------------------------------------------------------------- |
| `InferHookParams<K>`          | Tuple of callback parameters for hook `K`.                                   |
| `InferHookReturn<K>`          | Return type a callback must produce (`void` for actions, value for filters). |
| `InferHookCallback<K>`        | Full function signature expected for hook `K`.                               |
| `IsAction<K>` / `IsFilter<K>` | Type-level booleans.                                                         |
| `ExtractHookPayload<K>`       | First parameter payload, handy for documentation.                            |
| `MatchingHooks<'pattern'>`    | Narrow hooks by template literal pattern (`'db.files.*'`).                   |
| `InferDbEntity<'db.files.*'>` | Maps hook strings back to entity interfaces.                                 |

These utilities are heavily used by `typed-hooks.ts` and composables like `useHookEffect`.

---

## Error helpers

-   `ValidateHookName<'bad.name'>` produces string literal diagnostics suggesting similar hooks.
-   `CallbackMismatch<Expected, Got>` formats readable error messages for mismatched callbacks.
-   Temporary guard `__hook_name_checks__` keeps frequently-used names anchored in the type system.

---

## Usage tips

-   When adding new hooks, update `CoreHookPayloadMap` (or appropriate DB unions) first; inference and docs will follow automatically.
-   For plugin ecosystems, augment `Or3ActionHooks`/`Or3FilterHooks` in a `.d.ts` file to make your hooks discoverable.
-   Use `InferHookCallback<'ui.pane.msg:action:sent'>` in unit tests to ensure mocks stay in sync with payload evolution.

---

## Related

-   `hook-keys.ts` — Convenience `typedOn` helper that leans on these types.
-   `typed-hooks.ts` — Runtime wrapper applying `InferHookCallback` signatures to the hook engine.
-   `useHookEffect` — Composable that uses `InferHookCallback` for DX.
</file>

<file path="hooks/hooks.md">
# hooks

Lightweight hook engine that powers OR3’s action/filter system with priority scheduling, async support, and diagnostics.

---

## What does it do?

-   Registers callbacks as **actions** (fire-and-forget) or **filters** (value transformers).
-   Supports wildcard subscriptions with glob patterns (`ai.chat.*`).
-   Executes listeners in priority order, tracking the current priority stack.
-   Provides both async (`doAction`, `applyFilters`) and sync variants.
-   Captures timing and error metrics for introspection.

---

## Core concepts

| Concept   | Details                                                                           |
| --------- | --------------------------------------------------------------------------------- |
| Action    | Side-effect listeners, return `void`/`Promise<void>`. Run via `doAction`.         |
| Filter    | Transform a value and return the next value in the chain. Run via `applyFilters`. |
| Priority  | Lower numbers execute first (default `10`). Ties fall back to insertion order.    |
| Wildcards | Use `*` to match multiple hook names (`db.*.delete:action:after`).                |

---

## API surface

| Function                | Signature                              | Notes                                                  |
| ----------------------- | -------------------------------------- | ------------------------------------------------------ |
| `addAction`             | `(name, fn, priority?, acceptedArgs?)` | Registers an action listener.                          |
| `removeAction`          | `(name, fn, priority?)`                | Removes a specific action listener.                    |
| `doAction`              | `(name, ...args) => Promise<void>`     | Runs all action listeners async.                       |
| `doActionSync`          | `(name, ...args) => void`              | Synchronous variant.                                   |
| `addFilter`             | `(name, fn, priority?, acceptedArgs?)` | Registers filter listener.                             |
| `removeFilter`          | `(name, fn, priority?)`                | Removes filter listener.                               |
| `applyFilters`          | `(name, value, ...args) => Promise<T>` | Runs filters async, returning the final value.         |
| `applyFiltersSync`      | `(name, value, ...args) => T`          | Synchronous variant.                                   |
| `on`                    | `(name, fn, opts?) => disposer`        | Ergonomic wrapper picking `action` vs `filter`.        |
| `off`                   | `(disposer) => void`                   | Safely invokes disposers (with error reporting).       |
| `onceAction`            | `(name, fn, priority?) => disposer`    | Auto-removes listener after first fire.                |
| `hasAction / hasFilter` | `(name?, fn?)`                         | Returns `false`/priority/boolean for existence checks. |
| `removeAllCallbacks`    | `(priority?)`                          | Drops all callbacks, optionally by priority.           |
| `currentPriority`       | `() => number \| false`                | Reports the priority currently executing.              |

Diagnostics live under `_diagnostics` with per-hook timing arrays and error counts.

---

## Execution flow

1. **Lookup** — Gathers exact matches plus wildcard entries, then sorts by priority/id.
2. **Timing** — Measures each callback using `performance.now` when available.
3. **Errors** — Logs console errors and increments `_diagnostics.errors[name]` without interrupting other listeners.
4. **Filters** — Thread the transformed value through the chain, returning the final result.

---

## Wildcards

-   Register with `hooks.addAction('ui.pane.*', handler)` to observe entire families.
-   Stored with a compiled `RegExp` for quick matching, still respecting priority.
-   Removal requires the original glob string + callback reference.

---

## Usage tips

-   Favor the typed wrapper (`createTypedHookEngine`) or composable (`useHooks`) for better DX.
-   Always return the transformed value from filters; returning `undefined` will propagate.
-   Use `onceAction` for analytics pings or onboarding to avoid manual cleanup.
-   Inspect `hooks._diagnostics.timings` in devtools to spot slow listeners.

---

## Related

-   `hook-types.ts` — Type system describing hook names and payloads.
-   `typed-hooks.ts` — Zero-cost typed wrapper around this engine.
-   `useHookEffect` — Vue composable for lifecycle-aware subscriptions.
</file>

<file path="hooks/typed-hooks.md">
# typed-hooks

Typed wrapper around the hook engine that preserves runtime behavior while delivering full TypeScript inference.

---

## What does it do?

-   Wraps a `HookEngine` with strongly typed methods for registering/executing hooks.
-   Infers callback signatures from `hook-types.ts` using `InferHookCallback` utilities.
-   Normalizes `hooks.on` to pick `action` vs `filter` automatically when the name contains `:filter:`.
-   Exposes diagnostics and the underlying engine for advanced use.

---

## API

`createTypedHookEngine(engine: HookEngine): TypedHookEngine`

Returns an object implementing:

-   `addAction`, `removeAction`, `doAction`, `doActionSync`
-   `addFilter`, `removeFilter`, `applyFilters`, `applyFiltersSync`
-   `on`, `off`, `onceAction`
-   `hasAction`, `hasFilter`, `removeAllCallbacks`, `currentPriority`
-   `_engine`, `_diagnostics`

### Example

```ts
import { createHookEngine } from '~/core/hooks/hooks';
import { createTypedHookEngine } from '~/core/hooks/typed-hooks';

const engine = createHookEngine();
const hooks = createTypedHookEngine(engine);

hooks.addFilter('ui.chat.message:filter:outgoing', (text) => text.trim());
const sanitized = await hooks.applyFilters(
    'ui.chat.message:filter:outgoing',
    message
);
```

TypeScript enforces that callbacks return the correct value (`string` above) and that the hook name exists.

---

## Kind inference

-   `on(name, callback, opts?)` automatically sets `opts.kind` to `'filter'` when the name includes `':filter:'`.
-   You can still override `opts.kind` to handle custom naming schemes.

---

## Passthrough utilities

-   `hasAction` / `hasFilter` — Useful for tests or debugging.
-   `removeAllCallbacks` — Clear listeners by priority (e.g., during teardown).
-   `currentPriority` — Inspect priority during nested hook execution.
-   `_diagnostics` — Direct access to timing/error aggregates from the base engine.

---

## Usage tips

-   Use `useHooks()` (which already wraps the injected engine) instead of building a new typed engine in most components.
-   Export the typed instance when building plugins so consumers benefit from strong typing.
-   When extending hook payloads via declaration merging, the typed engine automatically reflects the new signatures.
</file>

<file path="hooks/useHooks.md">
# useHooks

Nuxt composable that returns the app-wide typed hook engine, creating a fallback instance when none is provided.

---

## What does it do?

-   Reads the injected `$hooks` instance from `useNuxtApp()`.
-   Wraps it with `createTypedHookEngine` to provide full TypeScript inference.
-   Caches the typed engine per provider to avoid rebuilding wrappers.
-   Creates a dev-only fallback hook engine when `$hooks` is missing (e.g., during unit tests).

---

## API

```ts
function useHooks(): TypedHookEngine;
```

Example usage:

```ts
const hooks = useHooks();

hooks.doAction('ui.pane.active:action', {
    pane,
    index: 0,
});

const sanitized = await hooks.applyFilters(
    'ui.chat.message:filter:outgoing',
    draft
);
```

-   The returned object includes every typed method described in `typed-hooks.md`.
-   Consumers do not need to import `hook-types` directly; inference is automatic.

---

## Fallback behavior

-   When `$hooks` is absent (tests, SSR stubs), the composable instantiates a local engine and logs a warning in dev mode.
-   The fallback stays cached across calls so listeners persist for the session.

---

## Caching strategy

-   Stores `{ engine, typed }` in a module-level `cached` object keyed by the current `$hooks` reference.
-   When the provider changes (e.g., HMR re-injection), the typed wrapper is rebuilt to keep methods in sync.

---

## Usage tips

-   Call `useHooks()` inside Vue `setup()` or other composables; it relies on Nuxt’s app context.
-   Pair with `useHookEffect` when you want automatic lifecycle cleanup around `hooks.on`.
-   In tests, stub `$hooks` on the Nuxt app to assert listener registration without touching the fallback.
</file>

<file path="types/composables.md">
# Composables types

Canonical reference for every exported TypeScript type and interface defined under `app/composables`. These contracts power registry utilities, workspace state, streaming, UI chrome, and plugin extension points. Each table links the shape you consume when building features or plugins on top of the composable layer.

---

## Shared registry helpers (`app/composables/_registry.ts`)

| Type             | Kind      | Description                                                                                                                            |
| ---------------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| `RegistryItem`   | interface | Minimal contract for registry entries (`id`, optional `order`). Shared by sidebar, header, project tree, and other registries.         |
| `RegistryApi<T>` | interface | Generic API returned by `createRegistry` exposing `register`, `unregister`, `listIds`, `snapshot`, and a reactive `useItems()` helper. |

```ts
// app/composables/_registry.ts
import { computed, shallowRef } from 'vue';
import type { ComputedRef, ShallowRef } from 'vue';

export interface RegistryItem {
    id: string;
    order?: number;
}

export interface RegistryApi<T extends RegistryItem> {
    register(item: T): void;
    unregister(id: string): void;
    listIds(): string[];
    snapshot(): T[];
    useItems(): ComputedRef<readonly T[]>;
}

export function createRegistry<T extends RegistryItem>(
    globalKey: string,
    sortFn: (a: T, b: T) => number = (a, b) =>
        (a.order ?? 200) - (b.order ?? 200)
): RegistryApi<T> {
    const g: any = globalThis as any;
    const registry: Map<string, T> =
        g[globalKey] || (g[globalKey] = new Map<string, T>());
    const store: ShallowRef<T[]> = shallowRef([]);

    function sync() {
        store.value = Array.from(registry.values());
    }

    function register(item: T) {
        if (import.meta.dev && registry.has(item.id)) {
            console.warn(`[registry:${globalKey}] Replacing id: ${item.id}`);
        }
        const frozen = Object.freeze({ ...item });
        registry.set(item.id, frozen);
        sync();
    }

    function unregister(id: string) {
        if (registry.delete(id)) sync();
    }

    function listIds() {
        return Array.from(registry.keys());
    }

    function snapshot(): T[] {
        return store.value.slice();
    }

    function useItems(): ComputedRef<readonly T[]> {
        return computed(() => [...store.value].sort(sortFn));
    }

    if (!store.value.length && registry.size) sync();

    return { register, unregister, listIds, snapshot, useItems };
}
```

---

## Workspace backup & preview caching

| Type                   | Kind      | Description                                                                                                                                  |
| ---------------------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| `WorkspaceImportMode`  | union     | `'replace'` or `'append'`; controls how imports merge with the existing Dexie database.                                                      |
| `WorkspaceBackupState` | interface | Reactive state bag returned by `useWorkspaceBackup()` (`isExporting`, `progress`, `currentStep`, `importMode`, `backupMeta`, `error`, etc.). |
| `ImportMetadata`       | interface | Parsed metadata pulled from `.or3` exports: database name/version plus per-table row counts.                                                 |
| `WorkspaceBackupApi`   | interface | Public API of `useWorkspaceBackup()` exposing `exportWorkspace`, `peekBackup`, `importWorkspace`, and `reset`.                               |
| `PreviewCacheOptions`  | alias     | Re-exported from `~/config/preview-cache`; defines limits such as `maxUrls`, `maxBytes`, and eviction strategy knobs.                        |
| `PreviewCacheMetrics`  | interface | Snapshot of cache stats (`urls`, `bytes`, `hits`, `misses`, `evictions`) produced by `usePreviewCache().metrics()`.                          |

```ts
// app/composables/core/useWorkspaceBackup.ts
import { ref, type Ref } from 'vue';
import type { AppError } from '~/utils/errors';

export type WorkspaceImportMode = 'replace' | 'append';

export interface WorkspaceBackupState {
    isExporting: Ref<boolean>;
    isImporting: Ref<boolean>;
    progress: Ref<number>;
    currentStep: Ref<
        | 'idle'
        | 'peeking'
        | 'confirm'
        | 'importing'
        | 'exporting'
        | 'done'
        | 'error'
    >;
    importMode: Ref<WorkspaceImportMode>;
    overwriteValues: Ref<boolean>;
    backupMeta: Ref<ImportMetadata | null>;
    backupFormat: Ref<'stream' | 'dexie' | null>;
    error: Ref<AppError | null>;
}

export interface ImportMetadata {
    databaseName: string;
    databaseVersion: number;
    tables: Array<{ name: string; rowCount: number }>;
}

export interface WorkspaceBackupApi {
    state: WorkspaceBackupState;
    exportWorkspace(): Promise<void>;
    peekBackup(file: Blob): Promise<void>;
    importWorkspace(file: Blob): Promise<void>;
    reset(): void;
}
```

```ts
// app/config/preview-cache.ts
export type PreviewCacheOptions = {
    maxUrls: number;
    maxBytes: number;
};

const BASE_LIMITS: PreviewCacheOptions = {
    maxUrls: 120,
    maxBytes: 80 * 1024 * 1024,
};

const LOW_MEMORY_LIMITS: PreviewCacheOptions = {
    maxUrls: 80,
    maxBytes: 48 * 1024 * 1024,
};

function detectDeviceMemory(): number | undefined {
    if (typeof navigator === 'undefined') return undefined;
    const value = (navigator as any).deviceMemory;
    return typeof value === 'number' && Number.isFinite(value)
        ? value
        : undefined;
}

export function resolvePreviewCacheOptions(
    overrides: Partial<PreviewCacheOptions> = {}
): PreviewCacheOptions {
    const memory = detectDeviceMemory();
    const defaults = memory && memory <= 4 ? LOW_MEMORY_LIMITS : BASE_LIMITS;
    return {
        maxUrls: overrides.maxUrls ?? defaults.maxUrls,
        maxBytes: overrides.maxBytes ?? defaults.maxBytes,
    };
}
```

```ts
// app/composables/core/usePreviewCache.ts
import type { PreviewCacheOptions } from '~/config/preview-cache';

export interface PreviewCacheMetrics {
    urls: number;
    bytes: number;
    hits: number;
    misses: number;
    evictions: number;
}
```

---

## Multi-pane orchestration (`app/composables/core/useMultiPane.ts`, `documents/usePaneDocuments.ts`)

| Type                      | Kind      | Description                                                                                                              |
| ------------------------- | --------- | ------------------------------------------------------------------------------------------------------------------------ |
| `MultiPaneMessage`        | interface | Normalised pane message payload (`role`, `content`, optional `file_hashes`, `id`, `stream_id`).                          |
| `PaneState`               | interface | Persistent pane descriptor (`id`, `mode`, `threadId`, optional `documentId`, `messages`, `validating`).                  |
| `UseMultiPaneOptions`     | interface | Optional configuration for `useMultiPane()` (`initialThreadId`, `maxPanes`, `onFlushDocument`, `loadMessagesFor`).       |
| `UseMultiPaneApi`         | interface | Methods returned by `useMultiPane()` (`panes`, `activePaneIndex`, `addPane`, `setPaneThread`, navigation helpers, etc.). |
| `MultiPaneState`          | alias     | Re-export of `PaneState` for consumers that prefer `MultiPaneState[]` semantics.                                         |
| `UsePaneDocumentsOptions` | interface | `usePaneDocuments()` inputs (pane refs, `activePaneIndex`, `createNewDoc`, `flushDocument`).                             |
| `UsePaneDocumentsApi`     | interface | Document helpers returned by `usePaneDocuments()` (`newDocumentInActive`, `selectDocumentInActive`).                     |

```ts
// app/composables/core/useMultiPane.ts
import type { Ref, ComputedRef } from 'vue';

export type MultiPaneMessage = {
    role: 'user' | 'assistant';
    content: string;
    file_hashes?: string | null;
    id?: string;
    stream_id?: string;
};

export interface PaneState {
    id: string;
    mode: 'chat' | 'doc';
    threadId: string;
    documentId?: string;
    messages: MultiPaneMessage[];
    validating: boolean;
}

export interface UseMultiPaneOptions {
    initialThreadId?: string;
    maxPanes?: number;
    onFlushDocument?: (id: string) => void | Promise<void>;
    loadMessagesFor?: (id: string) => Promise<MultiPaneMessage[]>;
}

export interface UseMultiPaneApi {
    panes: Ref<PaneState[]>;
    activePaneIndex: Ref<number>;
    canAddPane: ComputedRef<boolean>;
    newWindowTooltip: ComputedRef<string>;
    addPane(): void;
    closePane(index: number): Promise<void> | void;
    setActive(index: number): void;
    focusPrev(current: number): void;
    focusNext(current: number): void;
    setPaneThread(index: number, threadId: string): Promise<void>;
    loadMessagesFor(id: string): Promise<MultiPaneMessage[]>;
    ensureAtLeastOne(): void;
}

export type MultiPaneState = PaneState;

// app/composables/documents/usePaneDocuments.ts
```

```ts
// app/composables/documents/usePaneDocuments.ts
import type { Ref } from 'vue';
import type { MultiPaneState } from '~/composables/core/useMultiPane';

export interface UsePaneDocumentsOptions {
    panes: Ref<MultiPaneState[]>;
    activePaneIndex: Ref<number>;
    createNewDoc: (initial?: { title?: string }) => Promise<{ id: string }>;
    flushDocument: (id: string) => Promise<void> | void;
}

export interface UsePaneDocumentsApi {
    newDocumentInActive(initial?: {
        title?: string;
    }): Promise<{ id: string } | undefined>;
    selectDocumentInActive(id: string): Promise<void>;
}
```

---

## Document & thread history registries

| Type                    | Kind      | Description                                                                                                  |
| ----------------------- | --------- | ------------------------------------------------------------------------------------------------------------ |
| `DocumentHistoryAction` | interface | Defines sidebar document history actions (id, icon, label, optional `order`, async `handler({ document })`). |
| `ThreadHistoryAction`   | interface | Same pattern for thread history dropdown entries (`handler({ document: Thread })`).                          |

```ts
// app/composables/documents/useDocumentHistoryActions.ts
import type { Post } from '~/db';

export interface DocumentHistoryAction {
    id: string;
    icon: string;
    label: string;
    order?: number;
    handler: (ctx: { document: Post }) => void | Promise<void>;
}

// app/composables/threads/useThreadHistoryActions.ts
import type { Thread } from '~/db';

export interface ThreadHistoryAction {
    id: string;
    icon: string;
    label: string;
    order?: number;
    handler: (ctx: { document: Thread }) => void | Promise<void>;
}
```

---

## Prompt, messaging & AI state

| Type                | Kind      | Description                                                                                                       |
| ------------------- | --------- | ----------------------------------------------------------------------------------------------------------------- |
| `ActivePromptState` | interface | Module-singleton state describing the currently selected system prompt (`activePromptId`, `activePromptContent`). |
| `ChatMessageAction` | interface | Extendable chat message action button contract (id, icon, tooltip, `showOn`, optional `order`, async handler).    |
| `AiSettingsV1`      | interface | Persisted AI preferences (`masterSystemPrompt`, `defaultModelMode`, optional `fixedModelId`, schema version).     |

```ts
// app/composables/chat/useActivePrompt.ts
import { ref, readonly } from 'vue';

export interface ActivePromptState {
    activePromptId: string | null;
    activePromptContent: any | null;
}

// app/composables/chat/useMessageActions.ts
export interface ChatMessageAction {
    id: string;
    icon: string;
    tooltip: string;
    showOn: 'user' | 'assistant' | 'both';
    order?: number;
    handler: (ctx: { message: any; threadId?: string }) => void | Promise<void>;
}

// app/composables/chat/useAiSettings.ts
export interface AiSettingsV1 {
    version: 1;
    masterSystemPrompt: string;
    defaultModelMode: 'lastSelected' | 'fixed';
    fixedModelId: string | null;
}
```

---

## Streaming accumulator (`app/composables/chat/useStreamAccumulator.ts`)

| Type                    | Kind      | Description                                                                                         |
| ----------------------- | --------- | --------------------------------------------------------------------------------------------------- |
| `StreamingState`        | interface | Reactive token buffer state (`text`, `reasoningText`, `isActive`, `finalized`, `error`, `version`). |
| `AppendKind`            | union     | `'text'` or `'reasoning'`; distinguishes which buffer `append()` targets.                           |
| `StreamAccumulatorApi`  | interface | Contract returned by `createStreamAccumulator()` (`state`, `append`, `finalize`, `reset`).          |
| `UnifiedStreamingState` | alias     | Re-export of `StreamingState` for callers expecting the previous naming.                            |

```ts
// app/composables/chat/useStreamAccumulator.ts
export interface StreamingState {
    text: string;
    reasoningText: string;
    isActive: boolean;
    finalized: boolean;
    error: Error | null;
    version: number;
}

export type AppendKind = 'text' | 'reasoning';

export interface StreamAccumulatorApi {
    state: Readonly<StreamingState>;
    append(delta: string, options: { kind: AppendKind }): void;
    finalize(opts?: { error?: Error; aborted?: boolean }): void;
    reset(): void;
}

export type UnifiedStreamingState = StreamingState;
```

---

## Project tree & workspace CRUD

| Type                    | Kind      | Description                                                                                               |
| ----------------------- | --------- | --------------------------------------------------------------------------------------------------------- |
| `ProjectTreeKind`       | union     | `'chat'` or `'doc'`; identifies tree row flavor.                                                          |
| `ShowOnKind`            | union     | `'root'`, `'all'`, `'chat'`, `'doc'`; used to limit project tree actions.                                 |
| `ProjectTreeChild`      | interface | Child row descriptor (value, label, optional icon/parentId/select handler).                               |
| `ProjectTreeRoot`       | interface | Root row descriptor (project id/name, optional expansion flag, children, handler).                        |
| `ProjectTreeRow`        | alias     | Union of `ProjectTreeRoot` and `ProjectTreeChild`.                                                        |
| `ProjectTreeHandlerCtx` | interface | Context passed to project tree action handlers (`treeRow`, plus legacy `child`/`root`).                   |
| `ProjectTreeAction`     | interface | Registry entry for project tree context menu items (id, icon, label, optional `order`/`showOn`, handler). |
| `CreateProjectInput`    | interface | Input accepted by `useProjectsCrud().createProject` (name, optional description/id override).             |
| `DeleteProjectOptions`  | interface | Options for `deleteProject` (`soft` defaults to true, `false` triggers hard delete).                      |

```ts
// app/composables/projects/useProjectTreeActions.ts
import type { RegistryItem } from '#imports';

export type ProjectTreeKind = 'chat' | 'doc';
export type ShowOnKind = 'root' | 'all' | 'chat' | 'doc';

export interface ProjectTreeChild {
    value: string;
    label: string;
    icon?: string;
    kind?: ProjectTreeKind;
    parentId?: string;
    onSelect?: (e: Event) => void;
}

export interface ProjectTreeRoot {
    value: string;
    label: string;
    defaultExpanded?: boolean;
    children?: ProjectTreeChild[];
    onSelect?: (e: Event) => void;
}

export type ProjectTreeRow = ProjectTreeRoot | ProjectTreeChild;

export interface ProjectTreeHandlerCtx {
    treeRow: ProjectTreeRow;
    child?: ProjectTreeChild;
    root?: ProjectTreeRoot;
}

export interface ProjectTreeAction extends RegistryItem {
    id: string;
    icon: string;
    label: string;
    order?: number;
    showOn?: ShowOnKind[];
    handler: (ctx: ProjectTreeHandlerCtx) => void | Promise<void>;
}

// app/composables/projects/useProjectsCrud.ts
export interface CreateProjectInput {
    name: string;
    description?: string | null;
    id?: string;
}

export interface DeleteProjectOptions {
    soft?: boolean;
}
```

---

## Dashboard plugins & navigation

| Type                            | Kind      | Description                                                                                                             |
| ------------------------------- | --------- | ----------------------------------------------------------------------------------------------------------------------- |
| `DashboardPlugin`               | interface | Primary plugin registration shape (id, icon, label, optional description/order/handler/pages/capabilities).             |
| `DashboardPluginPage`           | interface | Per-plugin page descriptor (id, title, optional icon/order/description, component or async factory).                    |
| `DashboardNavigationErrorCode`  | union     | Error codes emitted by navigation helpers (`'missing-plugin'`, `'missing-page'`, `'handler-error'`, `'resolve-error'`). |
| `DashboardNavigationError`      | interface | Structured error object carrying a `message`, optional plugin/page context, and original `cause`.                       |
| `DashboardNavigationState`      | interface | Reactive navigation state (`view`, `activePluginId`, `activePageId`, `loadingPage`, `error`).                           |
| `DashboardNavigationResult`     | union     | Result wrapper for navigation attempts (`{ ok: true }` or `{ ok: false; error }`).                                      |
| `UseDashboardNavigationOptions` | interface | Optional base plugin list for `useDashboardNavigation()` bootstrap.                                                     |

```ts
// app/composables/dashboard/useDashboardPlugins.ts
import type { Component } from 'vue';

export interface DashboardPlugin {
    id: string;
    icon: string;
    label: string;
    description?: string;
    order?: number;
    handler?: (ctx: { id: string }) => void | Promise<void>;
    pages?: DashboardPluginPage[];
    capabilities?: string[];
}

export interface DashboardPluginPage {
    id: string;
    title: string;
    icon?: string;
    order?: number;
    description?: string;
    component: Component | (() => Promise<any>);
}

export type DashboardNavigationErrorCode =
    | 'missing-plugin'
    | 'missing-page'
    | 'handler-error'
    | 'resolve-error';

export interface DashboardNavigationError {
    code: DashboardNavigationErrorCode;
    message: string;
    pluginId?: string;
    pageId?: string;
    cause?: unknown;
}

export interface DashboardNavigationState {
    view: 'dashboard' | 'page';
    activePluginId: string | null;
    activePageId: string | null;
    loadingPage: boolean;
    error: DashboardNavigationError | null;
}

export type DashboardNavigationResult =
    | { ok: true }
    | { ok: false; error: DashboardNavigationError };

export interface UseDashboardNavigationOptions {
    baseItems?: DashboardPlugin[];
}
```

---

## Sidebar, header & composer chrome

| Type                         | Kind      | Description                                                                                                            |
| ---------------------------- | --------- | ---------------------------------------------------------------------------------------------------------------------- |
| `SidebarSectionPlacement`    | union     | `'top'`, `'main'`, or `'bottom'`; controls where custom sections render.                                               |
| `SidebarSection`             | interface | Registry entry for sidebar stack sections (id, component/async loader, optional `order`/`placement`).                  |
| `SidebarFooterActionContext` | interface | Runtime context passed to footer action handlers (`activeThreadId`, `activeDocumentId`, `isCollapsed`).                |
| `ChromeActionColor`          | union     | Palette of supported footer/header button colors (Iconify-compatible strings plus strong/neutral variants).            |
| `SidebarFooterAction`        | interface | Footer action registry entry (id, icon, optional label/tooltip/order/color, handler + visibility/disabled predicates). |
| `SidebarFooterActionEntry`   | interface | Derived tuple returned by `useSidebarFooterActions()` (`action`, `disabled`).                                          |
| `HeaderActionContext`        | interface | Context for header actions (current route, `isMobile`, arbitrary params).                                              |
| `HeaderAction`               | interface | Header action registry entry (id, icon, optional tooltip/label/order/color, handler + visibility/disabled guards).     |
| `HeaderActionEntry`          | interface | Result rows returned by `useHeaderActions()` with resolved `disabled` state.                                           |
| `ComposerActionContext`      | interface | Composer button context (`editor`, `threadId`, `paneId`, `isStreaming`, custom metadata).                              |
| `ComposerAction`             | interface | Composer toolbar action contract (id, icon, optional tooltip/label/order/color, handler + visibility/disabled guards). |
| `ComposerActionEntry`        | interface | Wrapper returned by `useComposerActions()` that pairs an action with its `disabled` flag.                              |

```ts
// app/composables/sidebar/useSidebarSections.ts
import type { Component, ComputedRef } from 'vue';
import type { RouteLocationNormalizedLoaded } from 'vue-router';
import type { Editor } from '@tiptap/vue-3';
import type { RegistryItem } from '../_registry';

export type SidebarSectionPlacement = 'top' | 'main' | 'bottom';

export interface SidebarSection extends RegistryItem {
    id: string;
    component: Component | (() => Promise<any>);
    order?: number;
    placement?: SidebarSectionPlacement;
}

export interface SidebarFooterActionContext {
    activeThreadId?: string | null;
    activeDocumentId?: string | null;
    isCollapsed?: boolean;
}

export type ChromeActionColor =
    | 'neutral'
    | 'primary'
    | 'secondary'
    | 'success'
    | 'warning'
    | 'error'
    | 'info'
    | 'inverse-primary'
    | (string & {});

export interface SidebarFooterAction extends RegistryItem {
    id: string;
    icon: string;
    label?: string;
    tooltip?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: SidebarFooterActionContext) => void | Promise<void>;
    visible?: (ctx: SidebarFooterActionContext) => boolean;
    disabled?: (ctx: SidebarFooterActionContext) => boolean;
}

export interface SidebarFooterActionEntry {
    action: SidebarFooterAction;
    disabled: boolean;
}

// app/composables/sidebar/useHeaderActions.ts
export interface HeaderActionContext {
    route?: RouteLocationNormalizedLoaded | null;
    isMobile?: boolean;
    [key: string]: unknown;
}

export interface HeaderAction extends RegistryItem {
    id: string;
    icon: string;
    tooltip?: string;
    label?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: HeaderActionContext) => void | Promise<void>;
    visible?: (ctx: HeaderActionContext) => boolean;
    disabled?: (ctx: HeaderActionContext) => boolean;
}

export interface HeaderActionEntry {
    action: HeaderAction;
    disabled: boolean;
}

// app/composables/sidebar/useComposerActions.ts
export interface ComposerActionContext {
    editor?: Editor | null;
    threadId?: string | null;
    paneId?: string | null;
    isStreaming?: boolean;
    [key: string]: unknown;
}

export interface ComposerAction {
    id: string;
    icon: string;
    tooltip?: string;
    label?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: ComposerActionContext) => void | Promise<void>;
    visible?: (ctx: ComposerActionContext) => boolean;
    disabled?: (ctx: ComposerActionContext) => boolean;
}

export interface ComposerActionEntry {
    action: ComposerAction;
    disabled: boolean;
}
```

---

## Editor extension points (`app/composables/editor`)

| Type                  | Kind      | Description                                                                                                     |
| --------------------- | --------- | --------------------------------------------------------------------------------------------------------------- |
| `EditorNode`          | interface | TipTap node extension registration (id, `Node` instance, optional `order`).                                     |
| `EditorMark`          | interface | TipTap mark extension registration (id, `Mark` instance, optional `order`).                                     |
| `EditorExtension`     | interface | Generic TipTap extension registration (id, `Extension` instance, optional `order`).                             |
| `EditorToolbarButton` | interface | Editor toolbar button contract (id, icon, tooltip, optional `order`, `isActive`, `visible`, and click handler). |

```ts
// app/composables/editor/useEditorNodes.ts
import type { Node, Mark, Extension } from '@tiptap/core';

export interface EditorNode {
    id: string;
    extension: Node;
    order?: number;
}

export interface EditorMark {
    id: string;
    extension: Mark;
    order?: number;
}

export interface EditorExtension {
    id: string;
    extension: Extension;
    order?: number;
}

// app/composables/editor/useEditorToolbar.ts
import type { Editor } from '@tiptap/vue-3';

export interface EditorToolbarButton {
    id: string;
    icon: string;
    tooltip?: string;
    order?: number;
    isActive?: (editor: Editor) => boolean;
    onClick: (editor: Editor) => void | Promise<void>;
    visible?: (editor: Editor) => boolean;
}
```

---

Maintaining this catalogue alongside the code ensures plugin authors and internal feature teams share a single source of truth. Update the relevant section whenever you add, rename, or extend a composable type so the documentation stays authoritative.
</file>

<file path="types/database.md">
# Database types

Reference for every exported type and interface defined under `app/db`. These aliases describe the Dexie schema, higher-level records, and helper payloads that wrap database operations.

---

## Schema-derived entities (`app/db/schema.ts`)

| Type               | Kind  | Source schema                  | Description                                                                                          |
| ------------------ | ----- | ------------------------------ | ---------------------------------------------------------------------------------------------------- |
| `Project`          | alias | `ProjectSchema`                | Fully validated project row (id, name, description, clocks, timestamps).                             |
| `Thread`           | alias | `ThreadSchema`                 | Thread row with branching metadata, status flags, and clock fields.                                  |
| `ThreadCreate`     | alias | `ThreadCreateSchema` input     | Looser input shape accepted when creating a thread prior to validation.                              |
| `Message`          | alias | `MessageSchema`                | Stored message row with role, data payload, ordering index, and timestamps.                          |
| `MessageCreate`    | alias | `MessageCreateSchema` input    | Input contract for new messages before normalization (allows sparse indexes, file hashes as arrays). |
| `Post`             | alias | `PostSchema`                   | Post/blog row persisted in Dexie.                                                                    |
| `PostCreate`       | alias | `PostCreateSchema` input       | Input structure for creating posts.                                                                  |
| `Kv`               | alias | `KvSchema`                     | Key-value record (name/value pairs plus clock/timestamps).                                           |
| `KvCreate`         | alias | `KvCreateSchema`               | Input payload for inserting KV entries.                                                              |
| `Attachment`       | alias | `AttachmentSchema`             | Attachment row linking messages to files.                                                            |
| `AttachmentCreate` | alias | `AttachmentCreateSchema` input | Input contract for creating attachments.                                                             |
| `FileMeta`         | alias | `FileMetaSchema`               | Stored metadata for blobs (hash, mime, size, soft delete flags).                                     |
| `FileMetaCreate`   | alias | `FileMetaCreateSchema` input   | Input structure when minting new file metadata.                                                      |

The `app/db/index.ts` barrel re-exports these aliases (including `Document`) for consumers using `import { Thread } from '~/db'` style imports.

```ts
// app/db/schema.ts
import { z } from 'zod';
import { newId, nowSec } from './util';

export const ProjectSchema = z.object({
    id: z.string(),
    name: z.string(),
    description: z.string().nullable().optional(),
    data: z.any(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    deleted: z.boolean().default(false),
    clock: z.number().int(),
});
export type Project = z.infer<typeof ProjectSchema>;

export const ThreadSchema = z.object({
    id: z.string(),
    title: z.string().nullable().optional(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    last_message_at: z.number().int().nullable().optional(),
    parent_thread_id: z.string().nullable().optional(),
    anchor_message_id: z.string().nullable().optional(),
    anchor_index: z.number().int().nullable().optional(),
    branch_mode: z.enum(['reference', 'copy']).nullable().optional(),
    status: z.string().default('ready'),
    deleted: z.boolean().default(false),
    pinned: z.boolean().default(false),
    clock: z.number().int(),
    forked: z.boolean().default(false),
    project_id: z.string().nullable().optional(),
    system_prompt_id: z.string().nullable().optional(),
});
export type Thread = z.infer<typeof ThreadSchema>;

export const ThreadCreateSchema = ThreadSchema.partial({
    id: true,
    title: true,
    last_message_at: true,
    parent_thread_id: true,
    status: true,
    deleted: true,
    pinned: true,
    forked: true,
    project_id: true,
    system_prompt_id: true,
})
    .omit({ created_at: true, updated_at: true, id: true, clock: true })
    .extend({
        id: z
            .string()
            .optional()
            .transform((v) => v ?? newId()),
        clock: z
            .number()
            .int()
            .optional()
            .transform((v) => v ?? 0),
        created_at: z.number().int().default(nowSec()),
        updated_at: z.number().int().default(nowSec()),
    });
export type ThreadCreate = z.input<typeof ThreadCreateSchema>;

export const MessageSchema = z.object({
    id: z.string(),
    data: z.unknown().nullable().optional(),
    role: z.string(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    error: z.string().nullable().optional(),
    deleted: z.boolean().default(false),
    thread_id: z.string(),
    index: z.number().int(),
    clock: z.number().int(),
    stream_id: z.string().nullable().optional(),
    file_hashes: z.string().nullable().optional(),
});
export type Message = z.infer<typeof MessageSchema>;

export const MessageCreateSchema = MessageSchema.partial({ index: true })
    .omit({ created_at: true, updated_at: true, id: true, clock: true })
    .extend({
        id: z
            .string()
            .optional()
            .transform((v) => v ?? newId()),
        clock: z
            .number()
            .int()
            .optional()
            .transform((v) => v ?? 0),
        created_at: z.number().int().default(nowSec()),
        updated_at: z.number().int().default(nowSec()),
    });
export type MessageCreate = z.input<typeof MessageCreateSchema>;

export const PostSchema = z.object({
    id: z.string(),
    title: z
        .string()
        .transform((s) => s.trim())
        .refine((s) => s.length > 0, 'Title is required'),
    content: z.string().default(''),
    postType: z.string().default('markdown'),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    deleted: z.boolean().default(false),
    meta: z.union([
        z.string(),
        z.object({
            key: z.string(),
            value: z.string().nullable().optional(),
        }),
        z
            .array(
                z.object({
                    key: z.string(),
                    value: z.string().nullable().optional(),
                })
            )
            .nullable()
            .optional(),
    ]),
    file_hashes: z.string().nullable().optional(),
});
export type Post = z.infer<typeof PostSchema>;

export const PostCreateSchema = PostSchema.partial({
    id: true,
    created_at: true,
    updated_at: true,
}).extend({
    id: z
        .string()
        .optional()
        .transform((v) => v ?? newId()),
    created_at: z.number().int().default(nowSec()),
    updated_at: z.number().int().default(nowSec()),
});
export type PostCreate = z.input<typeof PostCreateSchema>;

export const KvSchema = z.object({
    id: z.string(),
    name: z.string(),
    value: z.string().nullable().optional(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    clock: z.number().int(),
});
export type Kv = z.infer<typeof KvSchema>;

export const KvCreateSchema = KvSchema.omit({
    created_at: true,
    updated_at: true,
}).extend({
    created_at: z.number().int().default(nowSec()),
    updated_at: z.number().int().default(nowSec()),
});
export type KvCreate = z.infer<typeof KvCreateSchema>;

export const AttachmentSchema = z.object({
    id: z.string(),
    type: z.string(),
    name: z.string(),
    url: z.url(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    deleted: z.boolean().default(false),
    clock: z.number().int(),
});
export type Attachment = z.infer<typeof AttachmentSchema>;

export const AttachmentCreateSchema = AttachmentSchema.omit({
    created_at: true,
    updated_at: true,
}).extend({
    created_at: z.number().int().default(nowSec()),
    updated_at: z.number().int().default(nowSec()),
});
export type AttachmentCreate = z.infer<typeof AttachmentCreateSchema>;

export const FileMetaSchema = z.object({
    hash: z.string(),
    name: z.string(),
    mime_type: z.string(),
    kind: z.enum(['image', 'pdf']).default('image'),
    size_bytes: z.number().int(),
    width: z.number().int().optional(),
    height: z.number().int().optional(),
    page_count: z.number().int().optional(),
    ref_count: z.number().int().default(0),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    deleted: z.boolean().default(false),
    clock: z.number().int(),
});
export type FileMeta = z.infer<typeof FileMetaSchema>;

export const FileMetaCreateSchema = FileMetaSchema.omit({
    created_at: true,
    updated_at: true,
    ref_count: true,
}).extend({
    created_at: z.number().int().default(nowSec()),
    updated_at: z.number().int().default(nowSec()),
    ref_count: z.number().int().default(1),
    clock: z.number().int().default(0),
});
export type FileMetaCreate = z.infer<typeof FileMetaCreateSchema>;
```

---

## Document store helpers (`app/db/documents.ts`)

| Type                  | Kind      | Description                                                                             |
| --------------------- | --------- | --------------------------------------------------------------------------------------- |
| `DocumentRow`         | interface | Minimal Dexie row projection (id, title, content, timestamps).                          |
| `DocumentRecord`      | interface | Extended record used in composables (includes denormalised helpers like `paneIndex`).   |
| `CreateDocumentInput` | interface | Shape accepted by `createDocument` before schema validation (title, content, metadata). |
| `UpdateDocumentPatch` | interface | Partial update payload (existing record, merged document data, metadata).               |
| `Document`            | alias     | Re-export of `DocumentRecord` for ergonomic imports.                                    |

```ts
// app/db/documents.ts
export interface DocumentRow {
    id: string;
    title: string;
    content: string;
    postType: string;
    created_at: number;
    updated_at: number;
    deleted: boolean;
}

export interface DocumentRecord {
    id: string;
    title: string;
    content: any;
    created_at: number;
    updated_at: number;
    deleted: boolean;
}

export interface CreateDocumentInput {
    title?: string | null;
    content?: any;
}

export interface UpdateDocumentPatch {
    title?: string;
    content?: any;
}

export type Document = DocumentRecord;
```

---

## Prompt store helpers (`app/db/prompts.ts`)

| Type                | Kind      | Description                                                               |
| ------------------- | --------- | ------------------------------------------------------------------------- |
| `PromptRow`         | interface | Dexie row projection (id, name, text, timestamps).                        |
| `PromptRecord`      | interface | Rich record returned by prompt helpers (includes folder/project context). |
| `CreatePromptInput` | interface | Input payload for creating prompts (name, text, optional metadata).       |
| `UpdatePromptPatch` | interface | Patch contract for updating prompts (existing record, updates, metadata). |
| `Prompt`            | alias     | Re-export of `PromptRecord` for ergonomic imports.                        |

```ts
// app/db/prompts.ts
export interface PromptRow {
    id: string;
    title: string;
    content: string;
    postType: string;
    created_at: number;
    updated_at: number;
    deleted: boolean;
}

export interface PromptRecord {
    id: string;
    title: string;
    content: any;
    created_at: number;
    updated_at: number;
    deleted: boolean;
}

export interface CreatePromptInput {
    title?: string | null;
    content?: any;
}

export interface UpdatePromptPatch {
    title?: string;
    content?: any;
}

export type Prompt = PromptRecord;
```

---

## File linking helpers

| Type          | Kind        | Description                                                                                                        |
| ------------- | ----------- | ------------------------------------------------------------------------------------------------------------------ |
| `AddableFile` | union alias | Discriminated union accepted by `addFilesToMessage` (`{ type: 'blob'; blob; name? }` or `{ type: 'hash'; hash }`). |
| `FileBlobRow` | interface   | Underlying Dexie row for the `file_blobs` table (`hash`, `blob`).                                                  |

```ts
// app/db/message-files.ts
export type AddableFile =
    | { type: 'blob'; blob: Blob; name?: string }
    | { type: 'hash'; hash: string };

// app/db/client.ts
export interface FileBlobRow {
    hash: string;
    blob: Blob;
}
```

---

## Operational utilities

| Type        | Kind      | Description                                                                                        |
| ----------- | --------- | -------------------------------------------------------------------------------------------------- | --------------------------------------------------------- |
| `DbTryTags` | interface | Metadata passed to `dbTry` (`op: 'read'                                                            | 'write'`, optional `entity`, arbitrary diagnostics tags). |
| `ForkMode`  | alias     | Re-export of `BranchMode` describing `'reference'` vs `'copy'` branch semantics in `branching.ts`. |

```ts
// app/db/dbTry.ts
export interface DbTryTags {
    readonly op: 'read' | 'write';
    readonly entity?: string;
    readonly [k: string]: any;
}

// app/db/branching.ts
import type { BranchMode } from '../core/hooks/hook-types';
export type ForkMode = BranchMode;
```

These helper types surface the inputs and outputs that higher-level database APIs expose to composables, hooks, and plugins. Keep them in sync with schema or payload changes so consumer code stays type-safe.
</file>

<file path="types/hooks.md">
# Hooks types

Canonical reference for every exported TypeScript type and interface that powers the hook engine. All definitions come from `app/core/hooks/**/*.ts` and are grouped by concern so you can locate payload shapes, key unions, and helper generics quickly.

---

## Engine primitives

| Name              | Kind       | Description                                                                                                                             |
| ----------------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| `HookKind`        | union      | `'action'` or `'filter'`; used to declare hook registration intent.                                                                     |
| `RegisterOptions` | interface  | Common options (`priority`, `acceptedArgs`) shared by action/filter registration helpers.                                               |
| `OnOptions`       | interface  | Extends `RegisterOptions` with optional `kind` to drive the ergonomic `on()` helper.                                                    |
| `HookEngine`      | interface  | Runtime contract implemented by `createHookEngine()`; exposes registration, execution, diagnostics, and lifecycle helpers.              |
| `HookFn`          | type alias | Re-exports the internal `AnyFn` as a convenience import for external `.d.ts` usage.                                                     |
| `TypedHookEngine` | interface  | Purely type-level wrapper returned by `createTypedHookEngine()` exposing fully typed action/filter helpers while delegating at runtime. |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hooks.ts
export type HookKind = 'action' | 'filter';

export interface RegisterOptions {
    priority?: number;
    acceptedArgs?: number;
}

export interface OnOptions extends RegisterOptions {
    kind?: HookKind;
}

export type HookFn = (...args: any[]) => any;

export interface HookEngine {
    addFilter<F extends (...args: any[]) => any>(
        name: string,
        fn: F,
        priority?: number,
        acceptedArgs?: number
    ): void;
    removeFilter<F extends (...args: any[]) => any>(
        name: string,
        fn: F,
        priority?: number
    ): void;
    applyFilters<T>(name: string, value: T, ...args: any[]): Promise<T>;
    applyFiltersSync<T>(name: string, value: T, ...args: any[]): T;

    addAction<F extends (...args: any[]) => any>(
        name: string,
        fn: F,
        priority?: number,
        acceptedArgs?: number
    ): void;
    removeAction<F extends (...args: any[]) => any>(
        name: string,
        fn: F,
        priority?: number
    ): void;
    doAction(name: string, ...args: any[]): Promise<void>;
    doActionSync(name: string, ...args: any[]): void;

    hasFilter(name?: string, fn?: (...args: any[]) => any): boolean | number;
    hasAction(name?: string, fn?: (...args: any[]) => any): boolean | number;
    removeAllCallbacks(priority?: number): void;
    currentPriority(): number | false;

    onceAction(
        name: string,
        fn: (...args: any[]) => any,
        priority?: number
    ): () => void;
    on(name: string, fn: (...args: any[]) => any, opts?: OnOptions): () => void;
    off(disposer: () => void): void;

    _diagnostics: {
        timings: Record<string, number[]>;
        errors: Record<string, number>;
        callbacks(actionOrFilter?: HookKind): number;
    };
}

// Source: app/core/hooks/typed-hooks.ts
type Tail<T extends any[]> = T extends [any, ...infer Rest] ? Rest : [];

export interface TypedHookEngine {
    addAction<K extends ActionHookName>(
        name: K,
        callback: InferHookCallback<K>,
        priority?: number
    ): void;
    removeAction<K extends ActionHookName>(
        name: K,
        callback: InferHookCallback<K>,
        priority?: number
    ): void;
    doAction<K extends ActionHookName>(
        name: K,
        ...args: InferHookParams<K>
    ): Promise<void>;
    doActionSync<K extends ActionHookName>(
        name: K,
        ...args: InferHookParams<K>
    ): void;
    addFilter<K extends FilterHookName>(
        name: K,
        callback: InferHookCallback<K>,
        priority?: number
    ): void;
    removeFilter<K extends FilterHookName>(
        name: K,
        callback: InferHookCallback<K>,
        priority?: number
    ): void;
    applyFilters<K extends FilterHookName>(
        name: K,
        value: InferHookParams<K>[0],
        ...args: Tail<InferHookParams<K>>
    ): Promise<InferHookReturn<K>>;
    applyFiltersSync<K extends FilterHookName>(
        name: K,
        value: InferHookParams<K>[0],
        ...args: Tail<InferHookParams<K>>
    ): InferHookReturn<K>;
    on<K extends HookName>(
        name: K,
        callback: InferHookCallback<K>,
        opts?: OnOptions & {
            kind?: K extends ActionHookName
                ? 'action'
                : K extends FilterHookName
                ? 'filter'
                : 'action' | 'filter';
        }
    ): () => void;
    off(disposer: () => void): void;
    onceAction<K extends ActionHookName>(
        name: K,
        callback: InferHookCallback<K>,
        priority?: number
    ): () => void;
    hasAction<K extends ActionHookName>(
        name?: K,
        fn?: InferHookCallback<K>
    ): boolean | number;
    hasFilter<K extends FilterHookName>(
        name?: K,
        fn?: InferHookCallback<K>
    ): boolean | number;
    removeAllCallbacks(priority?: number): void;
    currentPriority(): number | false;
    readonly _engine: HookEngine;
    readonly _diagnostics: HookEngine['_diagnostics'];
}
```

---

## Key unions and handlers

| Name                       | Kind             | Description                                                                                                                                   |
| -------------------------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| `KnownHookKey`             | union            | Enumerates high-signal hook names (`ui.chat.message:filter:outgoing`, `ai.chat.send:action:before`, …) for first-class editor autocomplete.   |
| `DbFamily`                 | union            | Database table families (`'messages'`, `'documents'`, `'files'`, `'threads'`, `'projects'`, `'posts'`, `'prompts'`, `'attachments'`, `'kv'`). |
| `DbHookKey`                | template literal | Forms `db.${DbFamily}.${string}` for flexible DB hook addressing.                                                                             |
| `HookKey`                  | union            | Final public key type combining `KnownHookKey`, `DbHookKey`, and an open string fallback for plugins.                                         |
| `HookPayloads`             | interface        | Maps each `KnownHookKey` to its listener argument tuple (e.g. `'ui.pane.thread:filter:select'` → `[requestedId, pane, previousId]`).          |
| `ChatOutgoingFilterReturn` | alias            | `string \| false`; standardized return contract for outgoing chat filters.                                                                    |
| `ChatIncomingFilterReturn` | alias            | Always `string`; incoming assistant transforms must emit text.                                                                                |
| `FilesAttachFilterReturn`  | alias            | `FilesAttachInputPayload \| false`; allows file-attach veto from filters.                                                                     |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-keys.ts
export type KnownHookKey =
    | 'ui.chat.message:filter:outgoing'
    | 'ui.chat.message:filter:incoming'
    | 'ai.chat.model:filter:select'
    | 'ai.chat.messages:filter:input'
    | 'ai.chat.send:action:before'
    | 'ai.chat.send:action:after'
    | 'ai.chat.stream:action:delta'
    | 'ai.chat.stream:action:reasoning'
    | 'ai.chat.stream:action:complete'
    | 'ai.chat.stream:action:error'
    | 'ai.chat.retry:action:before'
    | 'ai.chat.retry:action:after'
    | 'ui.pane.active:action'
    | 'ui.pane.blur:action'
    | 'ui.pane.switch:action'
    | 'ui.pane.thread:filter:select'
    | 'ui.pane.thread:action:changed'
    | 'ui.pane.doc:filter:select'
    | 'ui.pane.doc:action:changed'
    | 'ui.pane.doc:action:saved'
    | 'ui.pane.msg:action:sent'
    | 'ui.pane.msg:action:received'
    | 'files.attach:filter:input';

export type DbFamily =
    | 'messages'
    | 'documents'
    | 'files'
    | 'threads'
    | 'projects'
    | 'posts'
    | 'prompts'
    | 'attachments'
    | 'kv';

export type DbHookKey = `db.${DbFamily}.${string}`;

export type HookKey = KnownHookKey | DbHookKey | (string & {});

export interface HookPayloads {
    'ai.chat.send:action:before': [AiSendBeforePayload];
    'ai.chat.send:action:after': [AiSendAfterPayload];
    'ai.chat.stream:action:delta': [string, AiStreamDeltaPayload];
    'ai.chat.stream:action:reasoning': [string, AiStreamReasoningPayload];
    'ai.chat.stream:action:complete': [AiStreamCompletePayload];
    'ai.chat.stream:action:error': [AiStreamErrorPayload];
    'ui.pane.msg:action:sent': [UiPaneMsgSentPayload];
    'ui.pane.msg:action:received': [UiPaneMsgReceivedPayload];
    'ui.pane.active:action': [UiPaneActivePayload];
    'ui.pane.blur:action': [UiPaneBlurPayload];
    'ui.pane.switch:action': [UiPaneSwitchPayload];
    'ui.pane.thread:filter:select': [
        string,
        UiPaneThreadChangedPayload['pane'],
        string
    ];
    'ui.pane.thread:action:changed': [UiPaneThreadChangedPayload];
    'ui.pane.doc:filter:select': [
        string,
        UiPaneDocChangedPayload['pane'],
        string
    ];
    'ui.pane.doc:action:changed': [UiPaneDocChangedPayload];
    'ui.pane.doc:action:saved': [UiPaneDocChangedPayload];
    'ui.chat.message:filter:outgoing': [string];
    'ui.chat.message:filter:incoming': [string, string | undefined];
    'ai.chat.model:filter:select': [string];
    'ai.chat.messages:filter:input': [any[]];
    'files.attach:filter:input': [FilesAttachInputPayload | false];
    'ai.chat.retry:action:before': [AiRetryBeforePayload];
    'ai.chat.retry:action:after': [AiRetryAfterPayload];
}

export type ChatOutgoingFilterReturn = string | false;
export type ChatIncomingFilterReturn = string;
export type FilesAttachFilterReturn = FilesAttachInputPayload | false;
```

---

## AI and chat payloads

| Name                        | Kind      | Description                                                                           |
| --------------------------- | --------- | ------------------------------------------------------------------------------------- |
| `AiSendBeforePayload`       | interface | Context before streaming begins (thread, model, user/assistant metadata).             |
| `AiSendAfterPayloadTimings` | interface | Timing breakdown (`startedAt`, `endedAt`, `durationMs`) attached to send completions. |
| `AiSendAfterPayload`        | interface | Post-send context including request/response summaries, timings, and abort flag.      |
| `AiStreamDeltaContext`      | interface | Token delta context (`threadId`, `assistantId`, lengths, `chunkIndex`).               |
| `AiStreamReasoningContext`  | interface | Reasoning stream metadata (reasoning span length).                                    |
| `AiStreamCompleteContext`   | interface | Final stream state (total length, reasoning length, file hashes).                     |
| `AiStreamErrorContext`      | interface | Error detail for streaming failures or aborts.                                        |
| `AiStreamDeltaPayload`      | alias     | Equal to `AiStreamDeltaContext` for ergonomics.                                       |
| `AiStreamReasoningPayload`  | alias     | Equal to `AiStreamReasoningContext`.                                                  |
| `AiStreamCompletePayload`   | alias     | Equal to `AiStreamCompleteContext`.                                                   |
| `AiStreamErrorPayload`      | alias     | Equal to `AiStreamErrorContext`.                                                      |
| `AiRetryBeforePayload`      | interface | Retry initiation context (original user/assistant IDs, trigger source).               |
| `AiRetryAfterPayload`       | interface | Retry completion context (replacement message IDs, thread).                           |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-types.ts
export interface AiSendBeforePayload {
    threadId?: string;
    modelId: string;
    user: { id: string; length: number };
    assistant: { id: string; streamId: string };
    messagesCount?: number;
}

export interface AiSendAfterPayloadTimings {
    startedAt: number;
    endedAt: number;
    durationMs: number;
}

export interface AiSendAfterPayload {
    threadId?: string;
    request?: { modelId?: string; userId?: string };
    response?: { assistantId?: string; length?: number };
    timings?: AiSendAfterPayloadTimings;
    aborted?: boolean;
}

export interface AiStreamDeltaContext {
    threadId?: string;
    assistantId: string;
    streamId: string;
    deltaLength: number;
    totalLength: number;
    chunkIndex: number;
}

export interface AiStreamReasoningContext {
    threadId?: string;
    assistantId: string;
    streamId: string;
    reasoningLength: number;
}

export interface AiStreamCompleteContext {
    threadId?: string;
    assistantId: string;
    streamId: string;
    totalLength: number;
    reasoningLength?: number;
    fileHashes?: string | null;
}

export interface AiStreamErrorContext {
    threadId?: string;
    streamId?: string;
    error?: unknown;
    aborted?: boolean;
}

export type AiStreamDeltaPayload = AiStreamDeltaContext;
export type AiStreamReasoningPayload = AiStreamReasoningContext;
export type AiStreamCompletePayload = AiStreamCompleteContext;
export type AiStreamErrorPayload = AiStreamErrorContext;

export interface AiRetryBeforePayload {
    threadId?: string;
    originalUserId: string;
    originalAssistantId?: string;
    triggeredBy: 'user' | 'assistant';
}

export interface AiRetryAfterPayload {
    threadId?: string;
    originalUserId: string;
    originalAssistantId?: string;
    newUserId?: string;
    newAssistantId?: string;
}
```

---

## Pane and UI payloads

| Name                         | Kind      | Description                                                            |
| ---------------------------- | --------- | ---------------------------------------------------------------------- | -------------- |
| `UiPaneMsgBase`              | interface | Core shape for pane messages (`id`, `threadId`, lengths, file hashes). |
| `UiPaneMsgReceived`          | interface | Extends `UiPaneMsgBase` with optional `reasoningLength`.               |
| `UiPaneActivePayload`        | interface | Fired when a pane becomes active (`pane`, `index`, `previousIndex`).   |
| `UiPaneBlurPayload`          | interface | Blur event payload capturing previous focus index.                     |
| `UiPaneSwitchPayload`        | interface | Pane switch payload with current and previous indices.                 |
| `UiPaneThreadChangedPayload` | interface | Thread change detail (old/new IDs, pane index, message count).         |
| `UiPaneDocChangedPayload`    | interface | Document change detail (old/new doc IDs, pane index, metadata).        |
| `UiPaneMsgSentPayload`       | interface | Outgoing pane message context including optional `meta`.               |
| `UiPaneMsgReceivedPayload`   | interface | Incoming pane message context including reasoning metadata.            |
| `UiSidebarSelectPayload`     | interface | Sidebar selection event (`kind: 'chat'                                 | 'doc'`, `id`). |
| `UiChatNewPayload`           | interface | Chat creation context (thread ID, creation timestamp).                 |
| `AppInitPayload`             | interface | Nuxt application bootstrap payload (`nuxtApp`).                        |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-types.ts
type PaneState = MultiPaneState;

export interface UiPaneMsgBase {
    id: string;
    threadId?: string;
    length?: number;
    fileHashes?: string | null;
}

export interface UiPaneMsgReceived extends UiPaneMsgBase {
    reasoningLength?: number;
}

export interface UiPaneActivePayload {
    pane: PaneState;
    index: number;
    previousIndex?: number;
}

export interface UiPaneBlurPayload {
    pane: PaneState;
    previousIndex: number;
}

export interface UiPaneSwitchPayload {
    pane: PaneState;
    index: number;
    previousIndex?: number;
}

export interface UiPaneThreadChangedPayload {
    pane: PaneState;
    oldThreadId: string | '';
    newThreadId: string;
    paneIndex: number;
    messageCount?: number;
}

export interface UiPaneDocChangedPayload {
    pane: PaneState;
    oldDocumentId: string | '';
    newDocumentId: string;
    paneIndex: number;
    meta?: Record<string, unknown>;
}

export interface UiPaneMsgSentPayload {
    pane: PaneState;
    paneIndex: number;
    message: UiPaneMsgBase;
    meta?: Record<string, unknown>;
}

export interface UiPaneMsgReceivedPayload {
    pane: PaneState;
    paneIndex: number;
    message: UiPaneMsgReceived;
    meta?: Record<string, unknown>;
}

export interface UiSidebarSelectPayload {
    kind: 'chat' | 'doc';
    id: string;
}

export interface UiChatNewPayload {
    threadId?: string;
    createdAt?: number;
}

export interface AppInitPayload {
    nuxtApp: any;
}
```

---

## Files, uploads, and attachments

| Name                      | Kind      | Description                                                                                       |
| ------------------------- | --------- | ------------------------------------------------------------------------------------------------- |
| `FilesAttachInputPayload` | interface | Filter payload describing a candidate file (`file`, `name`, `mime`, `size`, `kind`).              |
| `FilesAttachPayload`      | interface | Extends `FilesAttachInputPayload` with persistence metadata (`accepted`, optional `url`, `hash`). |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-types.ts
export interface FilesAttachInputPayload {
    file: File;
    name: string;
    mime: string;
    size: number;
    kind: 'image' | 'pdf';
}

export interface FilesAttachPayload extends FilesAttachInputPayload {
    accepted: boolean;
    url?: string;
    hash?: string;
}
```

---

## Branching and context utilities

| Name                        | Kind      | Description                                                                        |
| --------------------------- | --------- | ---------------------------------------------------------------------------------- |
| `BranchMode`                | alias     | `'reference'` or `'copy'` branch semantics.                                        |
| `BranchForkOptions`         | interface | Input parameters when forking threads (source IDs, mode, optional title override). |
| `BranchForkBeforePayload`   | interface | Pre-fork payload used by hooks (`source`, `anchor`, `mode`, optional `options`).   |
| `BranchContextAfterPayload` | interface | Post-branch context summary (thread counts, mode).                                 |
| `KvUpsertByNameInput`       | interface | Convenience payload for KV upserts by `name`.                                      |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-types.ts
export type BranchMode = 'reference' | 'copy';

export interface BranchForkOptions {
    sourceThreadId: string;
    anchorMessageId: string;
    mode?: BranchMode;
    titleOverride?: string;
}

export interface BranchForkBeforePayload {
    source: ThreadEntity;
    anchor: MessageEntity;
    mode: BranchMode;
    options?: { titleOverride?: string };
}

export interface BranchContextAfterPayload {
    threadId: string;
    mode: BranchMode;
    ancestorCount: number;
    localCount: number;
    finalCount: number;
}

export interface KvUpsertByNameInput {
    name: string;
    value: any;
}
```

---

## Entity mirrors and DB payload wrappers

| Name                 | Kind      | Description                                                                                |
| -------------------- | --------- | ------------------------------------------------------------------------------------------ |
| `MessageEntity`      | interface | Hook-friendly projection of a message row (`id`, `thread_id`, `role`, `data`, timestamps). |
| `ThreadEntity`       | interface | Thread metadata consumed by hooks (status, branching info, clock).                         |
| `DocumentEntity`     | interface | Document metadata for hooks (title, content, timestamps).                                  |
| `FileEntity`         | interface | File metadata (`hash`, `name`, `mime`, `size`, reference count).                           |
| `ProjectEntity`      | interface | Project record summary (name, description, clock flags).                                   |
| `PostEntity`         | interface | Lightweight post/blog record.                                                              |
| `PromptEntity`       | interface | Prompt data (`id`, `name`, `text`).                                                        |
| `AttachmentEntity`   | interface | Attachment record linking messages to files.                                               |
| `KvEntry`            | interface | Key-value store record (name/value, clocks, timestamps).                                   |
| `DbCreatePayload<T>` | interface | Generic wrapper emitted before/after `create` operations (`entity`, `tableName`).          |
| `DbUpdatePayload<T>` | interface | Wrapper for update lifecycle (existing, updated, patch, table).                            |
| `DbDeletePayload<T>` | interface | Wrapper for delete lifecycle (entity, id, table).                                          |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-types.ts
export interface MessageEntity {
    id: string;
    thread_id: string;
    role: 'user' | 'assistant' | 'system';
    data: any;
    index: number;
    created_at: number;
    updated_at?: number;
}

export interface ThreadEntity {
    id: string;
    title?: string | null;
    created_at: number;
    updated_at: number;
    last_message_at?: number | null;
    parent_thread_id?: string | null;
    anchor_message_id?: string | null;
    anchor_index?: number | null;
    branch_mode?: 'reference' | 'copy' | null;
    status: string;
    deleted: boolean;
    pinned: boolean;
    clock: number;
    forked: boolean;
    project_id?: string | null;
    system_prompt_id?: string | null;
}

export interface DocumentEntity {
    id: string;
    title?: string;
    content?: string;
    created_at?: number;
    updated_at?: number;
}

export interface FileEntity {
    hash: string;
    name: string;
    mime: string;
    size: number;
    ref_count?: number;
}

export interface ProjectEntity {
    id: string;
    name: string;
    description?: string | null;
    data: any;
    created_at: number;
    updated_at: number;
    deleted: boolean;
    clock: number;
}

export interface PostEntity {
    id: string;
    title?: string;
    body?: string;
    created_at?: number;
    updated_at?: number;
}

export interface PromptEntity {
    id: string;
    name: string;
    text: string;
}

export interface AttachmentEntity {
    id: string;
    message_id?: string;
    file_hash?: string;
}

export interface KvEntry {
    id: string;
    name: string;
    value?: string | null;
    created_at: number;
    updated_at: number;
    clock: number;
}

export interface DbCreatePayload<T = any> {
    entity: T;
    tableName: string;
}

export interface DbUpdatePayload<T = any> {
    existing: T;
    updated: T;
    patch: Partial<T>;
    tableName: string;
}

export interface DbDeletePayload<T = any> {
    entity: T;
    id: string;
    tableName: string;
}
```

---

## Hook name families and DB literals

| Name                      | Kind             | Description                                                                                               |
| ------------------------- | ---------------- | --------------------------------------------------------------------------------------------------------- |
| `DbEntityName`            | union            | Valid entity literals for DB hooks (`'messages'`, `'threads'`, …).                                        |
| `DbOperation`             | union            | Supported DB operations (`'create'`, `'update'`, `'delete'`, `'get'`, `'search'`, `'normalize'`, etc.).   |
| `DbPhase`                 | union            | `'before'` or `'after'` lifecycle for action hooks.                                                       |
| `DbDeleteType`            | union            | Distinguishes `'soft'` vs `'hard'` delete hooks.                                                          |
| `DbActionHookName`        | template literal | Enumerates action hook naming convention across DB families (`db.posts.delete:action:soft:before`, etc.). |
| `DbFilterHookName`        | template literal | Enumerates filter hook naming convention (`db.messages.create:filter:input`, etc.).                       |
| `CoreActionHookName`      | conditional      | Extracts built-in action hook keys from `CoreHookPayloadMap`.                                             |
| `ExtensionActionHookName` | alias            | `keyof Or3ActionHooks`; supports module augmentation.                                                     |
| `ActionHookName`          | union            | Combines core and extension action hook names.                                                            |
| `CoreFilterHookName`      | conditional      | Extracts built-in filter hook keys from `CoreHookPayloadMap`.                                             |
| `ExtensionFilterHookName` | alias            | `keyof Or3FilterHooks`; extension hook keys.                                                              |
| `FilterHookName`          | union            | Combines core and extension filter names.                                                                 |
| `HookName`                | union            | Full set of action + filter names.                                                                        |

---

## Payload maps and inference helpers

| Name                              | Kind          | Description                                                                                       |
| --------------------------------- | ------------- | ------------------------------------------------------------------------------------------------- |
| `CoreHookPayloadMap`              | mapped type   | Master mapping from built-in hook names to argument tuples; foundation for inference.             |
| `HookPayloadMap`                  | intersection  | `CoreHookPayloadMap` combined with developer augmentations via `Or3ActionHooks`/`Or3FilterHooks`. |
| `InferHookParams<K>`              | conditional   | Resolves the argument tuple for hook name `K`.                                                    |
| `InferHookReturn<K>`              | conditional   | Infers the expected return type for hook `K` (void for actions, chained value for filters).       |
| `InferHookCallback<K>`            | function type | Convenience signature for callbacks keyed by `K`.                                                 |
| `IsAction<K>`                     | conditional   | Type predicate that narrows `true` when `K` is an action hook.                                    |
| `IsFilter<K>`                     | conditional   | Type predicate for filter hook names.                                                             |
| `ExtractHookPayload<K>`           | conditional   | Pulls the payload tuple for hook `K`.                                                             |
| `MatchingHooks<Pattern>`          | conditional   | Extracts hook names that match a template literal pattern.                                        |
| `InferDbEntity<K>`                | conditional   | Infers the DB entity type represented by a hook key (e.g. `db.messages.*`).                       |
| `Tail<T>`                         | alias         | Removes the first element from a tuple (`T extends [any, ...infer Rest] ? Rest : []`).            |
| `SuggestSimilar<K>`               | conditional   | Produces human-readable suggestions for invalid hook keys during type checking.                   |
| `ValidateHookName<K>`             | conditional   | Emits helpful diagnostics when a hook name is invalid.                                            |
| `TypeName<T>`                     | conditional   | Friendly string literal describing the TypeScript type `T`.                                       |
| `CallbackMismatch<Expected, Got>` | conditional   | Diagnostic helper that compares expected vs actual callback signatures.                           |

---

## Usage notes

-   The hook engine exposes runtime APIs via `HookEngine` while `TypedHookEngine` wraps them for inference. Use `useHooks()` to obtain the typed variant.
-   When adding new hook keys, update `HookPayloads` and the relevant payload interfaces so documentation and inference stay aligned.
-   Generics like `InferHookParams` and `MatchingHooks` power helper utilities and schema validation—reference them when building tooling around the hook system.
</file>

<file path="repomix-output.md">
This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: README.md, docmap.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
composables/
  useActivePrompt.md
  useAiSettings.md
  useChat.md
  useChatInputBridge.md
  useComposerActions.md
  useDashboardPlugins.md
  useDefaultPrompt.md
  useDocumentHistoryActions.md
  useDocumentsList.md
  useDocumentsStore.md
  useEditorNodes.md
  useEditorToolbar.md
  useHeaderActions.md
  useHookEffect.md
  useMessageActions.md
  useMessageEditing.md
  useModelStore.md
  useMultiPane.md
  usePaneDocuments.md
  usePanePrompt.md
  usePreviewCache.md
  useProjectsCrud.md
  useProjectTreeActions.md
  useSidebarSearch.md
  useSidebarSections.md
  useStreamAccumulator.md
  useThreadHistoryActions.md
  useThreadSearch.md
  useWorkspaceBackup.md
database/
  attachments.md
  branching.md
  client.md
  dbTry.md
  documents.md
  files-select.md
  files-util.md
  files.md
  index.md
  kv.md
  message-files.md
  messages.md
  posts.md
  projects.md
  prompts.md
  schema.md
  threads.md
  util.md
hooks/
  hook-catalog.md
  hook-keys.md
  hook-types.md
  hooks.md
  typed-hooks.md
  useHooks.md
types/
  composables.md
  database.md
  hooks.md
```

# Files

## File: composables/useActivePrompt.md
````markdown
# useActivePrompt

Reactive composable that manages the currently selected system prompt for chat conversations.

This composable provides a module-singleton selection state (id + content) so multiple components
and composables can read the active system prompt consistently without creating duplicate refs.

It integrates with the local prompt database (`~/db/prompts`) to load prompt content and emits a
hook event after a prompt is selected so other subsystems can react.

---

## Features

-   Shared, readonly reactive `activePromptId` and `activePromptContent` that are visible across
    all consumers in the same Vite/SSR process (module-singleton pattern).
-   `setActivePrompt(id)` loads the prompt from the DB and updates the shared state.
-   Calls the hooks engine: `chat.systemPrompt.select:action:after` with the selected id/content.
-   `clearActivePrompt()` resets the selection to `null`.

---

## Installation

No installation required — the composable is part of the app and can be imported directly:

```ts
import { useActivePrompt } from '~/composables/chat/useActivePrompt';
```

---

## Usage

Basic usage in a component:

```vue
<script setup lang="ts">
import { watch } from 'vue';
import { useActivePrompt } from '~/composables/chat/useActivePrompt';

const {
    activePromptId,
    activePromptContent,
    setActivePrompt,
    clearActivePrompt,
} = useActivePrompt();

// react to changes
watch(activePromptId, (id) => {
    console.log('Active prompt id changed:', id);
});

// select a prompt by id (async)
async function select(id: string) {
    await setActivePrompt(id);
}

// clear selection
function clear() {
    clearActivePrompt();
}
</script>
```

### Example: use in a send-flow

When sending a message you can include the active system prompt like this:

```ts
const { getActivePromptContent } = useActivePrompt();
const systemPrompt = getActivePromptContent();
// attach systemPrompt to the outgoing message payload if present
```

Note: `getActivePromptContent()` returns the raw content value (or `null`) and is synchronous.

---

## API

-   activePromptId: Readonly<Ref<string | null>> — readonly reactive id of the selected prompt.
-   activePromptContent: Readonly<Ref<any | null>> — readonly reactive prompt content loaded from DB.
-   setActivePrompt(id: string | null): Promise<void> — set selection. Passing `null` clears. If the
    id is not found the selection will be cleared.
-   clearActivePrompt(): void — convenience that clears the selection (calls `setActivePrompt(null)`).
-   getActivePromptContent(): any | null — synchronous getter returning the raw content value.

---

## Types

The composable exposes the following TypeScript shape (approx):

```ts
export interface ActivePromptState {
    activePromptId: string | null;
    activePromptContent: any | null;
}

function useActivePrompt(): {
    activePromptId: Readonly<Ref<string | null>>;
    activePromptContent: Readonly<Ref<any | null>>;
    setActivePrompt(id: string | null): Promise<void>;
    clearActivePrompt(): void;
    getActivePromptContent(): any | null;
};
```

---

## Internals & Notes

-   Module-singleton: the composable uses module-scoped `ref`s so every import/consumer shares the
    same state. This is intentional to keep selection consistent across UI components.
-   `setActivePrompt` is asynchronous and will call `getPrompt(id)` from `~/db/prompts`.
-   After a successful selection the composable dispatches a hook action using the app hooks
    engine: `hooks.doAction('chat.systemPrompt.select:action:after', { id, content })`.
-   If the requested prompt id does not exist the composable clears the active selection.
-   Concurrency: callers should await `setActivePrompt` if they depend on the state being updated
    immediately; multiple concurrent calls may race and the last-resolved call wins.
-   Do not mutate `activePromptContent` or `activePromptId` directly — use the provided methods.

### SSR / Client considerations

-   The composable relies on the DB helper `getPrompt` which is typically a client-side data source
    (Dexie/IndexedDB). Avoid calling `setActivePrompt` during server-side rendering. Reading the
    readonly refs is safe but may initially be `null` on the server.

---

## Related

-   `~/db/prompts` — prompt storage and retrieval used by `setActivePrompt`
-   hooks engine — event emitted: `chat.systemPrompt.select:action:after`

---

## Example (full)

```vue
<template>
    <div>
        <div v-if="activePromptContent">Active: {{ activePromptId }}</div>
        <button @click="select('builtin:short_instruct')">
            Select built-in
        </button>
        <button @click="clear">Clear</button>
    </div>
</template>

<script setup lang="ts">
import { useActivePrompt } from '~/composables/chat/useActivePrompt';

const {
    activePromptId,
    activePromptContent,
    setActivePrompt,
    clearActivePrompt,
} = useActivePrompt();

function select(id: string) {
    setActivePrompt(id);
}
function clear() {
    clearActivePrompt();
}

// exported to template
const activePrompt = { activePromptId, activePromptContent, select, clear };
</script>
```

---

Document generated from `app/composables/chat/useActivePrompt.ts` implementation.
````

## File: composables/useAiSettings.md
````markdown
# useAiSettings

Persistence layer for AI preference knobs. Keeps the chat experience consistent by storing master prompts and model defaults in browser storage, while exposing a clean interface for UI controls or automated scripts.

---

## What it covers

`useAiSettings` gives you a reactive settings object and helper methods to read, update, and reset AI chat preferences. It sanitises input, survives hot-module reloads, and only touches storage in the browser.

-   Tracks the current settings in a single global store (HMR-safe)
-   Loads initial values from `localStorage` once per session
-   Persists updates automatically
-   Normalises user input to avoid bad types or unknown keys

---

## Quick start

```ts
import { useAiSettings } from '~/composables/chat/useAiSettings';

const { settings, set } = useAiSettings();

watchEffect(() => {
    console.log('Current default mode:', settings.value.defaultModelMode);
});

set({ defaultModelMode: 'fixed', fixedModelId: 'anthropic/claude-3-sonnet' });
```

---

## API

| Property     | Type                                     | Purpose                                                                      |
| ------------ | ---------------------------------------- | ---------------------------------------------------------------------------- |
| `settings`   | `ComputedRef<AiSettingsV1>`              | Reactive snapshot of the current settings.                                   |
| `set(patch)` | `(patch: Partial<AiSettingsV1>) => void` | Merge in new values, sanitise them, persist to storage.                      |
| `reset()`    | `() => void`                             | Restore defaults and persist them.                                           |
| `load()`     | `() => AiSettingsV1`                     | Re-read from storage, update the reactive store, and return the fresh value. |

### `AiSettingsV1`

```ts
interface AiSettingsV1 {
    version: 1;
    masterSystemPrompt: string;
    defaultModelMode: 'lastSelected' | 'fixed';
    fixedModelId: string | null;
}
```

Defaults:

```ts
const DEFAULT_AI_SETTINGS: AiSettingsV1 = {
    version: 1,
    masterSystemPrompt: '',
    defaultModelMode: 'lastSelected',
    fixedModelId: null,
};
```

---

## How to use it

### Drive a settings form

```vue
<template>
    <form class="space-y-4" @submit.prevent="save">
        <label class="block">
            <span>Master system prompt</span>
            <textarea v-model="prompt" class="retro-input" rows="3" />
        </label>

        <label class="block">
            <span>Default model mode</span>
            <select v-model="mode" class="retro-input">
                <option value="lastSelected">Remember last model</option>
                <option value="fixed">Always use a specific model</option>
            </select>
        </label>

        <label v-if="mode === 'fixed'" class="block">
            <span>Model ID</span>
            <input v-model="modelId" class="retro-input" />
        </label>

        <button type="submit" class="retro-btn">Save</button>
    </form>
</template>

<script setup lang="ts">
import { computed, ref, watch } from 'vue';
import { useAiSettings } from '~/composables/chat/useAiSettings';

const { settings, set } = useAiSettings();

const prompt = ref(settings.value.masterSystemPrompt);
const mode = ref(settings.value.defaultModelMode);
const modelId = ref(settings.value.fixedModelId ?? '');

watch(settings, (next) => {
    prompt.value = next.masterSystemPrompt;
    mode.value = next.defaultModelMode;
    modelId.value = next.fixedModelId ?? '';
});

function save() {
    set({
        masterSystemPrompt: prompt.value,
        defaultModelMode: mode.value,
        fixedModelId: mode.value === 'fixed' ? modelId.value || null : null,
    });
}
</script>
```

### Reset to defaults

```ts
const { reset } = useAiSettings();

reset();
```

### Hard refresh from storage

```ts
const { load } = useAiSettings();

const latest = load();
console.log('Reloaded settings', latest);
```

---

## Internal mechanics

1. **Singleton store**: A global object placed on `globalThis` survives HMR and ensures only one reactive store. The store holds `{ settings: Ref<AiSettingsV1>, loaded: boolean }`.
2. **Lazy hydration**: On first call in the browser, `loadFromStorage()` runs. Server contexts keep defaults because `window`/`document` are missing.
3. **Sanitisation**: `sanitizeAiSettings()` strips unknown keys, forces `defaultModelMode` to the allowed union, and normalises `fixedModelId`.
4. **Persistence**: `set` immediately writes to storage. A deep `watch` also saves direct mutations made outside of `set` for compatibility.
5. **Safety**: All storage access is wrapped in try/catch with console warnings in dev mode to avoid breaking the app when storage is unavailable.

---

## Edge cases & tips

-   **SSR**: Guarded by `isBrowser()` so storage isn’t touched during server rendering.
-   **Storage quota**: Failures fall back to logging a warning; settings stay in memory for the session.
-   **HMR**: Because the store lives on `globalThis`, you can tweak the composable without losing user-configured settings while the dev server is running.
-   **Direct mutations**: Prefer `set`, but the deep watch ensures manual changes like `settings.value.masterSystemPrompt = '...'` still persist.

---

## Related references

-   `useChat` — respects the defaults defined here.
-   `useAiSettingsPanel` (if present) — typical consumer for user-facing UI.
-   `AI_SETTINGS_STORAGE_KEY` — storage key constant if you need to inspect it manually.
````

## File: composables/useChat.md
````markdown
# useChat

The main composable for managing AI chat conversations in OR3. Handles sending messages, streaming responses, retrying failed messages, and managing conversation state.

Think of `useChat` as your chat conversation manager — it keeps track of all messages, talks to the AI, and handles everything from loading states to error recovery.

---

## What does it do?

`useChat` is the heart of every chat conversation. When you want to:

- Send a message to an AI model
- Display a conversation with streaming responses
- Retry a failed message
- Show loading states while the AI is thinking
- Cancel an ongoing AI response

...this composable handles all of that for you.

---

## Basic Example

Here's the simplest way to use it:

```vue
<script setup>
import { useChat } from '~/composables/chat/useAi';

// Create a new chat
const chat = useChat();

// Send a message
async function ask() {
  await chat.sendMessage('Hello, how are you?');
}
</script>

<template>
  <div>
    <!-- Show all messages -->
    <div v-for="msg in chat.messages.value" :key="msg.id">
      <strong>{{ msg.role }}:</strong> {{ msg.text }}
    </div>

    <!-- Show loading state -->
    <div v-if="chat.loading.value">AI is thinking...</div>

    <!-- Send button -->
    <button @click="ask" :disabled="chat.loading.value">
      Send Message
    </button>
  </div>
</template>
```

---

## How to use it

### 1. Create a chat instance

```ts
// Start a new conversation
const chat = useChat();

// Or continue an existing thread
const chat = useChat(existingMessages, 'thread-id-123');

// Or with a pending system prompt
const chat = useChat([], undefined, 'prompt-id-456');
```

### 2. Send messages

```ts
// Simple text message
await chat.sendMessage('What is the weather like?');

// Message with images/files
await chat.sendMessage('Describe this image', {
  files: [{ type: 'image/png', url: 'https://...' }],
  model: 'openai/gpt-4-vision',
  online: false
});

// Message with file attachments (by hash)
await chat.sendMessage('Analyze these files', {
  file_hashes: ['abc123', 'def456'],
  model: 'anthropic/claude-3-sonnet'
});
```

### 3. Handle the response

The AI response appears in two places:

- **During streaming**: `chat.tailAssistant.value` shows the message being written
- **After complete**: The message moves to `chat.messages.value`

```vue
<template>
  <!-- Show completed messages -->
  <div v-for="msg in chat.messages.value" :key="msg.id">
    {{ msg.text }}
  </div>

  <!-- Show streaming message (being written right now) -->
  <div v-if="chat.tailAssistant.value" class="streaming">
    {{ chat.tailAssistant.value.text }}
    <span v-if="chat.tailAssistant.value.pending">▋</span>
  </div>
</template>
```

### 4. Retry failed messages

If a message fails, you can retry it:

```ts
// Retry with the same model
await chat.retryMessage(failedMessageId);

// Retry with a different model
await chat.retryMessage(failedMessageId, 'anthropic/claude-3-opus');
```

### 5. Cancel ongoing responses

```ts
// Stop the AI mid-response
chat.abort();
```

### 6. Clear everything

```ts
// Remove all messages and reset state
chat.clear();
```

---

## What you get back

When you call `useChat()`, you get an object with:

| Property | Type | Description |
|----------|------|-------------|
| `messages` | `Ref<UiChatMessage[]>` | All finalized messages in the conversation |
| `loading` | `Ref<boolean>` | `true` while waiting for AI response |
| `threadId` | `Ref<string \| undefined>` | The database thread ID for this conversation |
| `streamId` | `Ref<string \| undefined>` | Current streaming message ID |
| `streamState` | `object` | Stream status: `{ active, finalized, error, aborted }` |
| `tailAssistant` | `Ref<UiChatMessage \| null>` | The AI message currently being streamed (not in `messages` yet) |
| `sendMessage` | `function` | Send a new user message |
| `retryMessage` | `function` | Retry a failed message |
| `abort` | `function` | Cancel the current AI response |
| `clear` | `function` | Clear all messages |
| `resetStream` | `function` | Reset stream state (usually automatic) |
| `flushTailAssistant` | `function` | Move `tailAssistant` into `messages` (usually automatic) |

---

## Message format

### UiChatMessage

This is what you see in `messages.value` and `tailAssistant.value`:

```ts
interface UiChatMessage {
  id: string;                    // unique message ID
  role: 'user' | 'assistant' | 'system';
  text: string;                  // the actual message text
  file_hashes?: string[];        // attached file references
  reasoning_text?: string;       // AI's reasoning (if model supports it)
  stream_id?: string;            // for tracking streaming messages
  pending?: boolean;             // true while streaming
}
```

### SendMessageParams

Optional parameters when sending a message:

```ts
interface SendMessageParams {
  files?: { type: string; url: string }[];  // images or files to attach
  model?: string;                           // AI model to use (e.g., 'openai/gpt-4')
  file_hashes?: string[];                   // reference existing files by hash
  extraTextParts?: string[];                // additional text segments
  online: boolean;                          // enable web search (adds ':online' suffix)
}
```

---

## How it works (under the hood)

Here's what happens when you send a message:

1. **Check API key**: Won't send without OpenRouter API key
2. **Apply filters**: Runs `ui.chat.message:filter:outgoing` hook (can block message)
3. **Create thread**: If this is the first message, creates a new thread in the database
4. **Load system prompt**: Fetches the active system prompt for context
5. **Add user message**: Saves your message to the database and updates `messages.value`
6. **Prepare AI request**: 
   - Builds conversation history
   - Removes empty assistant messages (API requirement)
   - Converts to OpenRouter format
   - Applies image limit (5 images max to avoid rate limits)
7. **Start streaming**: Opens a stream to OpenRouter API
8. **Process chunks**: As AI responds:
   - Text chunks update `tailAssistant.value.text`
   - Generated images get saved and attached
   - Reasoning text (if supported) goes into `reasoning_text`
   - Progress saved to DB every 500ms
9. **Apply incoming filter**: Runs `ui.chat.message:filter:incoming` hook
10. **Finalize**: Saves complete message to DB and emits completion hooks

If anything fails, the error is caught and you can retry.

---

## Common patterns

### Check if chat is ready

```ts
if (chat.loading.value) {
  console.log('Please wait, AI is responding...');
}
```

### Show streaming indicator

```vue
<div v-if="chat.tailAssistant.value?.pending">
  AI is typing<span class="dots">...</span>
</div>
```

### Handle retry button

```vue
<button 
  v-if="message.error" 
  @click="chat.retryMessage(message.id)"
>
  Retry
</button>
```

### Cancel long responses

```vue
<button 
  v-if="chat.loading.value" 
  @click="chat.abort"
  class="danger"
>
  Stop Generating
</button>
```

### Multi-model support

```ts
// Let user pick model
const selectedModel = ref('anthropic/claude-3-sonnet');

await chat.sendMessage(userInput, {
  model: selectedModel.value,
  online: false
});
```

### Attach images

```ts
// From file input
const fileUrl = URL.createObjectURL(file);
await chat.sendMessage('What is this?', {
  files: [{ type: file.type, url: fileUrl }],
  model: 'openai/gpt-4-vision'
});
```

---

## Important notes

### Memory management

- `messages.value` contains finalized messages only
- `tailAssistant.value` holds the message currently being streamed
- When you send a new message, `tailAssistant` automatically moves to `messages`
- Call `clear()` to free memory if the conversation gets very long

### Thread creation

If you don't provide a `threadId`, the first `sendMessage` creates one automatically:
- Title: first 6 words of your message
- System prompt: uses pending prompt or default
- Timestamp: set to now

### Retry behavior

When you retry a message:
1. Finds the user message and its assistant response
2. Deletes both from database and memory
3. Re-sends with original text and attachments
4. Creates new message IDs

### Hooks integration

The composable emits several hook events you can listen to:

- `ui.chat.message:filter:outgoing` — before sending (can veto)
- `ui.chat.message:filter:incoming` — after receiving (can transform)
- `ai.chat.model:filter:select` — choose/override model
- `ai.chat.messages:filter:input` — modify conversation history
- `ai.chat.send:action:before` — before AI call
- `ai.chat.send:action:after` — after completion/abort
- `ai.chat.stream:action:complete` — stream finished
- `ai.chat.stream:action:error` — stream error
- `ai.chat.retry:action:before` — before retry
- `ai.chat.retry:action:after` — after retry
- `ui.pane.msg:action:sent` — multi-pane message sent
- `ui.pane.msg:action:received` — multi-pane message received

### Image handling

- User images: displayed in attachments gallery (not embedded in text)
- AI-generated images: embedded as markdown `![image](url)` in message text
- Image limit: Max 5 images per request (automatically trimmed)
- Previous assistant images are carried forward in conversation

### Model selection

If you don't specify a model, it uses:
1. Last selected model (from localStorage)
2. Fixed model (from settings)
3. Fallback: `openai/gpt-oss-120b`

### Online mode

Add `:online` suffix to enable web search:
```ts
await chat.sendMessage('Latest news?', {
  model: 'anthropic/claude-3-sonnet',
  online: true  // becomes 'anthropic/claude-3-sonnet:online'
});
```

---

## Troubleshooting

### "Message blocked"
Your message was filtered by an outgoing hook. Check hook extensions.

### Empty responses
Check if API key is valid and model is available.

### Stream errors
Usually network issues or invalid API responses. Retry should work.

### Memory issues with long conversations
Call `clear()` or create a new chat instance for fresh conversation.

### Images not showing
- User images: Check `file_hashes` are valid
- AI images: Must use vision-capable model

---

## Related

- `useActivePrompt` — manage system prompts
- `useUserApiKey` — OpenRouter API key management
- `useAiSettings` — model preferences and master system prompt
- `useModelStore` — available models catalog
- `~/db/messages` — direct database access
- `~/db/threads` — thread management

---

## TypeScript

Full type signature:

```ts
function useChat(
  msgs?: ChatMessage[],
  initialThreadId?: string,
  pendingPromptId?: string
): {
  messages: Ref<UiChatMessage[]>;
  loading: Ref<boolean>;
  threadId: Ref<string | undefined>;
  streamId: Ref<string | undefined>;
  streamState: {
    active: Ref<boolean>;
    finalized: Ref<boolean>;
    error: Ref<Error | null>;
    aborted: Ref<boolean>;
  };
  tailAssistant: Ref<UiChatMessage | null>;
  sendMessage: (content: string, params?: SendMessageParams) => Promise<void>;
  retryMessage: (messageId: string, modelOverride?: string) => Promise<void>;
  abort: () => void;
  clear: () => void;
  resetStream: () => void;
  flushTailAssistant: () => void;
}
```

---

## Example: Full chat component

```vue
<template>
  <div class="chat-container">
    <!-- Message list -->
    <div class="messages">
      <div 
        v-for="msg in chat.messages.value" 
        :key="msg.id"
        :class="`message message-${msg.role}`"
      >
        <div class="role">{{ msg.role }}</div>
        <div class="text">{{ msg.text }}</div>
        <button 
          v-if="msg.role === 'assistant'" 
          @click="retry(msg.id)"
          class="retry-btn"
        >
          ↻ Retry
        </button>
      </div>

      <!-- Streaming message -->
      <div 
        v-if="chat.tailAssistant.value" 
        class="message message-assistant streaming"
      >
        <div class="role">assistant</div>
        <div class="text">
          {{ chat.tailAssistant.value.text }}
          <span v-if="chat.tailAssistant.value.pending" class="cursor">▋</span>
        </div>
      </div>
    </div>

    <!-- Input area -->
    <div class="input-area">
      <textarea 
        v-model="input" 
        @keydown.enter.meta="send"
        :disabled="chat.loading.value"
        placeholder="Type your message..."
      />
      <button 
        v-if="!chat.loading.value"
        @click="send"
        :disabled="!input.trim()"
      >
        Send
      </button>
      <button 
        v-else
        @click="chat.abort()"
        class="stop-btn"
      >
        Stop
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { useChat } from '~/composables/chat/useAi';

const chat = useChat();
const input = ref('');

async function send() {
  if (!input.value.trim()) return;
  const text = input.value;
  input.value = '';
  await chat.sendMessage(text);
}

async function retry(messageId: string) {
  await chat.retryMessage(messageId);
}
</script>

<style scoped>
.chat-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

.messages {
  flex: 1;
  overflow-y: auto;
  padding: 1rem;
}

.message {
  margin-bottom: 1rem;
  padding: 0.5rem;
  border-radius: 4px;
}

.message-user {
  background: #e3f2fd;
  margin-left: 20%;
}

.message-assistant {
  background: #f5f5f5;
  margin-right: 20%;
}

.streaming .cursor {
  animation: blink 1s infinite;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

.input-area {
  display: flex;
  gap: 0.5rem;
  padding: 1rem;
  border-top: 1px solid #ddd;
}

textarea {
  flex: 1;
  padding: 0.5rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  resize: none;
  font-family: inherit;
}

button {
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 4px;
  background: #2196f3;
  color: white;
  cursor: pointer;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.stop-btn {
  background: #f44336;
}

.retry-btn {
  margin-top: 0.5rem;
  font-size: 0.875rem;
  background: #757575;
}
</style>
```

---

Document generated from `app/composables/chat/useAi.ts` implementation.
````

## File: composables/useChatInputBridge.md
````markdown
# useChatInputBridge

Lightweight registry that lets external features (pane plugins, slash commands, automation) inject chat messages into an existing chat input without duplicating business logic.

---

## Why it exists

`useChatInputBridge` exposes a tiny, reactive directory of chat inputs keyed by `paneId`. Chat containers register their imperative API and the bridge forwards programmatic sends through the same UI pipeline a user click would trigger.

-   Keeps message handling inside `ChatInputDropper`
-   Avoids rehydrating chat state or bypassing hooks
-   Supports multiple panes/windows
-   Safe in dev (HMR-resilient)

---

## Surface area

| Function              | Signature                                               | Purpose                                                                                                    |
| --------------------- | ------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| `registerPaneInput`   | `(paneId: string, api: ChatInputImperativeApi) => void` | Register or update the imperative API for a pane. Called by the chat input component on mount/HMR.         |
| `unregisterPaneInput` | `(paneId: string) => void`                              | Remove the pane entry on unmount.                                                                          |
| `programmaticSend`    | `(paneId: string, text: string) => boolean`             | Push text into the pane input and trigger its native send handler. Returns `false` if the pane is missing. |
| `hasPane`             | `(paneId: string) => boolean`                           | Test whether a pane is currently registered.                                                               |

### `ChatInputImperativeApi`

```ts
interface ChatInputImperativeApi {
    setText(t: string): void;
    triggerSend(): void;
}
```

---

## Typical usage

### Registering inside a chat pane

```ts
import { onMounted, onUnmounted } from 'vue';
import {
    registerPaneInput,
    unregisterPaneInput,
} from '~/composables/chat/useChatInputBridge';

const paneId = usePaneId();

onMounted(() => {
    registerPaneInput(paneId, {
        setText: (value) => (messageInput.value = value),
        triggerSend: () => sendMessage(),
    });
});

onUnmounted(() => {
    unregisterPaneInput(paneId);
});
```

### Sending from an external plugin

```ts
import { programmaticSend } from '~/composables/chat/useChatInputBridge';

const success = programmaticSend(activePaneId, '/imagine neon city at dusk');

if (!success) {
    console.warn('Pane not ready yet');
}
```

---

## Implementation notes

1. **Registry** — Maintains a `Ref<RegisteredPaneInput[]>`. Lookup happens through the helper `find(paneId)` to keep the public API concise.
2. **Updates** — Re-registering the same pane ID replaces the stored API so HMR or re-renders don’t stack duplicates.
3. **Error handling** — `programmaticSend` wraps calls in `try/catch`; errors log in dev mode and return `false` so callers can retry or surface UI feedback.
4. **Debug hook** — In dev, the registry is exposed on `globalThis.__or3ChatInputBridge` for console inspection.
5. **No storage** — Everything lives in memory; it only coordinates runtime components.

---

## Tips & gotchas

-   Always call `unregisterPaneInput` on unmount to keep the registry clean.
-   `programmaticSend` does nothing server-side; ensure it runs in the client.
-   Avoid invoking it before the pane finishes mounting—`hasPane` lets you guard against that.
-   Keep `paneId` stable per chat instance so automations target the right recipient.

---

## Related modules

-   `ChatInputDropper.vue` — actual UI input exposing the imperative API.
-   `pane-plugin-api` — typical consumer needing programmatic sends.
-   `useChat` — eventual destination for messages triggered through the bridge.
````

## File: composables/useComposerActions.md
````markdown
# useComposerActions

Composer action registry powering the quick-action buttons beneath the chat composer. Lets plugins add buttons that hook into the active editor, thread, or pane context with visibility and disabled logic.

---

## What does it do?

`useComposerActions` manages a global list of composer actions:

-   `registerComposerAction()` adds or replaces an action definition.
-   `useComposerActions(contextFn)` returns a computed list of actions + disabled state derived from the current pane.
-   `unregisterComposerAction()` cleans up during teardown/HMR.
-   `listRegisteredComposerActionIds()` helps debug what’s registered.

Actions can check editor state, streaming status, thread IDs, etc., and render with retro-friendly icons and colors.

---

## Basic Example

```ts
import {
    registerComposerAction,
    unregisterComposerAction,
    useComposerActions,
} from '~/composables/sidebar/useComposerActions';

registerComposerAction({
    id: 'custom:clear-editor',
    icon: 'i-ph-broom',
    label: 'Clear',
    color: 'warning',
    order: 180,
    handler: ({ editor }) => editor?.commands.clearContent(),
    disabled: ({ editor }) => !editor || editor.isEmpty,
});

const actions = useComposerActions(() => ({ editor: editorRef.value }));

onScopeDispose(() => unregisterComposerAction('custom:clear-editor'));
```

---

## How to use it

### 1. Register actions during setup

Call `registerComposerAction()` in a plugin or component. Namespace IDs (`your-plugin:action`) to avoid collisions. The composable freezes your payload to prevent accidental mutation.

### 2. Provide context to consumers

`useComposerActions(contextFn)` accepts a function returning the latest `ComposerActionContext` (editor ref, thread ID, streaming flag, etc.). When context values change, the computed array updates automatically.

### 3. Control visibility and disabled state

-   `visible(ctx)` hides the button when it returns `false`.
-   `disabled(ctx)` grays it out while keeping it in the layout.

Both callbacks run every render, so keep logic fast and side-effect free.

### 4. Handle clicks

`handler(ctx)` executes when the button is clicked. You can return a promise to perform async work (e.g., API calls). The UI doesn’t await by default—manage loading state externally if needed.

### 5. Clean up on unmount/HMR

Always call `unregisterComposerAction()` (or use `useHookEffect`) to avoid duplicate buttons when modules reload.

---

## What you get back

`useComposerActions(contextFn)` returns a `ComputedRef<ComposerActionEntry[]>`. Each entry includes the original `action` plus a `disabled` flag evaluated against the latest context.

| Property   | Type                                  | Description                                |
| ---------- | ------------------------------------- | ------------------------------------------ | --------------- |
| `id`       | `string`                              | Unique identifier.                         |
| `icon`     | `string`                              | Iconify name rendered in the composer bar. |
| `tooltip`  | `string \| undefined`                 | Optional hover text.                       |
| `label`    | `string \| undefined`                 | Optional button label.                     |
| `order`    | `number \| undefined`                 | Sorting hint (defaults to 200).            |
| `color`    | `ChromeActionColor \| undefined`      | Nuxt UI color token for button styling.    |
| `handler`  | `(ctx: ComposerActionContext) => void | Promise<void>`                             | Click callback. |
| `visible`  | `(ctx) => boolean`                    | Optional visibility predicate.             |
| `disabled` | `(ctx) => boolean`                    | Optional disabled predicate.               |

---

## API

```ts
registerComposerAction(action: ComposerAction): void;
unregisterComposerAction(id: string): void;
useComposerActions(context?: () => ComposerActionContext): ComputedRef<ComposerActionEntry[]>;
listRegisteredComposerActionIds(): string[];
```

---

## Under the hood

1. **Global registry** – Stores actions on `globalThis.__or3ComposerActionsRegistry`, ensuring a single source of truth across imports.
2. **Reactive list** – Mirrors the map with a Vue `reactive` wrapper so computed consumers react to updates.
3. **Sorting** – Ensures deterministic order via `order ?? 200` ascending.
4. **Immutability** – Actions are `Object.freeze`d to prevent accidental runtime mutation after registration.

---

## Edge cases & tips

-   **Duplicate IDs**: Later registrations overwrite earlier ones; dev mode logs a warning.
-   **Missing context**: All predicates receive an empty object if you omit `contextFn`—guard for undefined fields.
-   **Async errors**: Handlers should catch their own errors and show toasts; the registry doesn’t intercept failures.
-   **Streaming state**: Use `isStreaming` to disable actions while the AI is responding.

---

## Related

-   `useHeaderActions` — similar registry for the sidebar header buttons.
-   `useSidebarSections` — adds custom panels and footer actions to the chrome.
-   `~/app/components/chat` — consumes composer actions to render the button row.

---

## TypeScript

```ts
interface ComposerActionContext {
    editor?: Editor | null;
    threadId?: string | null;
    paneId?: string | null;
    isStreaming?: boolean;
}

interface ComposerAction {
    id: string;
    icon: string;
    tooltip?: string;
    label?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: ComposerActionContext) => void | Promise<void>;
    visible?: (ctx: ComposerActionContext) => boolean;
    disabled?: (ctx: ComposerActionContext) => boolean;
}
```
````

## File: composables/useDashboardPlugins.md
````markdown
# useDashboardPlugins

Dashboard extension hub that lets first- and third-party features register launcher tiles, lazy-loaded pages, and capability flags for the retro dashboard. It centralises plugin discovery, page resolution, and in-app navigation state.

---

## What does it do?

`useDashboardPlugins` and its sibling utilities give you a full plugin registry:

-   `registerDashboardPlugin` / `unregisterDashboardPlugin` keep a global map of tiles, their icons, handlers, and optional inline pages.
-   `registerDashboardPluginPage` normalises page definitions, marks components as raw, and handles lazy factories + caches.
-   `useDashboardPlugins()` exposes a sorted, reactive list for rendering the dashboard grid.
-   `useDashboardNavigation()` orchestrates the dashboard → plugin → page flow, resolving components on demand and surfacing errors.
-   Capability helpers (`hasCapability`, `hasAllCapabilities`, etc.) enforce optional permission checks per plugin.

The registry survives HMR and SSR hydration thanks to `globalThis` caching and careful cloning/marking of reactive components.

---

## Basic Example

```ts
import {
    registerDashboardPlugin,
    registerDashboardPluginPage,
    useDashboardNavigation,
} from '~/composables/dashboard/useDashboardPlugins';

registerDashboardPlugin({
    id: 'notes',
    icon: 'i-ph-note-pencil',
    label: 'Notes',
    order: 120,
    capabilities: ['canWriteDocs'],
});

registerDashboardPluginPage('notes', {
    id: 'compose',
    title: 'Compose note',
    component: () => import('~/components/dashboard/NotesCompose.vue'),
});

const { dashboardItems, openPlugin, landingPages, openPage } =
    useDashboardNavigation();

await openPlugin('notes');
await openPage('notes', 'compose');
```

---

## How to use it

### 1. Register plugins early

Call `registerDashboardPlugin()` in a client entry (plugin, layout setup) so the dashboard grid has items on first render. Inline `pages` are optional but handy for declarative registration.

### 2. Define pages (optional)

Use `registerDashboardPluginPage(pluginId, page)` for additional routes or lazy modules. Page components can be direct Vue components or async factories; the registry caches the resolved component per plugin/page pair.

### 3. Drive the UI with `useDashboardNavigation`

The navigation composable merges built-in base items with registered plugins. It exposes:

-   `dashboardItems` — sorted tiles, ready for rendering.
-   `openPlugin(id)` — opens a plugin tile; routes to sole page automatically.
-   `openPage(pluginId, pageId)` — resolves and mounts a page component, tracking loading state and errors.
-   `goBack()` / `reset()` — return to the dashboard view.

Use `resolvedPageComponent` to mount the current page inside a `<component>`.

### 4. Enforce capabilities when needed

`hasCapability`, `hasAnyCapability`, and `hasAllCapabilities` read declarations from the registered plugin. Wire these into guards, button states, or context menus.

---

## API

### Plugin registry

```ts
registerDashboardPlugin(plugin: DashboardPlugin): void;
unregisterDashboardPlugin(id: string): void;
useDashboardPlugins(): ComputedRef<DashboardPlugin[]>;
listRegisteredDashboardPluginIds(): string[];
```

### Page registry

```ts
registerDashboardPluginPage(pluginId: string, page: DashboardPluginPage): void;
unregisterDashboardPluginPage(pluginId: string, pageId?: string): void;
useDashboardPluginPages(getId: () => string | undefined): ComputedRef<DashboardPluginPage[]>;
listDashboardPluginPages(pluginId: string): DashboardPluginPage[];
getDashboardPluginPage(pluginId: string, pageId: string): DashboardPluginPage | undefined;
resolveDashboardPluginPageComponent(pluginId: string, pageId: string): Promise<Component | undefined>;
```

### Navigation runtime

```ts
useDashboardNavigation(options?: { baseItems?: DashboardPlugin[] }): {
    state: Readonly<DashboardNavigationState>;
    resolvedPageComponent: Readonly<ShallowRef<Component | null>>;
    dashboardItems: ComputedRef<DashboardPlugin[]>;
    landingPages: ComputedRef<DashboardPluginPage[]>;
    headerPluginLabel: ComputedRef<string>;
    activePageTitle: ComputedRef<string>;
    openPlugin(pluginId: string): Promise<DashboardNavigationResult>;
    openPage(pluginId: string, pageId: string): Promise<DashboardNavigationResult>;
    goBack(): void;
    reset(): void;
};
```

### Capability helpers

```ts
hasCapability(pluginId: string, capability: string): boolean;
getPluginCapabilities(pluginId: string): string[];
hasAllCapabilities(pluginId: string, capabilities: string[]): boolean;
hasAnyCapability(pluginId: string, capabilities: string[]): boolean;
```

---

## Under the hood

1. **Global registries** — Uses `globalThis` slots so plugins survive HMR and SSR boundary crossings without duplicate registration.
2. **Reactive projections** — Keeps `reactiveList` and `reactivePages` mirrors for Vue consumers, ensuring computed getters remain responsive.
3. **Ordering** — Applies `DEFAULT_ORDER` (200) when no explicit order is set, making plugin placement predictable.
4. **Component caching** — Memoises resolved page components, clears caches on unregister, and marks resolved objects with `markRaw` to preserve Vue perf.
5. **Navigation state** — A singleton runtime tracks view mode, active plugin/page ids, loading state, and errors while exposing read-only refs to the UI.

---

## Edge cases & tips

-   **Duplicate IDs**: In dev, re-registering a plugin logs a warning but still replaces it—handy during HMR but avoid in production.
-   **Lazy pages**: If an async page loader returns a non-component, dev mode warns and the nav surfaces a `resolve-error` result.
-   **Single-page plugins**: `openPlugin()` auto-opens the lone page, simplifying button handlers.
-   **Error handling**: `openPlugin`/`openPage` return `{ ok: false, error }` with codes (`missing-plugin`, `missing-page`, `handler-error`, `resolve-error`) for structured UI reactions.
-   **Capability checks**: All capability helpers safely return `false` when the plugin is absent or declarations are missing—no need for extra guards.

---

## Related

-   `~/composables/dashboard` — home for dashboard-specific extensions.
-   `~/core/hooks` — hook system often used by plugins during registration.
-   `~/app/components/dashboard` — grid and page host components that consume `useDashboardNavigation`.
````

## File: composables/useDefaultPrompt.md
````markdown
# useDefaultPrompt

Central helper for tracking the default system prompt across chat panes. It wraps the `kv` table, keeps a singleton ref of the active prompt ID, and fires hooks when the default changes so other modules can react.

---

## Overview

`useDefaultPrompt` gives you a reactive `defaultPromptId` alongside helpers to set or clear it. Behind the scenes it reads from Dexie on first use, stores the value in `kv` under `default_system_prompt_id`, and triggers a hook so panes refresh their copy.

-   Loads once per session (client-side) and caches the id in a shared ref
-   Keeps mutations synced to IndexedDB + in-memory state
-   Exposes `clearDefaultPrompt()` and `ensureLoaded()` helpers
-   Provides a `getDefaultPromptId()` utility for low-level access

---

## Quick start

```ts
import { useDefaultPrompt } from '~/composables/chat/useDefaultPrompt';

const { defaultPromptId, setDefaultPrompt, clearDefaultPrompt } =
    useDefaultPrompt();

watch(defaultPromptId, (id) => {
    console.log('Default prompt is now', id ?? 'not set');
});

await setDefaultPrompt('prompt-123');
// ... later
await clearDefaultPrompt();
```

---

## API

| Member                 | Type                                    | Description                                                           |
| ---------------------- | --------------------------------------- | --------------------------------------------------------------------- |
| `defaultPromptId`      | `ReadonlyRef<string \| null>`           | Reactive id for the default system prompt (or `null`).                |
| `setDefaultPrompt(id)` | `(id: string \| null) => Promise<void>` | Persist a new default prompt id (or `null`) and broadcast hook event. |
| `clearDefaultPrompt()` | `() => Promise<void>`                   | Convenience alias for `setDefaultPrompt(null)`.                       |
| `ensureLoaded()`       | `() => Promise<void>`                   | Force-load the cached value (useful during SSR guards).               |

### Standalone helper

| Function               | Description                                                                                                   |
| ---------------------- | ------------------------------------------------------------------------------------------------------------- |
| `getDefaultPromptId()` | Async function that reads directly from Dexie and returns the stored id without touching the singleton store. |

---

## How it works

1. **Singleton state** — The ref `_defaultPromptId` lives at module scope, so every caller shares the same reactive value.
2. **Lazy load** — `loadOnce()` reads `kv` only the first time a browser caller uses the composable. On SSR it no-ops because Dexie isn’t available.
3. **Updates** — `setDefaultPrompt()` updates the ref, persists via `setKvByName`, then fires `chat.systemPrompt.default:action:update` with the new id so listeners refresh.
4. **Clearing** — `clearDefaultPrompt()` simply calls `setDefaultPrompt(null)`.
5. **Direct access** — `getDefaultPromptId()` is exported for non-reactive flows (e.g. server actions) that just need the value once.

---

## Usage patterns

### Create a settings toggle

```ts
const { defaultPromptId, setDefaultPrompt } = useDefaultPrompt();

async function applyPrompt(promptId: string) {
    await setDefaultPrompt(promptId);
}
```

### Guard before loading prompt content

```ts
const { ensureLoaded, defaultPromptId } = useDefaultPrompt();

await ensureLoaded();
if (defaultPromptId.value) {
    await loadPrompt(defaultPromptId.value);
}
```

### Server-side lookup

```ts
import { getDefaultPromptId } from '~/composables/chat/useDefaultPrompt';

const promptId = await getDefaultPromptId();
if (promptId) {
    // fetch prompt details from db
}
```

---

## Edge cases & notes

-   **Client-only loading** — The composable guards on `import.meta.client`; SSR imports will see `defaultPromptId` remain `null` until the client hydrates.
-   **Missing record** — If the key isn’t present, the ref is set to `null` and no errors bubble up.
-   **Hook listeners** — Consumers can subscribe with `useHooks().addAction('chat.systemPrompt.default:action:update', handler)` to respond whenever the default changes.
-   **Error handling** — Storage read/write operations are wrapped in try/catch; failures simply keep the ref at `null`.

---

## Related references

-   `useActivePrompt` — to manage prompt details once you have the id.
-   `~/db/kv` — utility wrapping Dexie’s key-value store.
-   `chat.systemPrompt.default:action:update` — hook dispatched after every update.
````

## File: composables/useDocumentHistoryActions.md
````markdown
# useDocumentHistoryActions

Registry composable that lets plugins inject extra actions into the document history sidebar menu. Keeps a global list of action buttons, sorts them, and survives HMR so dashboard add-ons can extend the UI safely.

---

## What does it do?

`useDocumentHistoryActions` powers the dropdown on each document history item:

-   `registerDocumentHistoryAction()` adds or replaces an action definition.
-   `useDocumentHistoryActions()` returns a sorted, reactive array of actions for rendering.
-   `unregisterDocumentHistoryAction()` removes actions during cleanup to avoid duplicates.
-   `listRegisteredDocumentHistoryActionIds()` helps authors inspect what’s already registered.

Because the registry lives on `globalThis`, the set of actions persists across hot reloads and SSR hydration.

---

## Basic Example

```ts
import {
    registerDocumentHistoryAction,
    unregisterDocumentHistoryAction,
    useDocumentHistoryActions,
} from '~/composables/documents/useDocumentHistoryActions';

registerDocumentHistoryAction({
    id: 'export-pdf',
    icon: 'i-ph-file-pdf',
    label: 'Export as PDF',
    order: 210,
    async handler({ document }) {
        await exportDocumentToPdf(document.id);
    },
});

const actions = useDocumentHistoryActions();

onScopeDispose(() => {
    unregisterDocumentHistoryAction('export-pdf');
});
```

---

## How to use it

### 1. Register on startup or inside a hook

Call `registerDocumentHistoryAction()` when your plugin initialises. Use `useHookEffect()` if you need automatic cleanup on HMR/unmount.

### 2. Provide a unique ID and icon

-   Prefix IDs with your namespace (`my-plugin:download`) to avoid conflicts.
-   Supply an Iconify name that fits the retro UI.

### 3. Handle the click

The handler receives `{ document }` where `document` is the Dexie `Post` record. Perform async work freely; the dropdown stays responsive.

### 4. Render the actions

Components like the document sidebar call `useDocumentHistoryActions()` to read the current list. You can do the same to inject actions into custom UIs or tests.

---

## What you get back

`useDocumentHistoryActions()` returns a computed ref sorted by `order` (default 200), so lower numbers appear first.

| Property  | Type                                                 | Description                        |
| --------- | ---------------------------------------------------- | ---------------------------------- |
| `id`      | `string`                                             | Unique identifier for the action.  |
| `icon`    | `string`                                             | Iconify name rendered in the menu. |
| `label`   | `string`                                             | Button text shown in the dropdown. |
| `order`   | `number \| undefined`                                | Placement hint (defaults to 200).  |
| `handler` | `(ctx: { document: Post }) => void \| Promise<void>` | Click callback.                    |

---

## API

```ts
registerDocumentHistoryAction(action: DocumentHistoryAction): void;
unregisterDocumentHistoryAction(id: string): void;
useDocumentHistoryActions(): ComputedRef<DocumentHistoryAction[]>;
listRegisteredDocumentHistoryActionIds(): string[];
```

---

## Under the hood

1. **Global map** – Stores actions on `globalThis.__or3DocumentHistoryActionsRegistry` to persist across reloads.
2. **Reactive mirror** – Maintains `reactiveList.items` so Vue can track changes without making the map reactive.
3. **Sorting** – Consumers sort by `order` on every read, ensuring deterministic menus.
4. **HMR-safe** – Re-registering an existing ID simply replaces the entry; dev mode can warn upstream.

---

## Edge cases & tips

-   **Duplicate IDs**: Later registrations replace earlier ones. If that’s unintentional, inspect `listRegisteredDocumentHistoryActionIds()`.
-   **Order gaps**: You don’t need consecutive numbers—stick to buckets (100 built-ins, 200 extensions, etc.).
-   **Cleanup**: Always unregister on scope dispose to avoid stale actions when HMR tears down modules.
-   **Error handling**: Wrap handler logic in try/catch and surface toast notifications yourself; the registry doesn’t swallow errors.

---

## Related

-   `useHookEffect` — ideal for registering/unregistering actions inside plugin lifecycles.
-   `~/app/components/sidebar/DocumentHistory.vue` — renders the menu that consumes this registry.
-   `~/db/posts` — source type for the `document` payload.

---

## TypeScript

```ts
interface DocumentHistoryAction {
    id: string;
    icon: string;
    label: string;
    order?: number;
    handler: (ctx: { document: Post }) => void | Promise<void>;
}
```
````

## File: composables/useDocumentsList.md
````markdown
# useDocumentsList

Lightweight fetch-and-refresh composable for the documents sidebar. Loads recent Dexie `documents` entries, trims heavy fields, and keeps the list fresh when database hooks fire.

---

## What does it do?

`useDocumentsList(limit?)` gives you:

-   A `docs` ref with up to `limit` lightweight document summaries.
-   A `loading` flag optimised for SSR → client hydration.
-   An `error` ref populated when Dexie calls fail.
-   A `refresh()` function to reload on demand.
-   Automatic refresh when `db.documents.*` hook events fire on the client.

By trimming `content`, the sidebar avoids storing huge TipTap JSON strings in memory.

---

## Basic Example

```ts
import { useDocumentsList } from '~/composables/documents/useDocumentsList';

const { docs, loading, error, refresh } = useDocumentsList(100);

onMounted(() => {
    if (!loading.value && !docs.value.length) refresh();
});
```

---

## How to use it

### 1. Call the composable in setup

Optionally pass a `limit` (default `200`) to cap results. The first run sets `loading` to `true` so SSR and client HTML match.

### 2. Render the list

`docs.value` contains objects with metadata (`id`, `title`, `postType`, timestamps, `deleted`, `meta`). Bind them into your sidebar or dashboards.

### 3. Handle loading & errors

-   Show spinners while `loading.value` is `true`.
-   Read `error.value` when a fetch fails; a toast is already fired with "Document: list failed".

### 4. Refresh when needed

Call `refresh()` after bulk operations or when server-triggered changes need to propagate. On the client, the composable already listens for:

-   `db.documents.create:action:after`
-   `db.documents.update:action:after`
-   `db.documents.delete:action:*:after`

Those hooks come from the central `$hooks` engine via `useHookEffect` and ensure the list stays current.

---

## What you get back

| Property  | Type                  | Description                                       |
| --------- | --------------------- | ------------------------------------------------- |
| `docs`    | `Ref<Document[]>`     | Array of trimmed document records (no `content`). |
| `loading` | `Ref<boolean>`        | `true` while fetching from Dexie.                 |
| `error`   | `Ref<unknown>`        | Error value if the last fetch failed.             |
| `refresh` | `() => Promise<void>` | Reload the list manually.                         |

The returned `Document` objects keep `content: ''` to satisfy the type while staying lightweight.

---

## Under the hood

1. **Dexie fetch** – Uses `listDocuments(limit)` to query the `documents` store.
2. **Field pruning** – Maps results to a slimmer object before storing in the ref.
3. **Error handling** – Catches failures, stamps `error.value`, and raises a toast.
4. **Hook subscriptions** – Registers `useHookEffect` listeners on the client to refresh after create/update/delete actions.
5. **SSR friendly** – Leaves `loading` true during SSR so hydration sees the same markup.

---

## Edge cases & tips

-   **Server-only usage**: On the server, the hook listeners don’t run. Call `refresh()` manually if you render on the server and stream updates.
-   **Limit tuning**: Adjust `limit` depending on sidebar performance; the query already caps the results client-side.
-   **Custom toasts**: If you need custom messaging, catch `error.value` in your component and display additional context.
-   **Deleted docs**: Entries include a `deleted` flag so you can filter out soft-deleted documents if desired.

---

## Related

-   `~/db/documents` — Dexie helpers used under the hood.
-   `useDocumentsStore` — full document state with content + autosave.
-   `usePaneDocuments` — orchestrates pane-specific document selection.

---

## TypeScript

```ts
function useDocumentsList(limit?: number): {
    docs: Ref<Document[]>;
    loading: Ref<boolean>;
    error: Ref<unknown>;
    refresh: () => Promise<void>;
};
```
````

## File: composables/useDocumentsStore.md
````markdown
# useDocumentsStore

Stateful document manager that loads Dexie records, stages edits, debounces autosaves, and coordinates pane-level hooks. It is the backbone for rich text documents in OR3’s multi-pane UI.

---

## What does it do?

`useDocumentsStore` exposes a suite of helpers around a shared `documentsMap` cache:

-   Loads documents via `loadDocument()` and caches them per ID.
-   Tracks pending title/content changes and auto-flushes after 750 ms of inactivity.
-   Sends toast notifications when create/load/save actions fail.
-   Emits `$hooks` events (`ui.pane.doc:action:saved`, `:changed`, etc.) so panes stay in sync.
-   Provides low-level helpers like `releaseDocument()` to drop heavy TipTap JSON from memory.

The map lives in module scope, so every component shares the same live state.

---

## Basic Example

```ts
import {
    newDocument,
    loadDocument,
    setDocumentTitle,
    setDocumentContent,
    useDocumentState,
} from '~/composables/documents/useDocumentsStore';

const doc = await newDocument({ title: 'Untitled doc' });

await loadDocument(doc.id);

setDocumentTitle(doc.id, 'My Notes');
setDocumentContent(doc.id, editorStateJSON);

const state = useDocumentState(doc.id);
watch(
    () => state.status,
    (status) => {
        if (status === 'saved') console.log('Document persisted');
    }
);
```

---

## How to use it

### 1. Create or load records

-   Use `newDocument(initial?)` to create a Dexie record and seed the store.
-   Call `loadDocument(id)` to fetch an existing record into memory. The function resolves to the record (or `null` if missing) and surfaces toasts for not-found errors.

### 2. Stage edits

-   `setDocumentTitle(id, title)` and `setDocumentContent(id, content)` mark changes as pending and schedule a save.
-   Saves batch after 750 ms (configurable via `scheduleSave`’s default).

### 3. Flush explicitly when needed

-   Invoke `flush(id)` to force an immediate save, e.g., before navigation.
-   Pass `{ flush: false }` into `releaseDocument()` if you’ve already flushed.

### 4. Observe status

-   `useDocumentState(id)` returns the shared `DocState` (record, status, pending fields, last error).
-   Status cycles through `'loading' → 'idle' → 'saving' → 'saved'` (or `'error'`).

### 5. Release heavy content

Call `releaseDocument(id, { flush?: boolean, deleteEntry?: boolean })` when you leave a pane to reclaim memory. This clears timers, optional flushes, and drops the record reference so the GC can free the TipTap payload.

---

## What you get back

| Helper                            | Description                                                          |
| --------------------------------- | -------------------------------------------------------------------- |
| `newDocument(initial?)`           | Creates a document and primes the store; emits toast on failure.     |
| `loadDocument(id)`                | Fetches from Dexie, updates cache, and returns the record or `null`. |
| `setDocumentTitle(id, title)`     | Marks a new title and schedules a save.                              |
| `setDocumentContent(id, content)` | Stages TipTap JSON and schedules a save.                             |
| `flush(id)`                       | Persists pending fields immediately.                                 |
| `releaseDocument(id, opts?)`      | Clears timers, optionally flushes, and removes cached state.         |
| `useDocumentState(id)`            | Returns the `DocState` entry for reactive inspection.                |
| `useAllDocumentsState()`          | Gives you the reactive map (for debugging tooling).                  |
| `__hasPendingDocumentChanges(id)` | Internal helper to check for staged edits.                           |
| `__peekDocumentStatus(id)`        | Internal helper to read status without touching reactivity.          |

`DocState` looks like:

```ts
interface DocState {
    record: Document | null;
    status: 'idle' | 'saving' | 'saved' | 'error' | 'loading';
    lastError?: any;
    pendingTitle?: string;
    pendingContent?: any;
    timer?: any;
}
```

---

## Under the hood

1. **Shared map** – `documentsMap` (reactive `Map<string, DocState>`) ensures every component edits the same instance.
2. **Debounced saves** – `scheduleSave()` coalesces rapid edits into a single `flush()` invocation.
3. **Dexie helpers** – Uses `createDocument`, `updateDocument`, and `getDocument` from `~/db/documents`.
4. **Toast feedback** – Failures call `useToast().add()` with consistent retro styling.
5. **Pane events** – After `flush()`, the store locates open document panes via the global multi-pane API and triggers `ui.pane.doc:action:saved` events through `$hooks`.
6. **Memory hygiene** – `releaseDocument()` clears timers, removes `content`, and optionally deletes the map entry.

---

## Edge cases & tips

-   **Missing record**: `loadDocument()` returns `null` and shows a toast; callers should handle the `null` case.
-   **Autosave race**: Multiple rapid edits reset the same timer, so only the final state flushes.
-   **Manual flush before unload**: Call `await flush(id)` in route guards/modals to guarantee persistence.
-   **Pane hooks**: Tests or integrations can call `__hasPendingDocumentChanges()` to decide whether to force a save before closing a pane.
-   **Deleting entries**: After releasing with `{ deleteEntry: true }`, calling `useDocumentState(id)` recreates a fresh placeholder.

---

## Related

-   `usePaneDocuments` — orchestrates pane switching on top of this store.
-   `~/composables/core/useMultiPane` — pane runtime referenced when emitting hook actions.
-   `~/db/documents` — Dexie CRUD implementation backing all operations.

---

## TypeScript

```ts
function useDocumentState(id: string): DocState;
function useAllDocumentsState(): Map<string, DocState>;
async function loadDocument(id: string): Promise<Document | null>;
async function newDocument(initial?: {
    title?: string;
    content?: any;
}): Promise<Document>;
function setDocumentTitle(id: string, title: string): void;
function setDocumentContent(id: string, content: any): void;
async function flush(id: string): Promise<void>;
async function releaseDocument(
    id: string,
    opts?: { flush?: boolean; deleteEntry?: boolean }
): Promise<void>;
```
````

## File: composables/useEditorNodes.md
````markdown
# useEditorNodes

Registry trio that lets plugins add TipTap nodes, marks, and extensions to the OR3 editor without patching the core component. Maintains global maps, keeps ordering stable, and plays nicely with HMR.

---

## What does it do?

`useEditorNodes` exports helpers that manage three registries:

-   `registerEditorNode` / `listEditorNodes` for TipTap `Node` extensions.
-   `registerEditorMark` / `listEditorMarks` for TipTap `Mark` extensions.
-   `registerEditorExtension` / `listEditorExtensions` for generic TipTap extensions.

Each registry sorts entries by `order` (default 200) and stores them on `globalThis` so reloads don’t duplicate items.

---

## Basic Example

```ts
import BulletList from '@tiptap/extension-bullet-list';
import Italic from '@tiptap/extension-italic';
import CharacterCount from '@tiptap/extension-character-count';
import {
    registerEditorNode,
    registerEditorMark,
    registerEditorExtension,
    unregisterEditorNode,
} from '~/composables/editor/useEditorNodes';

registerEditorNode({
    id: 'custom:bullet-list',
    extension: BulletList,
    order: 180,
});

registerEditorMark({
    id: 'custom:italic',
    extension: Italic,
});

registerEditorExtension({
    id: 'custom:char-count',
    extension: CharacterCount.configure({ limit: 2000 }),
});

onScopeDispose(() => {
    unregisterEditorNode('custom:bullet-list');
});
```

---

## How to use it

### 1. Pick the right registry

-   Use `registerEditorNode()` for block/inline nodes (paragraphs, lists, embeds).
-   Use `registerEditorMark()` for text marks (bold, italic, highlights).
-   Use `registerEditorExtension()` for plugins that don’t fit either bucket (history, collaboration, etc.).

### 2. Provide a unique ID

Namespace IDs (e.g., `your-plugin:node`) so duplicate registrations override intentionally.

### 3. Set ordering if needed

-   Built-ins typically occupy the <200 range. Lower values appear earlier when the editor component iterates.
-   Leave `order` undefined to slot your extension after core ones.

### 4. Clean up on dispose

Call the matching `unregister*` helper during HMR or component teardown to prevent stale entries.

### 5. Consume from the editor shell

`listEditorNodes()`, `listEditorMarks()`, and `listEditorExtensions()` return sorted arrays—`DocumentEditor.vue` reads them to build the TipTap instance.

---

## API

```ts
registerEditorNode(node: EditorNode): void;
unregisterEditorNode(id: string): void;
listEditorNodes(): EditorNode[];
listRegisteredEditorNodeIds(): string[];

registerEditorMark(mark: EditorMark): void;
unregisterEditorMark(id: string): void;
listEditorMarks(): EditorMark[];
listRegisteredEditorMarkIds(): string[];

registerEditorExtension(ext: EditorExtension): void;
unregisterEditorExtension(id: string): void;
listEditorExtensions(): EditorExtension[];
listRegisteredEditorExtensionIds(): string[];
```

---

## Under the hood

1. **Global maps** – Registries live on `globalThis.__or3Editor*Registry`, so multiple imports share the same data and HMR doesn’t double-register.
2. **Reactive mirrors** – `reactiveList` objects mirror each map so Vue can track changes when lists are recomputed.
3. **Stable sorting** – Items sort by `order` with a secondary `id` tie-breaker for deterministic output.
4. **Dev warnings** – In dev mode, double registration logs a warning to help catch collisions early.

---

## Edge cases & tips

-   **Duplicate IDs**: Later registrations replace earlier ones. Use this intentionally for overrides, otherwise rename your extension.
-   **Mark vs extension**: Some TipTap packages export both mark + helper. Register whichever type your editor setup expects.
-   **SSR safety**: Registries initialise lazily and don’t touch browser-only APIs, so they’re safe during server rendering.
-   **Cleanup**: Forgetting to unregister during HMR can leave stale marks that break tests; wrap registrations in `useHookEffect` to automate cleanup.

---

## Related

-   `useEditorToolbar` — complementary registry for toolbar buttons.
-   `~/app/components/editor/DocumentEditor.vue` — consumes these lists when building the TipTap instance.
-   `~/utils/editor/` — shared helpers for configuring extensions.

---

## TypeScript

```ts
interface EditorNode {
    id: string;
    extension: Node;
    order?: number;
}

interface EditorMark {
    id: string;
    extension: Mark;
    order?: number;
}

interface EditorExtension {
    id: string;
    extension: Extension;
    order?: number;
}
```
````

## File: composables/useEditorToolbar.md
````markdown
# useEditorToolbar

Toolbar registry for the TipTap editor. Lets plugins add buttons, toggles, or dropdowns to the retro editor header while keeping the UI reactive and order-aware.

---

## What does it do?

`useEditorToolbar` exposes helpers to manage toolbar buttons:

-   `registerEditorToolbarButton()` adds or replaces a button definition.
-   `useEditorToolbarButtons(editorRef)` returns a computed, filtered, and sorted array of buttons ready to render.
-   `unregisterEditorToolbarButton()` cleans up during teardown/HMR.
-   `listRegisteredEditorToolbarButtonIds()` lets authors inspect the registry.

Buttons can customise visibility, active state, icons, ordering, and click behaviour.

---

## Basic Example

```ts
import Bold from '@tiptap/extension-bold';
import {
    registerEditorToolbarButton,
    unregisterEditorToolbarButton,
    useEditorToolbarButtons,
} from '~/composables/editor/useEditorToolbar';
import { registerEditorMark } from '~/composables/editor/useEditorNodes';

registerEditorMark({ id: 'custom:bold', extension: Bold });

registerEditorToolbarButton({
    id: 'custom:bold-toggle',
    icon: 'i-ph-text-b',
    tooltip: 'Bold (⌘B)',
    order: 150,
    isActive: (editor) => editor.isActive('bold'),
    onClick: (editor) => editor.chain().focus().toggleBold().run(),
});

const buttons = useEditorToolbarButtons(editorRef);

onScopeDispose(() => {
    unregisterEditorToolbarButton('custom:bold-toggle');
});
```

---

## How to use it

### 1. Register buttons during setup

Call `registerEditorToolbarButton()` inside a plugin or component. Namespace IDs to avoid clashes (`my-plugin:bold`).

### 2. Implement handlers

-   `onClick` receives the live TipTap editor instance—chain commands, toggle marks, etc.
-   `isActive` marks buttons as pressed (useful for toggles).
-   `visible` hides buttons conditionally (e.g., based on editor capabilities).

Wrap logic in try/catch if the command could fail; errors bubble to the console in dev but won’t break rendering.

### 3. Consume in the toolbar component

Pass a ref to the current `Editor` instance into `useEditorToolbarButtons()`. The computed result auto-updates when visibility changes (e.g., selection context).

### 4. Order buttons

-   Built-ins generally occupy <200 slots.
-   Set `order` to insert before/after core controls; ties fall back to `id` alphabetical order.

### 5. Clean up for HMR

Call `unregisterEditorToolbarButton()` during teardown to avoid duplicates when modules hot reload.

---

## What you get back

`useEditorToolbarButtons(editorRef)` returns a `ComputedRef<EditorToolbarButton[]>`. Each button contains:

| Property   | Type                          | Description                                          |
| ---------- | ----------------------------- | ---------------------------------------------------- | ------------------------------------ |
| `id`       | `string`                      | Unique identifier.                                   |
| `icon`     | `string`                      | Iconify name shown in the retro toolbar.             |
| `tooltip`  | `string \| undefined`         | Hover hint.                                          |
| `order`    | `number \| undefined`         | Controls placement (default 200).                    |
| `isActive` | `(editor: Editor) => boolean` | Optional active state tester.                        |
| `onClick`  | `(editor: Editor) => void     | Promise<void>`                                       | Executes when the button is clicked. |
| `visible`  | `(editor: Editor) => boolean` | Optional visibility predicate; hidden on exceptions. |

---

## API

```ts
registerEditorToolbarButton(button: EditorToolbarButton): void;
unregisterEditorToolbarButton(id: string): void;
useEditorToolbarButtons(editorRef: Ref<Editor | null>): ComputedRef<EditorToolbarButton[]>;
listRegisteredEditorToolbarButtonIds(): string[];
```

---

## Under the hood

1. **Global map** – Buttons live on `globalThis.__or3EditorToolbarRegistry`, preventing duplicate registrations across imports/HMR.
2. **Reactive mirror** – A reactive list mirrors the map so Vue recomputes consumer arrays automatically.
3. **Visibility guard** – `useEditorToolbarButtons` filters buttons through their `visible` callback inside a try/catch; errors default to hiding the button.
4. **Stable sort** – Buttons sort by `order` with a secondary `id` tie-breaker for deterministic output.

---

## Edge cases & tips

-   **No editor yet**: When `editorRef.value` is `null`, the computed array is empty—render guards should handle this gracefully.
-   **Async handlers**: Returning a promise is supported; UI code can await if needed (e.g., to show loading states).
-   **Keyboard shortcuts**: Pair buttons with TipTap commands bound via `editor.registerPlugin` or external shortcut handlers.
-   **Testing**: In Vitest, provide a mocked editor object with the minimal API (`chain`, `isActive`) to test your buttons.

---

## Related

-   `useEditorNodes` — register complementary nodes/marks.
-   `~/app/components/editor/DocumentEditorToolbar.vue` — consumes the toolbar registry.
-   `@tiptap/vue-3` — TipTap editor integration referenced by button handlers.

---

## TypeScript

```ts
interface EditorToolbarButton {
    id: string;
    icon: string;
    tooltip?: string;
    order?: number;
    isActive?: (editor: Editor) => boolean;
    onClick: (editor: Editor) => void | Promise<void>;
    visible?: (editor: Editor) => boolean;
}
```
````

## File: composables/useHeaderActions.md
````markdown
# useHeaderActions

Sidebar header action registry that powers the icon buttons in the chrome header (new thread, toggle layout, etc.). Lets plugins contribute actions that react to route, breakpoint, or custom context.

---

## What does it do?

`useHeaderActions` wraps the shared registry factory to provide:

-   `registerHeaderAction()` / `unregisterHeaderAction()` for lifecycle management.
-   `useHeaderActions(contextFn)` to compute filtered, ordered buttons with disabled state applied.
-   `listRegisteredHeaderActionIds()` for debugging.

Actions can adjust styling via `color`, display tooltips, and opt into mobile-only/desktop-only modes.

---

## Basic Example

```ts
import {
    registerHeaderAction,
    unregisterHeaderAction,
    useHeaderActions,
} from '~/composables/sidebar/useHeaderActions';

registerHeaderAction({
    id: 'custom:toggle-projects',
    icon: 'i-ph-folders',
    tooltip: 'Toggle projects',
    order: 160,
    visible: ({ isMobile }) => !isMobile,
    handler: () => emitToggleProjects(),
});

const actions = useHeaderActions(() => ({ route: useRoute(), isMobile }));

onScopeDispose(() => unregisterHeaderAction('custom:toggle-projects'));
```

---

## How to use it

### 1. Register actions on startup

-   Namespace IDs to avoid clobbering built-ins.
-   Provide `icon`, optional `tooltip`, `label`, `color`, and `order`.

### 2. Feed context into `useHeaderActions`

`contextFn` should return whatever inputs your predicates need (e.g., current `route`, `isMobile` flag from `useBreakpoints`). The computed list recalculates whenever the returned values change.

### 3. Control visibility and disabled state

-   `visible(ctx)` returns `false` to hide the button entirely.
-   `disabled(ctx)` greys out the button but keeps tooltip + layout.

### 4. Handle clicks

`handler(ctx)` can perform sync or async work. Manage your own loading indicators—you can combine with `disabled` toggles if necessary.

### 5. Cleanup during teardown

Call `unregisterHeaderAction()` (or use `useHookEffect`) to avoid duplicates under HMR.

---

## What you get back

`useHeaderActions(contextFn)` returns a `ComputedRef<HeaderActionEntry[]>` where each entry includes the original action plus evaluated `disabled` state.

| Property   | Type                                | Description                                  |
| ---------- | ----------------------------------- | -------------------------------------------- | -------------- |
| `id`       | `string`                            | Unique identifier.                           |
| `icon`     | `string`                            | Iconify name for the header button.          |
| `tooltip`  | `string \| undefined`               | Hover/focus hint.                            |
| `label`    | `string \| undefined`               | Optional text label beside the icon.         |
| `order`    | `number \| undefined`               | Sort order (default 200).                    |
| `color`    | `ChromeActionColor \| undefined`    | Styling hint passed to the button component. |
| `handler`  | `(ctx: HeaderActionContext) => void | Promise<void>`                               | Click handler. |
| `visible`  | `(ctx) => boolean`                  | Optional visibility predicate.               |
| `disabled` | `(ctx) => boolean`                  | Optional disabled predicate.                 |

---

## API

```ts
registerHeaderAction(action: HeaderAction): void;
unregisterHeaderAction(id: string): void;
useHeaderActions(context?: () => HeaderActionContext): ComputedRef<HeaderActionEntry[]>;
listRegisteredHeaderActionIds(): string[];
```

---

## Under the hood

1. **Registry factory** – Uses `createRegistry('__or3HeaderActionsRegistry')` which already handles dedupe, sorting, and reactivity.
2. **Default ordering** – Applies `order ?? 200` so plugin buttons usually land after built-ins unless you specify otherwise.
3. **Context-driven filtering** – Runs `visible`/`disabled` functions for every render; errors aren’t caught here, so write defensive code if predicates touch optional fields.
4. **Shared list** – All imports share the same global registry, making it safe to register from multiple modules.

---

## Edge cases & tips

-   **Mobile-only actions**: Pair `visible` with your responsive breakpoints to hide controls on smaller layouts.
-   **Route-dependent actions**: Use `route.name` or `route.path` inside predicates to only show actions on relevant pages.
-   **Async state**: If a handler triggers network work, consider disabling the button until the promise resolves.
-   **Testing**: Mock `createRegistry` or inject a fake registry when writing unit tests to keep them deterministic.

---

## Related

-   `useComposerActions` — handles composer button row.
-   `useSidebarSections` — adds custom sidebar panels and footer actions.
-   `~/composables/_registry` — shared factory powering these registries.

---

## TypeScript

```ts
interface HeaderActionContext {
    route?: RouteLocationNormalizedLoaded | null;
    isMobile?: boolean;
}

interface HeaderAction extends RegistryItem {
    id: string;
    icon: string;
    tooltip?: string;
    label?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: HeaderActionContext) => void | Promise<void>;
    visible?: (ctx: HeaderActionContext) => boolean;
    disabled?: (ctx: HeaderActionContext) => boolean;
}
```
````

## File: composables/useHookEffect.md
````markdown
# useHookEffect

Typed helper for subscribing to the internal hook bus. It registers a callback, cleans up automatically on component unmount and during hot-module reload, and returns a disposer if you need manual control.

---

## What does it do?

`useHookEffect` wraps the hook engine (`useHooks()`) with lifecycle-aware registration. Whenever a component mounts, it attaches your callback to a named hook and guarantees cleanup so you never leak listeners.

-   Supports every hook name with full TypeScript inference
-   Lets you override hook kind (`action` / `filter`) and priority
-   Auto-detaches on `onBeforeUnmount`
-   Handles Vite/Nuxt HMR disposal for local development

---

## Basic Example

```ts
import { useHookEffect } from '~/composables/core/useHookEffect';

useHookEffect('ui.chat.message:filter:outgoing', async (message) => {
    if (message.content.includes('restricted')) {
        return false; // veto send
    }
    return message;
});
```

---

## How to use it

### 1. Import and register

Call `useHookEffect(name, callback)` in `setup()`. The callback signature is inferred from the hook name, so TypeScript will keep you honest.

### 2. Optionally tweak behavior

Pass an `opts` object to set a specific hook kind or priority:

```ts
useHookEffect('ui.pane.switch:action', handler, {
    kind: 'action',
    priority: 50,
});
```

### 3. Manually dispose if needed

The function returns a disposer. You rarely need it, but it can be helpful when toggling listeners in response to reactive state.

```ts
const dispose = useHookEffect('ai.chat.send:action:after', onComplete);

watch(enabled, (next) => {
    if (!next) dispose();
});
```

---

## API

```ts
function useHookEffect<K extends HookName>(
    name: K,
    fn: InferHookCallback<K>,
    opts?: {
        kind?: HookKind;
        priority?: number;
    }
): () => void;
```

| Parameter       | Type                               | Description                                                                 |
| --------------- | ---------------------------------- | --------------------------------------------------------------------------- |
| `name`          | `HookName`                         | The hook identifier (strongly typed to known strings).                      |
| `fn`            | `InferHookCallback<K>`             | Listener invoked when the hook fires.                                       |
| `opts.kind`     | `'action' \| 'filter' \| HookKind` | Override the resolved kind when the name is ambiguous.                      |
| `opts.priority` | `number`                           | Smaller numbers run first; defaults to the hook engine’s standard priority. |

Returns the disposer you can call to unregister immediately.

---

## Under the hood

1. Fetches the shared hook engine with `useHooks()`.
2. Registers the callback with `hooks.on`, capturing the disposer.
3. Subscribes to `onBeforeUnmount` to `hooks.off(disposer)`.
4. During HMR, listens for `import.meta.hot.dispose` and calls the disposer.

Because of that lifecycle tie-in, you can safely register listeners in any component without worrying about stale callbacks.

---

## Edge cases & tips

-   **SSR**: Safe to import; hooks execute client-side where the engine lives.
-   **Multiple registrations**: Each call returns its own disposer—store them if you plan to toggle listeners dynamically.
-   **Kind inference**: If a hook name ends with `:filter:*`, the kind defaults to `filter`; same for `:action:*`. Override `opts.kind` only when absolutely necessary.
-   **Priorities**: Use lower numbers to ensure your filter runs before default ones (e.g., set to `25` to beat default `50`).

---

## Related

-   `useHooks()` — exposes the raw hook API if you need advanced control.
-   `docs/core-hook-map.md` — catalog of built-in hook names.
-   `useChat` / `useMultiPane` — major composables that emit the hooks you’ll most often tap into.
````

## File: composables/useMessageActions.md
````markdown
# useMessageActions

Extensible action registry for chat messages. Lets core UI and plugins add contextual buttons (copy, retry, favorite, etc.) in a consistent order with minimal wiring.

---

## What it does

`useMessageActions` maintains a global list of action descriptors keyed by an id. Components register their actions once, and when rendering an individual message you can pull the filtered, sorted list for that message’s role.

-   Stores actions in a singleton Map (survives HMR)
-   Exposes helpers to register/unregister actions
-   Provides a computed list scoped to user or assistant messages
-   Supports ordering via an optional `order` property (default 200)

---

## Registering an action

```ts
import { registerMessageAction } from '~/composables/chat/useMessageActions';

registerMessageAction({
    id: 'copy-text',
    icon: 'i-heroicons-clipboard-document',
    tooltip: 'Copy to clipboard',
    showOn: 'assistant',
    order: 150,
    async handler({ message }) {
        await navigator.clipboard.writeText(message.text);
    },
});
```

Built-in actions from core components typically use orders below 200. Plugins can pick `order >= 200` to appear after defaults unless they intentionally override.

---

## API

| Export                             | Type                                                                             | Description                                                           |
| ---------------------------------- | -------------------------------------------------------------------------------- | --------------------------------------------------------------------- |
| `registerMessageAction(action)`    | `(action: ChatMessageAction) => void`                                            | Add or replace an action descriptor in the registry.                  |
| `unregisterMessageAction(id)`      | `(id: string) => void`                                                           | Remove an action by id (optional cleanup).                            |
| `useMessageActions(message)`       | `(message: { role: 'user' \| 'assistant' }) => ComputedRef<ChatMessageAction[]>` | Get a computed, role-filtered, ordered list for a specific message.   |
| `listRegisteredMessageActionIds()` | `() => string[]`                                                                 | Return all registered ids (useful for debugging or collision checks). |

### `ChatMessageAction`

```ts
interface ChatMessageAction {
    id: string;
    icon: string;
    tooltip: string;
    showOn: 'user' | 'assistant' | 'both';
    order?: number; // defaults to 200
    handler: (ctx: { message: any; threadId?: string }) => void | Promise<void>;
}
```

---

## Using in a component

```vue
<template>
    <div class="message-actions">
        <UButton
            v-for="action in actions"
            :key="action.id"
            :icon="action.icon"
            variant="ghost"
            size="xs"
            :aria-label="action.tooltip"
            @click="action.handler({ message, threadId })"
        />
    </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useMessageActions } from '~/composables/chat/useMessageActions';

const props = defineProps<{
    message: { role: 'user' | 'assistant'; id: string };
}>();
const threadId = useCurrentThreadId();

const actionsComputed = useMessageActions(props.message);
const actions = computed(() => actionsComputed.value);
</script>
```

---

## Internals

1. **Registry Map** — Stored on `globalThis` so repeated imports share data even with HMR.
2. **Reactive mirror** — A `reactiveList` array mirrors the Map contents so Vue can track changes. Every register/unregister call re-syncs the array.
3. **Computed filtering** — `useMessageActions` filters `reactiveList.items` based on `showOn` and sorts by `order ?? 200`.
4. **Cleanup** — `unregisterMessageAction` helps modules remove actions when disabled or disposed.

---

## Tips & edge cases

-   **ID collisions**: registering with an existing `id` overwrites the previous action; use `listRegisteredMessageActionIds()` to audit.
-   **Async handlers**: You can return promises; the caller decides whether to await or fire-and-forget.
-   **Context object**: `handler` receives `{ message, threadId }`; extend as needed but keep the shape consistent for plugin compatibility.
-   **Role filtering**: Use `showOn: 'both'` for universal actions (e.g., “pin”), otherwise scope to `user` or `assistant`.

---

## Related modules

-   `ChatMessage.vue` — built-in consumer that renders the buttons.
-   `useMessageEditing` — often paired to expose “Edit message” action.
-   `pane plugin API` — natural spot to add custom actions when a plugin activates.
````

## File: composables/useMessageEditing.md
````markdown
# useMessageEditing

Encapsulates the UI + persistence flow for editing a chat message. Handles toggling edit mode, keeping a draft buffer, and writing the updated content back to Dexie.

---

## What it handles

`useMessageEditing` wraps all state required for an inline message editor:

-   Tracks whether the message is currently being edited
-   Keeps a draft copy of the text with undo (cancel) support
-   Persists the change to the `messages` table via `upsert`
-   Works with plain objects or `Ref`-wrapped messages (streaming tail vs finalized)

---

## Quick example

```ts
import { useMessageEditing } from '~/composables/chat/useMessageEditing';

const props = defineProps<{ message: UiChatMessage }>();
const editing = useMessageEditing(props.message);

function onSave() {
    editing.saveEdit();
}
```

In a template you can wire the state like this:

```vue
<template>
    <div v-if="editing.editing.value" class="message-editor">
        <textarea v-model="editing.draft.value" rows="3" class="retro-input" />
        <div class="flex gap-2 mt-2">
            <button
                class="retro-btn"
                :disabled="editing.saving.value"
                @click="editing.saveEdit"
            >
                Save
            </button>
            <button
                class="retro-btn"
                :disabled="editing.saving.value"
                @click="editing.cancelEdit"
            >
                Cancel
            </button>
        </div>
    </div>
    <div v-else>
        {{ props.message.text }}
        <button class="retro-btn" @click="editing.beginEdit">Edit</button>
    </div>
</template>
```

---

## API

| Property / Method | Type                  | Description                                                             |
| ----------------- | --------------------- | ----------------------------------------------------------------------- |
| `editing`         | `Ref<boolean>`        | `true` while the UI is in edit mode.                                    |
| `draft`           | `Ref<string>`         | Draft text bound to the editor input.                                   |
| `original`        | `Ref<string>`         | Snapshot of the message content before editing (used for cancel).       |
| `saving`          | `Ref<boolean>`        | `true` while the composable is persisting the update.                   |
| `beginEdit()`     | `() => void`          | Initialise draft/original values and switch to edit mode.               |
| `cancelEdit()`    | `() => void`          | Exit edit mode without saving, resetting buffers.                       |
| `saveEdit()`      | `() => Promise<void>` | Persist trimmed draft text to Dexie and update the live message object. |

### Message input contract

The `message` argument can be:

-   A `UiChatMessage` object with `text` and/or `content`
-   A `Ref` wrapping such an object (useful when the message swaps underneath, e.g., streaming tail to stored message)

`saveEdit()` writes the new text to both `content` and `text` if present so renderers stay in sync.

---

## Under the hood

1. **Message accessor** — `getMessage()` unwraps refs and returns the latest object before each action.
2. **Draft prep** — `beginEdit()` pulls the existing content from `message.content` or falls back to `message.text`.
3. **Persistence** — `saveEdit()` fetches the stored record via `db.messages.get(id)` and calls `upsert.message(...)` with the updated text and `updated_at` timestamp.
4. **State updates** — After persistence, it updates the in-memory message object so the UI reflects the new content immediately.
5. **Guard rails** — Empty drafts short-circuit to `cancelEdit()`. Missing IDs abort silently.

---

## Tips & edge cases

-   **Streaming messages**: Because it accepts refs, you can start editing a message that transitions from “tail” to finalized without losing the editor state.
-   **Concurrent edits**: `saving` prevents duplicate writes; external overrides should listen for `saving.value` before issuing new edits.
-   **No-op on blank**: Saving trims whitespace; if the result is empty it cancels instead of writing an empty record.
-   **Error handling**: Errors during persistence are caught by the `try/finally` block—state resets `saving` back to `false`, but you might want to wrap `saveEdit()` in a try/catch to display UI feedback.

---

## Related composables

-   `useMessageActions` — expose an “Edit” action that toggles this composable.
-   `useChat` — source of `UiChatMessage` records this composable edits.
-   `~/db/upsert` — the Dexie helper invoked during `saveEdit()`.
````

## File: composables/useModelStore.md
````markdown
# useModelStore

Shared catalog + favorites manager for OpenRouter models. Centralises fetching, caching, and filtering so every pane sees the same list without repeated network hits.

---

## Responsibilities

`useModelStore` exposes reactive state for the model catalog, favorites, search query, and filters. It layers three cache tiers (memory → Dexie → network) and dedupes concurrent fetches. Consumers can refresh, invalidate, or persist favorites with a single call.

-   Hydrates catalog from memory, Dexie (`kv` table), or network
-   Persists the catalog in Dexie for 48 hours by default
-   Dedupes in-flight fetches across callers
-   Manages favorites with persistence to `kv`
-   Exposes helper refs for search/filter UI

---

## Quick start

```ts
import { useModelStore } from '~/composables/chat/useModelStore';

const {
    catalog,
    favoriteModels,
    fetchModels,
    addFavoriteModel,
    removeFavoriteModel,
    searchQuery,
    filters,
} = useModelStore();

await fetchModels();
searchQuery.value = 'claude';
await addFavoriteModel(catalog.value[0]);
```

---

## API

| Export                       | Type                                                                                                             | Description                                                       |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `catalog`                    | `Ref<OpenRouterModel[]>`                                                                                         | Reactive catalog of models.                                       |
| `favoriteModels`             | `Ref<OpenRouterModel[]>`                                                                                         | Models the user has favorited (persisted).                        |
| `searchQuery`                | `Ref<string>`                                                                                                    | Shared search string for UI components.                           |
| `filters`                    | `Ref<{ input?: string[]; output?: string[]; minContext?: number; parameters?: string[]; price?: PriceBucket; }>` | Reactive filter state.                                            |
| `lastLoadedAt`               | `Ref<number \| undefined>`                                                                                       | Timestamp (ms) of the most recent catalog load.                   |
| `fetchModels(opts?)`         | `(opts?: { force?: boolean; ttlMs?: number }) => Promise<OpenRouterModel[]>`                                     | Populate catalog using cache layers; respects TTL unless `force`. |
| `refreshModels()`            | `() => Promise<OpenRouterModel[]>`                                                                               | Shortcut for `fetchModels({ force: true })`.                      |
| `invalidate()`               | `() => Promise<void>`                                                                                            | Clear memory cache and delete Dexie entry.                        |
| `getFavoriteModels()`        | `() => Promise<OpenRouterModel[]>`                                                                               | Load favorites from `kv` into memory.                             |
| `addFavoriteModel(model)`    | `(model: OpenRouterModel) => Promise<void>`                                                                      | Append to favorites (deduped) and persist.                        |
| `removeFavoriteModel(model)` | `(model: OpenRouterModel) => Promise<void>`                                                                      | Remove favorite and persist.                                      |
| `clearFavoriteModels()`      | `() => Promise<void>`                                                                                            | Remove all favorites and persist.                                 |

Constants:

```ts
MODELS_CACHE_KEY = 'MODELS_CATALOG';
MODELS_TTL_MS = 48 * 60 * 60 * 1000; // 48 hours
```

---

## Usage patterns

### Populate a model picker

```ts
const { catalog, fetchModels, searchQuery, filters } = useModelStore();

await fetchModels();

const filteredModels = computed(() => {
    return catalog.value.filter((model) => {
        if (searchQuery.value && !model.id.includes(searchQuery.value)) {
            return false;
        }
        if (
            filters.value.price &&
            model.price?.bucket !== filters.value.price
        ) {
            return false;
        }
        return true;
    });
});
```

### Sync favorites to UI

```ts
const {
    favoriteModels,
    addFavoriteModel,
    removeFavoriteModel,
    getFavoriteModels,
} = useModelStore();

await getFavoriteModels();

function toggleFavorite(model: OpenRouterModel) {
    if (favoriteModels.value.some((m) => m.id === model.id)) {
        removeFavoriteModel(model);
    } else {
        addFavoriteModel(model);
    }
}
```

### Force-refreshing the catalog

```ts
const { refreshModels } = useModelStore();

await refreshModels(); // bypasses cache and hits the network
```

---

## Internals

1. **Singleton refs** — `catalog`, `favoriteModels`, `filters`, etc. live at module scope so every caller shares the same reactive data.
2. **Cache layers** — `fetchModels` tries memory first, then Dexie (if supported), then network. TTL is configurable per call.
3. **Dexie persistence** — Catalog is stored via `kv.set(MODELS_CACHE_KEY, JSON.stringify(list))`; timestamps come from `rec.updated_at` (seconds) and are compared against the TTL.
4. **In-flight dedupe** — Network fetches share a module-level `inFlight` promise so parallel callers await the same request.
5. **Favorites persistence** — Favorites use a separate `kv` key (`favorite_models`) and are stored as JSON.
6. **Error handling** — On network failure it attempts to serve stale Dexie data; JSON parse failures purge the corrupt record.

---

## Tips & edge cases

-   **IndexedDB availability**: `canUseDexie()` guards against SSR and private modes that block IndexedDB. If Dexie is unavailable, caching falls back to memory only.
-   **TTL overrides**: Pass `fetchModels({ ttlMs: 15 * 60 * 1000 })` to tighten freshness requirements for specific views.
-   **Favorites dedupe**: `addFavoriteModel` ignores duplicates by `model.id`.
-   **Invalidation**: After calling `invalidate()`, make sure to call `fetchModels()` again to repopulate memory.
-   **Persistent filters/search**: Since refs are shared, updating `searchQuery` in one component immediately affects others (intended for synchronized UI).

---

## Related modules

-   `models-service` — underlying fetcher for OpenRouter models.
-   `kv` helpers — Dexie-backed storage used for both catalog and favorites.
-   `useAiSettings` — may use this store to pick the default model.
````

## File: composables/useMultiPane.md
````markdown
# useMultiPane

State manager that powers OR3’s multi-pane chat/document workspace. It keeps the active pane list, loads messages on demand, enforces pane limits, and fires hook events so plugins can react to pane lifecycle changes.

---

## What does it do?

`useMultiPane` centralises all window management logic outside the UI layer:

-   Creates, focuses, and closes panes with automatic fallback when the last pane would disappear
-   Loads chat message history for each pane (with Dexie-backed fallback)
-   Tracks the active pane index, preventing focus bugs
-   Emits hook events for pane open/close/switch so extensions stay in sync
-   Supports a configurable pane cap, custom message loaders, and document flush callbacks

---

## Basic Example

```ts
import { useMultiPane } from '~/composables/core/useMultiPane';

const multiPane = useMultiPane({ initialThreadId: 'thread-123', maxPanes: 4 });

multiPane.addPane();
await multiPane.setPaneThread(1, 'thread-456');
multiPane.setActive(1);
```

---

## How to use it

### 1. Create the store

```ts
const multiPane = useMultiPane({
    initialThreadId: '',
    maxPanes: 3,
    onFlushDocument: async (docId) => {
        await saveDraft(docId);
    },
});
```

### 2. Bind to UI

Use `multiPane.panes` to render your pane tabs and `multiPane.activePaneIndex` to highlight the current one. Buttons can call `addPane`, `closePane(i)`, or `setActive(i)`.

### 3. Load or switch chats

Hook `setPaneThread(index, threadId)` to any thread picker.

```ts
await multiPane.setPaneThread(activeIndex.value, selectedThreadId);
```

### 4. Keyboard shortcuts

`focusPrev(current)` and `focusNext(current)` make it easy to wire ⌥← / ⌥→ navigation.

### 5. Keep at least one pane alive

Call `ensureAtLeastOne()` if you manipulate `panes` directly (rare, but handy in dev tools).

---

## API

```ts
const multiPane = useMultiPane(options?: UseMultiPaneOptions);
```

| Option            | Type                                                | Description                                                      |
| ----------------- | --------------------------------------------------- | ---------------------------------------------------------------- |
| `initialThreadId` | `string`                                            | Starting thread for the first pane (empty string for new chat).  |
| `maxPanes`        | `number`                                            | Maximum simultaneous panes (default `3`).                        |
| `onFlushDocument` | `(id: string) => void \| Promise<void>`             | Called before closing a document pane so you can persist drafts. |
| `loadMessagesFor` | `(threadId: string) => Promise<MultiPaneMessage[]>` | Override message loader (defaults to Dexie query).               |

### Returned object

| Property / Method                | Type                                                 | Purpose                                                                 |
| -------------------------------- | ---------------------------------------------------- | ----------------------------------------------------------------------- |
| `panes`                          | `Ref<PaneState[]>`                                   | Reactive list of panes in open order.                                   |
| `activePaneIndex`                | `Ref<number>`                                        | Index of the currently focused pane.                                    |
| `canAddPane`                     | `ComputedRef<boolean>`                               | `true` when below `maxPanes`.                                           |
| `newWindowTooltip`               | `ComputedRef<string>`                                | Pre-baked tooltip text for “new pane” buttons.                          |
| `addPane()`                      | `() => void`                                         | Append a blank pane and focus it.                                       |
| `closePane(index)`               | `(index: number) => Promise<void> \| void`           | Close a pane; never removes the last one.                               |
| `setActive(index)`               | `(index: number) => void`                            | Mark a pane as focused, firing switch hooks.                            |
| `focusPrev(current)`             | `(current: number) => void`                          | Focus the previous pane if available.                                   |
| `focusNext(current)`             | `(current: number) => void`                          | Focus the next pane if available.                                       |
| `setPaneThread(index, threadId)` | `(index: number, threadId: string) => Promise<void>` | Load messages for a chat and attach it to the pane. Pass `''` to clear. |
| `loadMessagesFor`                | `(threadId: string) => Promise<MultiPaneMessage[]>`  | Exposed loader (useful for tests).                                      |
| `ensureAtLeastOne()`             | `() => void`                                         | Guarantees at least one pane exists.                                    |

`PaneState` consists of:

```ts
interface PaneState {
    id: string;
    mode: 'chat' | 'doc';
    threadId: string;
    documentId?: string;
    messages: MultiPaneMessage[];
    validating: boolean;
}
```

---

## Under the hood

1. **Pane creation** — `createEmptyPane()` generates a UUID (via `crypto.randomUUID` fallback) and seeds a blank chat pane.
2. **Message loading** — The default loader queries Dexie for non-deleted messages, normalises content/reasoning text, and returns a lightweight list suited for pane previews.
3. **Hooks integration** — Every major action (`open`, `close`, `switch`, `active`, `blur`, thread changes) dispatches hook events so plugins and side panels can respond.
4. **Focus logic** — `setActive` handles focus order, blur hooks, and ensures active index stays in range when panes close.
5. **Global exposure** — Stores the API on `globalThis.__or3MultiPaneApi` so extensions or devtools can orchestrate panes externally.

---

## Edge cases & tips

-   **Thread veto**: Filters registered on `ui.pane.thread:filter:select` can return `false` to block a thread switch.
-   **Document panes**: When `mode === 'doc'` and `documentId` is set, `closePane` calls `onFlushDocument` before removing the pane—use it to save unsaved edits.
-   **Pane limit**: `addPane()` silently no-ops once `maxPanes` is reached; pair with `canAddPane` to disable UI affordances.
-   **Hot reload**: On HMR the latest instance overwrites `__or3MultiPaneApi`, so developer tooling always hits the freshest store.
-   **Testing**: Pass `loadMessagesFor` to inject fixtures without touching Dexie.

---

## Related

-   `usePanePrompt` — tracks pending system prompts per pane.
-   `useChat` — main consumer of pane message state.
-   Hooks: `ui.pane.*` actions/filters documented in `docs/core-hook-map.md`.
````

## File: composables/usePaneDocuments.md
````markdown
# usePaneDocuments

Pane-aware controller that lets the dashboard create or switch documents inside the multi-pane workspace. It glues `useDocumentsStore`, pane state, and hook events into two ergonomic methods.

---

## What does it do?

`usePaneDocuments({ panes, activePaneIndex, createNewDoc, flushDocument })` returns helpers that:

-   Create a fresh document in the active pane while flushing/releasing the previous one.
-   Switch the active pane to a different document, honouring hook vetoes and autosave semantics.
-   Emit `$hooks` actions (`ui.pane.doc:action:saved`, `:changed`) so listeners react to transitions.
-   Reuse `useDocumentState` + `releaseDocument` to keep autosave + memory management consistent.

---

## Basic Example

```ts
import { usePaneDocuments } from '~/composables/documents/usePaneDocuments';
import { useMultiPane } from '~/composables/core/useMultiPane';
import { newDocument, flush } from '~/composables/documents/useDocumentsStore';

const { panes, activePaneIndex } = useMultiPane();

const { newDocumentInActive, selectDocumentInActive } = usePaneDocuments({
    panes,
    activePaneIndex,
    createNewDoc: (initial) => newDocument(initial),
    flushDocument: (id) => flush(id),
});

await newDocumentInActive({ title: 'Meeting notes' });
await selectDocumentInActive(existingDocId);
```

---

## How to use it

### 1. Supply pane + document dependencies

-   `panes` / `activePaneIndex` come from `useMultiPane`.
-   `createNewDoc` should return `{ id }` for the newly created record.
-   `flushDocument` flushes staged changes for a given ID (usually `flush()` from `useDocumentsStore`).

### 2. Create a document in the active pane

`await newDocumentInActive(initial?)`:

-   Flushes + releases the currently bound doc (if any), emitting `ui.pane.doc:action:saved` when staged changes existed.
-   Creates the new record via `createNewDoc`.
-   Runs `ui.pane.doc:filter:select` filters, allowing plugins to veto/redirect.
-   Updates the pane (`mode = 'doc'`, sets `documentId`, clears chat state) and fires `ui.pane.doc:action:changed` with `{ created: true }` metadata.

### 3. Switch the active pane to another document

`await selectDocumentInActive(id)`:

-   Applies the same select filter to allow vetoes.
-   Flushes + saves pending edits on the current doc when switching away and emits the saved action if needed.
-   Releases the previous document state to free memory.
-   Updates the pane bindings and emits `ui.pane.doc:action:changed` with `reason: 'select'`.

### 4. Respect hook vetoes

If any filter returns `false`, both helpers abort without changing the pane. Use this to block navigation when validations fail.

---

## What you get back

| Method                          | Returns                                | Description                                                                                  |
| ------------------------------- | -------------------------------------- | -------------------------------------------------------------------------------------------- |
| `newDocumentInActive(initial?)` | `Promise<{ id: string } \| undefined>` | Creates a doc in the active pane; returns the record summary or `undefined` on failure/veto. |
| `selectDocumentInActive(id)`    | `Promise<void>`                        | Switches the active pane to `id`; no-op if vetoed or invalid.                                |

Both methods run asynchronously and should be awaited to ensure flushes complete before continuing.

---

## Under the hood

1. **Pane lookup** – Reads the current pane via `panes.value[activePaneIndex.value]`.
2. **Pending change detection** – Uses `useDocumentState()` to check `pendingTitle`/`pendingContent` before emitting saved events.
3. **Hooks integration** – Utilises `useHooks()` to call `applyFilters('ui.pane.doc:filter:select', ...)` and `doAction('ui.pane.doc:action:changed' | '...:saved')`.
4. **Memory cleanup** – Calls `releaseDocument(id, { flush: false })` after switching to avoid lingering TipTap trees.
5. **Resets chat state** – Clears `threadId` and `messages` when moving panes back to document mode.

---

## Edge cases & tips

-   **Null pane**: If no pane exists at the active index, helpers exit early.
-   **Duplicate select**: Selecting the already-active doc short-circuits after reset; no extra hook events fire.
-   **Error suppression**: Internal `try { ... } catch {}` blocks ensure hook misbehaviour doesn’t crash the UX—but you should still log within your own filters/actions.
-   **Testing**: You can stub `createNewDoc` / `flushDocument` to use in Vitest without hitting Dexie.

---

## Related

-   `useDocumentsStore` — provides `flush`, `releaseDocument`, and state inspection.
-   `useMultiPane` — pane state machine consumed by this helper.
-   `~/core/hooks/useHooks` — hook engine used for filters/actions.

---

## TypeScript

```ts
interface UsePaneDocumentsOptions {
    panes: Ref<MultiPaneState[]>;
    activePaneIndex: Ref<number>;
    createNewDoc: (initial?: { title?: string }) => Promise<{ id: string }>;
    flushDocument: (id: string) => Promise<void> | void;
}

interface UsePaneDocumentsApi {
    newDocumentInActive(initial?: {
        title?: string;
    }): Promise<{ id: string } | undefined>;
    selectDocumentInActive(id: string): Promise<void>;
}
```
````

## File: composables/usePanePrompt.md
````markdown
# usePanePrompt

Tiny helper that tracks a “pending system prompt” per pane. It lets the UI stage a prompt that will be applied when the user creates their next thread in that pane.

---

## What does it do?

`usePanePrompt` exposes three functions backed by a reactive map:

-   `setPanePendingPrompt(paneId, promptId)` — stage a prompt identifier
-   `getPanePendingPrompt(paneId)` — read the pending prompt (if any)
-   `clearPanePendingPrompt(paneId)` — forget the association once it’s used

Because the backing store is reactive, other consumers can watch it for UI hints, and HMR/devtools expose the map for inspection.

---

## Basic Example

```ts
import {
    setPanePendingPrompt,
    getPanePendingPrompt,
    clearPanePendingPrompt,
} from '~/composables/core/usePanePrompt';

setPanePendingPrompt('pane-1', 'prompt-active-user');

const pending = getPanePendingPrompt('pane-1');
// => 'prompt-active-user'

clearPanePendingPrompt('pane-1');
```

---

## How to use it

### 1. Stage a prompt when the user picks one

When the prompt selector changes, call `setPanePendingPrompt(paneId, promptId)` so the next thread creation uses it.

### 2. Read before creating a thread

Inside your thread creation flow, read `getPanePendingPrompt(paneId)` and pass the ID to the chat builder if it exists.

### 3. Clear after applying

Once the system prompt is attached to the thread, call `clearPanePendingPrompt(paneId)` to avoid reusing it accidentally.

---

## API

```ts
setPanePendingPrompt(paneId: string, promptId: string | null): void;
getPanePendingPrompt(paneId: string): string | null | undefined;
clearPanePendingPrompt(paneId: string): void;
```

| Function                 | Description                                                                             |
| ------------------------ | --------------------------------------------------------------------------------------- |
| `setPanePendingPrompt`   | Store the prompt ID (or `null` to explicitly clear it).                                 |
| `getPanePendingPrompt`   | Return the stored ID, `null` if explicitly cleared, or `undefined` if it was never set. |
| `clearPanePendingPrompt` | Remove the key entirely from the map.                                                   |

The underlying map lives in a `reactive({})`, so Vue watchers/computed values respond to changes.

---

## Under the hood

1. Keeps a module-level reactive object `pendingByPane` keyed by pane ID.
2. Exported helpers mutate or read that map directly.
3. In dev mode, the map is exposed on `globalThis.__or3PanePendingPrompts` for debugging.

There’s no persistence; entries reset on full reload.

---

## Edge cases & tips

-   **`null` vs `undefined`**: A stored `null` means “explicitly cleared”, while `undefined` means nothing was ever set for that pane.
-   **No SSR concerns**: The composable uses in-memory state only; safe to import anywhere.
-   **Pane lifecycle**: When a pane closes, remember to call `clearPanePendingPrompt` if you want to drop staged prompts immediately.

---

## Related

-   `useMultiPane` — orchestrates pane state and is a natural place to call these helpers.
-   `useActivePrompt` — resolves prompt details once you have the ID.
-   Hooks `ui.pane.thread:action:changed` — good trigger for clearing pending prompts.
````

## File: composables/usePreviewCache.md
````markdown
# usePreviewCache

In-memory LRU-ish cache for preview assets (images, PDFs, etc.). It wraps blob URL creation, tracks byte usage, exposes metrics, and handles eviction with pinning so priority previews stick around.

---

## What does it do?

`usePreviewCache` gives you a reusable cache instance that:

-   Normalises preview options via `resolvePreviewCacheOptions`
-   Provides `ensure()` to fetch or reuse cached URLs
-   Tracks hits/misses/evictions for telemetry
-   Supports pinning entries to avoid eviction while in view
-   Offers helpers to promote, release, drop, and flush entries

An additional `useSharedPreviewCache` exposes a singleton cache shared across the app.

---

## Basic Example

```ts
import { usePreviewCache } from '~/composables/core/usePreviewCache';

const cache = usePreviewCache({ maxUrls: 50, maxBytes: 50 * 1024 * 1024 });

const url = await cache.ensure('file:123', async () => {
    const blob = await fetchPreviewBlob();
    return { url: URL.createObjectURL(blob), bytes: blob.size };
});

img.src = url;
```

---

## How to use it

### 1. Create or grab the cache

```ts
const cache = useSharedPreviewCache();
// or
const cache = usePreviewCache({ maxUrls: 100, maxBytes: 80 * 1024 * 1024 });
```

### 2. Ensure previews exist

Call `ensure(key, loader, pin?)` to fetch or reuse a preview URL.

```ts
const url = await cache.ensure(hash, () => buildPreview(hash), 1);
```

### 3. Manage lifecycle

-   `promote(key)` when a preview becomes visible
-   `release(key)` when it scrolls off-screen
-   `drop(key)` or `flushAll()` to manually clear

### 4. Monitor usage

`cache.metrics()` reports counts and total bytes; `cache.logMetrics(stage)` dumps them to the console in dev builds.

---

## API

```ts
const cache = usePreviewCache(options?: Partial<PreviewCacheOptions>);
```

| Method          | Signature                                             | Description                                                                               |
| --------------- | ----------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| `ensure`        | `(key, loader, pin?) => Promise<string \| undefined>` | Return cached URL or call `loader()` to create one. Updates LRU data and enforces limits. |
| `promote`       | `(key, pin?) => void`                                 | Bump access counter and raise pin weight.                                                 |
| `release`       | `(key) => void`                                       | Lower pin count after a preview is no longer critical.                                    |
| `drop`          | `(key) => boolean`                                    | Remove a single entry and revoke the blob URL.                                            |
| `flushAll`      | `() => string[]`                                      | Remove every entry, returning the keys dropped.                                           |
| `evictIfNeeded` | `(stage?) => string[]`                                | Enforce `maxUrls`/`maxBytes`; returns evicted keys.                                       |
| `metrics`       | `() => PreviewCacheMetrics`                           | Snapshot of cache size, bytes, hits, misses, evictions.                                   |
| `logMetrics`    | `(stage) => void`                                     | Console log (dev only).                                                                   |
| `peek`          | `(key) => string \| undefined`                        | Read URL without mutating access counters.                                                |
| `options`       | `PreviewCacheOptions`                                 | Resolved options (max counts, etc.).                                                      |

`useSharedPreviewCache(overrides?)` returns a singleton instance; overrides only apply to the first call (later overrides warn in dev). `resetSharedPreviewCache()` flushes and clears the singleton reference.

---

## Under the hood

1. **Options resolution** — Merges partial overrides with defaults via `resolvePreviewCacheOptions`.
2. **Map storage** — Maintains a `Map<key, CacheEntry>` with metadata (`bytes`, `pin`, `lastAccess`).
3. **LRU eviction** — When limits are exceeded, entries sort by pin weight then `lastAccess`; unpinned, least-recent entries fall out first.
4. **Blob revocation** — `remove()` revokes object URLs via `URL.revokeObjectURL` to avoid leaks.
5. **Metrics** — Hits/misses/evictions counters increment inside `ensure()`/`evictIfNeeded()`; `metrics()` packages them for dashboards.

---

## Edge cases & tips

-   **Pinning**: `pin` is additive—pass higher numbers to make an item harder to evict (e.g., 2 for hero previews). Remember to `release`.
-   **Loader bytes**: If the loader omits `bytes`, the cache assumes `0`. Supplying the blob size keeps eviction accurate.
-   **Shared cache overrides**: Only the first call to `useSharedPreviewCache` respects overrides; later calls log a warning when options differ.
-   **Server-side rendering**: Safe to import, but loaders should guard against browser-only APIs (e.g., `URL.createObjectURL`).
-   **Diagnostics**: Call `logMetrics('stage-name')` in dev to trace eviction behavior.

---

## Related

-   `preview-cache` config (`~/config/preview-cache.ts`) — default limits and resolver.
-   `useWorkspaceBackup` — another heavy I/O composable that benefits from previews for status screens.
-   `useSharedPreviewCache` / `resetSharedPreviewCache` — exported alongside this composable for global cache reuse.
````

## File: composables/useProjectsCrud.md
````markdown
# useProjectsCrud

Project CRUD toolkit that wraps Dexie helpers with validation, timestamping, and data normalisation for OR3 project records.

---

## What does it do?

`useProjectsCrud()` returns methods to create, rename, delete, and update projects:

-   `createProject` builds a new record with generated IDs, timestamps, and trimmed input.
-   `renameProject` validates titles and upserts updates.
-   `deleteProject` supports soft and hard delete flows.
-   `updateProjectEntries` replaces the project’s `data` array with normalised entries.
-   `syncProjectEntryTitle` propagates entry title/kind updates across every project reference.

Each helper uses the shared Dexie `db` instance under the hood.

---

## Basic Example

```ts
import { useProjectsCrud } from '~/composables/projects/useProjectsCrud';

const {
    createProject,
    renameProject,
    deleteProject,
    updateProjectEntries,
    syncProjectEntryTitle,
} = useProjectsCrud();

const projectId = await createProject({
    name: 'Design Sprint',
    description: 'Week-long challenge',
});

await renameProject(projectId, 'Design Sprint Q3');

await updateProjectEntries(projectId, [
    { id: 'doc-1', name: 'Brief', kind: 'doc' },
    { id: 'chat-8', name: 'AI brainstorm', kind: 'chat' },
]);

await deleteProject(projectId, { soft: true });
```

---

## How to use it

### 1. Instantiate once per setup

Call `const api = useProjectsCrud()` in composables or components. The returned methods are stateless and can be reused across calls.

### 2. Create projects

-   `createProject({ name, description?, id? })` trims input, generates defaults, and writes via `create.project`.
-   Returns the new project ID so you can navigate or open panes immediately.

### 3. Update metadata

-   `renameProject(id, name)` trims the new name and ensures the project exists before upserting.
-   `updateProjectEntries(id, entries)` clones the array before persisting to avoid mutating callers.

### 4. Delete projects

-   Soft delete (default) marks the record via `del.soft.project`.
-   Hard delete (`{ soft: false }`) removes it entirely via `del.hard.project`.

### 5. Sync linked entry titles

`syncProjectEntryTitle(entryId, kind, title)` iterates every project, normalises `data`, and updates matching entries—useful when a document/chat is renamed elsewhere.

---

## What you get back

`useProjectsCrud()` returns:

| Method                                        | Description                                                                           |
| --------------------------------------------- | ------------------------------------------------------------------------------------- |
| `createProject(input)`                        | Creates a project; throws if name missing. Returns new ID.                            |
| `renameProject(id, name)`                     | Renames an existing project; throws if not found or name empty.                       |
| `deleteProject(id, options?)`                 | Soft or hard deletes a project.                                                       |
| `updateProjectEntries(id, entries)`           | Replaces the project’s `data` array after cloning entries.                            |
| `syncProjectEntryTitle(entryId, kind, title)` | Updates matching entry names across all projects; returns number of projects touched. |

---

## Under the hood

1. **Dexie helpers** – Calls `create.project`, `upsert.project`, `del.soft.project`, `del.hard.project`, and `db.projects.bulkPut`.
2. **Timestamps** – Uses `nowSec()` for `created_at`/`updated_at`, ensuring consistent epoch seconds throughout the app.
3. **ID generation** – Defaults to `newId()` when callers omit `id`.
4. **Normalisation** – Clones entry objects and relies on `normalizeProjectData` to accommodate legacy formats.
5. **Bulk updates** – `syncProjectEntryTitle` batches writes with `bulkPut` to minimise Dexie transactions.

---

## Edge cases & tips

-   **Empty names**: Helpers throw if the provided name is blank after trimming—handle errors in your UI.
-   **Missing project**: `renameProject` and `updateProjectEntries` throw when `db.projects.get` can’t find the ID.
-   **Concurrent edits**: `clock` isn’t mutated here; if you rely on CRDT syncs, adjust the payload before calling `upsert`.
-   **Entry kind**: `syncProjectEntryTitle` supplies `kind` when missing so downstream UIs can rely on it.
-   **Soft delete recovery**: Soft-deleted records still exist; build admin tooling to restore if required.

---

## Related

-   `useProjectTreeActions` — UI actions for projects and their entries.
-   `~/utils/projects/normalizeProjectData` — ensures project `data` arrays follow the latest schema.
-   `~/db/projects` — Dexie schema and helper exports referenced here.

---

## TypeScript

```ts
interface CreateProjectInput {
    name: string;
    description?: string | null;
    id?: string;
}

interface DeleteProjectOptions {
    soft?: boolean;
}

type ProjectEntry = {
    id: string;
    name: string;
    kind?: ProjectEntryKind;
    [key: string]: any;
};

function useProjectsCrud(): {
    createProject(input: CreateProjectInput): Promise<string>;
    renameProject(id: string, name: string): Promise<void>;
    deleteProject(id: string, options?: DeleteProjectOptions): Promise<void>;
    updateProjectEntries(id: string, entries: ProjectEntry[]): Promise<void>;
    syncProjectEntryTitle(
        entryId: string,
        kind: ProjectEntryKind,
        title: string
    ): Promise<number>;
};
```
````

## File: composables/useProjectTreeActions.md
````markdown
# useProjectTreeActions

Extensible action registry for the project tree sidebar. Lets plugins add context buttons to project rows or child entries (documents, chats) with ordering and visibility controls.

---

## What does it do?

`useProjectTreeActions` builds on the generic `createRegistry` utility to provide:

-   `registerProjectTreeAction()` to add or replace project tree actions.
-   `useProjectTreeActions()` to retrieve a reactive, sorted list of actions.
-   `unregisterProjectTreeAction()` for cleanup.
-   `listRegisteredProjectTreeActionIds()` to inspect current registrations.

Actions can target project roots, all rows, or specific child kinds (`chat`, `doc`) via `showOn` filters.

---

## Basic Example

```ts
import {
    registerProjectTreeAction,
    unregisterProjectTreeAction,
    useProjectTreeActions,
} from '~/composables/projects/useProjectTreeActions';

registerProjectTreeAction({
    id: 'custom:open-in-new-pane',
    icon: 'i-ph-squares-four',
    label: 'Open in new pane',
    order: 180,
    showOn: ['doc', 'chat'],
    async handler({ treeRow }) {
        if ('parentId' in treeRow) {
            await openEntryInFreshPane(treeRow.value);
        }
    },
});

const actions = useProjectTreeActions();

onScopeDispose(() => {
    unregisterProjectTreeAction('custom:open-in-new-pane');
});
```

---

## How to use it

### 1. Register an action

Call `registerProjectTreeAction()` when your plugin starts. Provide a unique `id`, Iconify `icon`, `label`, optional `order`, `showOn`, and an async-compatible `handler`.

### 2. Target specific rows

-   Omitting `showOn` shows the action everywhere.
-   Include `['root']` to limit to project rows.
-   Use `['doc']` or `['chat']` to target children representing documents or chat threads.

### 3. Handle the click

The handler receives `{ treeRow, child, root }`:

-   `treeRow` is always present and can be root or child.
-   `child` and `root` remain for legacy shapes—prefer `treeRow` moving forward.

### 4. Consume from the UI

`useProjectTreeActions()` returns a reactive array used by components like `SidebarProjectTree.vue`. You rarely call it yourself unless you render a custom tree UI.

### 5. Clean up

Call `unregisterProjectTreeAction()` during dispose to keep the registry tidy across HMR.

---

## API

```ts
registerProjectTreeAction(action: ProjectTreeAction): void;
unregisterProjectTreeAction(id: string): void;
useProjectTreeActions(): ComputedRef<ProjectTreeAction[]>;
listRegisteredProjectTreeActionIds(): string[];
```

---

## Under the hood

1. **Registry factory** – Uses `createRegistry('__or3ProjectTreeActionsRegistry')`, which already handles sorting, deduping, and reactivity.
2. **Ordering** – `createRegistry` sorts by `order` (default 200); ties fall back to registration order.
3. **HMR safe** – The registry lives on `globalThis`, so multiple imports share the same entries.
4. **Visibility filtering** – Consumers apply `showOn` checks before rendering buttons, ensuring minimal logic in handlers.

---

## Edge cases & tips

-   **Unknown `treeRow` shape**: Some legacy callers might pass `child`/`root`; guard your handler accordingly.
-   **Async errors**: Return promises and handle errors inside the handler—UI components don’t catch them automatically.
-   **Order collisions**: Use different `order` buckets to cluster your plugin’s actions together.
-   **Testing**: In Jest/Vitest, stub `createRegistry` with a local implementation if you want to isolate actual Dexie usage.

---

## Related

-   `useProjectsCrud` — manages the underlying Dexie project records.
-   `~/app/components/sidebar/SidebarProjectTree.vue` — consumes this registry to render contextual menus.
-   `~/utils/projects/normalizeProjectData` — helps keep tree rows consistent with stored data.

---

## TypeScript

```ts
type ProjectTreeKind = 'chat' | 'doc';
type ShowOnKind = 'root' | 'all' | 'chat' | 'doc';

interface ProjectTreeChild {
    value: string;
    label: string;
    icon?: string;
    kind?: ProjectTreeKind;
    parentId?: string;
    onSelect?: (e: Event) => void;
}

interface ProjectTreeRoot {
    value: string;
    label: string;
    defaultExpanded?: boolean;
    children?: ProjectTreeChild[];
    onSelect?: (e: Event) => void;
}

interface ProjectTreeAction {
    id: string;
    icon: string;
    label: string;
    order?: number;
    showOn?: ShowOnKind[];
    handler: (ctx: ProjectTreeHandlerCtx) => void | Promise<void>;
}
```
````

## File: composables/useSidebarSearch.md
````markdown
# useSidebarSearch

Unified search composable that indexes threads, projects, and documents for the sidebar search bar. Uses Orama for fast client-side search with a substring fallback to guarantee results.

---

## What does it do?

`useSidebarSearch(threads, projects, documents)` returns reactive state and helpers that:

-   Build (and rebuild) a shared Orama index when underlying data changes.
-   Debounce queries (120 ms) and return results grouped by type.
-   Provide a substring fallback if Orama throws or returns zero hits.
-   Track readiness/busy states and expose a manual `rebuild()` + `runSearch()` API.

The composable mirrors the pattern established in `useThreadSearch` but spans multiple datasets.

---

## Basic Example

```ts
import { useSidebarSearch } from '~/composables/sidebar/useSidebarSearch';

const threads = useThreads();
const projects = useProjects();
const documents = useDocuments();

const { query, threadResults, projectResults, documentResults, ready, busy } =
    useSidebarSearch(threads, projects, documents);

watch(query, (value) => console.debug('Searching for', value));
```

---

## How to use it

### 1. Pass in reactive sources

Provide `Ref<Thread[]>`, `Ref<Project[]>`, and `Ref<Post[]>`. The composable watches for changes and rebuilds the index only when counts or `updated_at` signatures change.

### 2. Bind the query input

`query` is a writable `ref<string>`. Watch or v-model it in your search input. Typing triggers a debounced search.

### 3. Render grouped results

Use `threadResults`, `projectResults`, and `documentResults` to populate search dropdowns or grouped lists.

### 4. Handle readiness/loading

-   `ready` flips to `true` after the first successful index build.
-   `busy` reports when the index rebuild is in progress.

### 5. Manual maintenance

-   Call `rebuild()` to force an index rebuild (e.g., after external imports).
-   Call `runSearch()` to re-run the query without changing `query.value`.

---

## What you get back

`useSidebarSearch` returns:

| Property          | Type                  | Description                                        |
| ----------------- | --------------------- | -------------------------------------------------- |
| `query`           | `Ref<string>`         | Current search string.                             |
| `threadResults`   | `Ref<Thread[]>`       | Matching threads.                                  |
| `projectResults`  | `Ref<Project[]>`      | Matching projects.                                 |
| `documentResults` | `Ref<Post[]>`         | Matching documents (filtered to non-deleted docs). |
| `ready`           | `Ref<boolean>`        | `true` once the Orama index is built.              |
| `busy`            | `Ref<boolean>`        | `true` while rebuilding.                           |
| `rebuild`         | `() => Promise<void>` | Forces index rebuild.                              |
| `runSearch`       | `() => Promise<void>` | Runs search against current query.                 |

---

## Under the hood

1. **Document signature** – `computeSignature()` combines dataset counts + latest `updated_at` to decide when to rebuild.
2. **Orama index** – Builds a schema with `id`, `kind`, `title`, `updated_at`, and indexes all eligible records.
3. **ID maps** – Maintains `id → entity` dictionaries per kind for quick result mapping.
4. **Search pipeline** – Runs Orama search with limit 500. If no hits or an error occurs, falls back to case-insensitive substring matching.
5. **Debounce** – Uses a `setTimeout` to delay searches by 120 ms, mirroring other search composables.

---

## Edge cases & tips

-   **Empty query**: Returns full datasets (threads, projects, docs) instead of empty results.
-   **Deleted docs**: Filters out posts with `postType !== 'doc'` or `deleted === true` in both index build and fallback.
-   **Index rebuild storms**: The signature guard prevents redundant rebuilds even when watchers fire frequently.
-   **Fallback warning**: Logs a warning once (`[useSidebarSearch] fallback substring search used`) to aid debugging.
-   **Stale searches**: Uses incremental `lastQueryToken` to discard results from outdated async calls.

---

## Related

-   `useThreadSearch` — single-domain search the pattern was based on.
-   `~/core/search/orama` — shared Orama helpers (`createDb`, `buildIndex`, `searchWithIndex`).
-   `~/composables/sidebar/useSidebarSections` — consumer of the search results to display grouped lists.

---

## TypeScript

```ts
function useSidebarSearch(
    threads: Ref<Thread[]>,
    projects: Ref<Project[]>,
    documents: Ref<Post[]>
): {
    query: Ref<string>;
    threadResults: Ref<Thread[]>;
    projectResults: Ref<Project[]>;
    documentResults: Ref<Post[]>;
    ready: Ref<boolean>;
    busy: Ref<boolean>;
    rebuild: () => Promise<void>;
    runSearch: () => Promise<void>;
};
```
````

## File: composables/useSidebarSections.md
````markdown
# useSidebarSections

Sidebar chrome registry that lets plugins add new panels (top/main/bottom stacks) and footer actions to the OR3 sidebar. Provides ordering, placement, visibility, and disabled control.

---

## What does it do?

`useSidebarSections` exposes two registries via the shared `_registry` factory:

-   Section registry: `registerSidebarSection()` / `useSidebarSections()` groups components by placement (`top`, `main`, `bottom`).
-   Footer action registry: `registerSidebarFooterAction()` / `useSidebarFooterActions()` manages button-style actions rendered in the sidebar footer.

Both registries share ordering semantics and dedupe logic.

---

## Basic Example

```ts
import {
    registerSidebarSection,
    unregisterSidebarSection,
    useSidebarSections,
    registerSidebarFooterAction,
    unregisterSidebarFooterAction,
} from '~/composables/sidebar/useSidebarSections';

registerSidebarSection({
    id: 'custom:tips',
    component: () => import('~/components/sidebar/TipsPanel.vue'),
    placement: 'bottom',
    order: 210,
});

registerSidebarFooterAction({
    id: 'custom:new-project',
    icon: 'i-ph-plus-circle',
    label: 'New Project',
    color: 'primary',
    handler: () => openNewProjectModal(),
});

const sections = useSidebarSections();
const footerActions = useSidebarFooterActions(() => ({
    activeThreadId: currentThreadId.value,
}));

onScopeDispose(() => {
    unregisterSidebarSection('custom:tips');
    unregisterSidebarFooterAction('custom:new-project');
});
```

---

## How to use it

### 1. Register sections

-   Provide a unique `id`, a Vue component (sync or async factory), optional `order`, and `placement`.
-   Default placement is `'main'`, which renders inside the primary scroll stack.
-   Sections are rendered as-is, so handle loading states internally for async components.

### 2. Register footer actions

-   Define Iconify `icon`, optional `label`, `tooltip`, `color`, and `order`.
-   `visible(ctx)` and `disabled(ctx)` let you tailor actions to the active thread/document or collapsed sidebar state.

### 3. Consume registries

-   `useSidebarSections()` returns a computed object `{ top, main, bottom }`, each sorted by `order`.
-   `useSidebarFooterActions(contextFn)` returns a computed array of `{ action, disabled }` entries based on the latest context.

### 4. Clean up

Call the matching `unregister*` helpers during scope disposal/HMR to prevent duplicates.

---

## What you get back

### Sections

`useSidebarSections()` → `ComputedRef<{ top: SidebarSection[]; main: SidebarSection[]; bottom: SidebarSection[] }>`

### Footer actions

`useSidebarFooterActions(contextFn)` → `ComputedRef<SidebarFooterActionEntry[]>`

Each `SidebarFooterActionEntry` contains the original action and `disabled` boolean.

---

## Under the hood

1. **Registry factory** – Uses `createRegistry('__or3SidebarSectionsRegistry')` and `createRegistry('__or3SidebarFooterActionsRegistry')`, which handle reactivity, sorting, and deduping.
2. **Default ordering** – Applies `order ?? 200` for deterministic placement relative to built-ins.
3. **Placement split** – The `useSidebarSections()` computed buckets entries by `placement` before sorting.
4. **Context evaluation** – Footer actions evaluate `visible`/`disabled` with the provided context function each render.

---

## Edge cases & tips

-   **Async components**: When `component` is a lazy import, Nuxt handles suspense; consider showing an internal loading indicator for better UX.
-   **Collapsed sidebar**: Use the `isCollapsed` flag inside footer action predicates to hide text-heavy buttons.
-   **Multiple registrations**: Re-registering with the same `id` replaces the previous entry—handy for overrides.
-   **Testing**: Mock `createRegistry` for deterministic unit tests.

---

## Related

-   `useHeaderActions` — header button registry sharing the same pattern.
-   `useComposerActions` — controls the chat composer quick actions.
-   `~/composables/_registry` — factory implementing the registry mechanics.

---

## TypeScript

```ts
type SidebarSectionPlacement = 'top' | 'main' | 'bottom';

interface SidebarSection extends RegistryItem {
    id: string;
    component: Component | (() => Promise<any>);
    order?: number;
    placement?: SidebarSectionPlacement;
}

type ChromeActionColor =
    | 'neutral'
    | 'primary'
    | 'secondary'
    | 'success'
    | 'warning'
    | 'error'
    | 'info'
    | 'inverse-primary'
    | (string & {});

interface SidebarFooterAction extends RegistryItem {
    id: string;
    icon: string;
    label?: string;
    tooltip?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: SidebarFooterActionContext) => void | Promise<void>;
    visible?: (ctx: SidebarFooterActionContext) => boolean;
    disabled?: (ctx: SidebarFooterActionContext) => boolean;
}
```
````

## File: composables/useStreamAccumulator.md
````markdown
# useStreamAccumulator

Frame-batched accumulator for AI streaming tokens. It receives partial text/reasoning deltas, buffers them, and flushes at most once per animation frame so the UI stays smooth.

---

## Purpose

`useStreamAccumulator` replaces ad-hoc refs for building assistant responses. It normalises streaming flow with a single API:

-   `append()` collects text or reasoning deltas without immediate DOM churn
-   `finalize()` seals the stream and records errors/abort state
-   `reset()` prepares for the next stream
-   `state` exposes reactive fields (`text`, `reasoningText`, `isActive`, etc.) any component can watch

The accumulator automatically batches writes via `requestAnimationFrame` when available, falling back to microtasks in environments without rAF (tests, SSR stubs).

---

## Quick example

```ts
import { useStreamAccumulator } from '~/composables/chat/useStreamAccumulator';

const stream = useStreamAccumulator();

// Stream chunks coming from OpenRouter
stream.append('Hello', { kind: 'text' });
stream.append(', world!', { kind: 'text' });
stream.append('Considering user intent...', { kind: 'reasoning' });

// When the stream completes:
stream.finalize();

console.log(stream.state.text); // "Hello, world!"
```

---

## API

| Member                   | Type                                                                | Description                                                                                            |
| ------------------------ | ------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| `state`                  | `Readonly<StreamingState>`                                          | Reactive state object (see below).                                                                     |
| `append(delta, options)` | `(delta: string, options: { kind: 'text' \| 'reasoning' }) => void` | Queue a delta chunk for batching. Empty strings are ignored.                                           |
| `finalize(opts?)`        | `(opts?: { error?: Error; aborted?: boolean }) => void`             | Flush any pending chunks, mark the stream inactive/finalized, optionally capture an error. Idempotent. |
| `reset()`                | `() => void`                                                        | Cancel pending frames, clear buffers, and return the state to its initial active state.                |

### `StreamingState`

```ts
interface StreamingState {
    text: string;
    reasoningText: string;
    isActive: boolean;
    finalized: boolean;
    error: Error | null;
    version: number; // increments each flush for lightweight watchers
}
```

The composable exports `type UnifiedStreamingState = StreamingState` for consumers migrating from legacy code.

---

## Usage patterns

### Wiring into a stream handler

```ts
const accumulator = useStreamAccumulator();

async function handleChunk(chunk: StreamChunk) {
    if (chunk.type === 'text-delta') {
        accumulator.append(chunk.text, { kind: 'text' });
    } else if (chunk.type === 'reasoning-delta') {
        accumulator.append(chunk.reasoning, { kind: 'reasoning' });
    }
}

function handleComplete(error?: Error) {
    accumulator.finalize(error ? { error } : undefined);
}
```

### Reacting to flushes

```ts
watch(
    () => accumulator.state.version,
    () => {
        latestText.value = accumulator.state.text;
    }
);
```

### Reusing for multiple responses

```ts
accumulator.reset();
// start next stream by calling append() again
```

---

## Internals

1. **Batching** — Deltas are stored in `pendingMain` / `pendingReasoning` arrays until `flush()` concatenates and appends to `state`. `flush()` runs via rAF; if unavailable, a cancelable microtask is used.
2. **Idempotent finalize** — Calls after the first are no-ops (with dev warnings). `finalize()` cancels scheduled frames, flushes remaining buffers, flips `isActive` false, marks `finalized`, and sets `error` when provided.
3. **Reset logic** — Cancels pending frames/microtasks, clears buffers, resets state values, and bumps `version` so watchers notice the reset.
4. **Empty delta guard** — Ignores empty strings and warns (up to three times in dev) to highlight upstream tokenization issues.
5. **Environment-safe** — `getRAF()` / `getCAF()` resolve lazily so tests can stub them; SSR falls back to `setTimeout`.

---

## Tips & edge cases

-   **Multiple consumers**: `state` is reactive; share it across components without additional refs.
-   **Abort semantics**: Pass `finalize({ aborted: true })` if the stream was cancelled. Downstream UI can infer this from `state.isActive === false && state.finalized === true` plus the `aborted` flag you track externally.
-   **Error path**: Provide `finalize({ error })` to surface issues; UI can render the error based on `state.error`.
-   **Reset before reuse**: Always call `reset()` before starting another stream on the same accumulator.
-   **Performance**: Because flushing happens ≤ once per frame, high-frequency streams won’t thrash the DOM even when chunks arrive rapidly.

---

## Related modules

-   `useChat` — consumes this accumulator to build assistant messages.
-   Legacy `useTailStream` — superseded by this composable.
-   Streaming infrastructure in `~/core` — responsible for turning OpenRouter SSE events into `append()` calls.
````

## File: composables/useThreadHistoryActions.md
````markdown
# useThreadHistoryActions

Registry for adding custom actions to the thread history sidebar dropdown. Mirrors the document history registry but targets threads, letting plugins inject export, share, or workflow buttons.

---

## What does it do?

`useThreadHistoryActions` exposes:

-   `registerThreadHistoryAction()` / `unregisterThreadHistoryAction()` to manage action lifecycle.
-   `useThreadHistoryActions()` to read a sorted, reactive list of actions for rendering.
-   `listRegisteredThreadHistoryActionIds()` for debugging or collision checks.

Actions are stored globally on `globalThis`, so they persist across HMR and shared imports.

---

## Basic Example

```ts
import {
    registerThreadHistoryAction,
    unregisterThreadHistoryAction,
    useThreadHistoryActions,
} from '~/composables/threads/useThreadHistoryActions';

registerThreadHistoryAction({
    id: 'custom:export-thread',
    icon: 'i-ph-cloud-arrow-down',
    label: 'Export Thread',
    order: 210,
    async handler({ document }) {
        await exportThread(document.id);
    },
});

const actions = useThreadHistoryActions();

onScopeDispose(() => {
    unregisterThreadHistoryAction('custom:export-thread');
});
```

---

## How to use it

### 1. Register actions when your plugin loads

-   Namespace IDs (`my-plugin:action`) to avoid collisions.
-   Provide `icon`, `label`, optional `order`, and a `handler` receiving `{ document: Thread }`.

### 2. Consume the computed list

-   Components like `SidebarThreadHistory.vue` call `useThreadHistoryActions()` to obtain sorted actions.
-   The returned array is already sorted by `order` (default 200) so you can render directly.

### 3. Cleanup for HMR

-   Call `unregisterThreadHistoryAction()` (or wrap registration in `useHookEffect`) to keep the registry tidy during hot reloads.

### 4. Handle async operations

-   `handler` can be async; manage toasts/loading in your own logic.

---

## What you get back

`useThreadHistoryActions()` → `ComputedRef<ThreadHistoryAction[]>` where each action includes:

| Property  | Type                                 | Description                              |
| --------- | ------------------------------------ | ---------------------------------------- | --------------- |
| `id`      | `string`                             | Unique identifier.                       |
| `icon`    | `string`                             | Iconify name to display in the dropdown. |
| `label`   | `string`                             | Action text shown next to the icon.      |
| `order`   | `number \| undefined`                | Sorting hint (default 200).              |
| `handler` | `(ctx: { document: Thread }) => void | Promise<void>`                           | Click callback. |

---

## Under the hood

1. **Global registry** – Uses `globalThis.__or3ThreadHistoryActionsRegistry` so multiple imports share the same entries.
2. **Reactive mirror** – Maintains `reactiveList.items` for Vue to track updates without making the map reactive.
3. **Sorting** – The computed accessor sorts by `order` each time, keeping render order deterministic.
4. **HMR-safe** – Overwriting the same ID just replaces the entry; dev warnings can be added similarly to other registries if needed.

---

## Edge cases & tips

-   **Duplicate IDs**: Last registration wins. Use `listRegisteredThreadHistoryActionIds()` to inspect the registry.
-   **Missing thread**: Ensure components pass the correct `Thread` to handlers; the registry doesn’t enforce schema.
-   **Async errors**: Catch and surface toast messages yourself—the registry doesn’t handle failure reporting.
-   **Order buckets**: Follow the convention (built-ins ~100–150, extensions ≥200) for predictable placement.

---

## Related

-   `useDocumentHistoryActions` — sister registry for documents.
-   `useThreadSearch` — locate threads for history UI.
-   `~/app/components/sidebar/ThreadHistory.vue` — consumes this registry to render dropdown actions.

---

## TypeScript

```ts
interface ThreadHistoryAction {
    id: string;
    icon: string;
    label: string;
    order?: number;
    handler: (ctx: { document: Thread }) => void | Promise<void>;
}
```
````

## File: composables/useThreadSearch.md
````markdown
# useThreadSearch

Thread-specific search composable that powers the sidebar query field. Builds a small Orama index over thread titles, debounces input, and falls back to substring matching when required.

---

## What does it do?

`useThreadSearch(threads)` delivers:

-   A writable `query` ref bound to the search input.
-   A reactive `results` list kept in sync with Orama hits or substring fallback.
-   Automatic index rebuilds when the thread collection grows or shrinks.
-   Debounced searches (120 ms) to avoid excessive recomputation.
-   Convenience helpers (`rebuild`, `runSearch`) plus ready/busy flags.

---

## Basic Example

```ts
import { useThreadSearch } from '~/composables/threads/useThreadSearch';

const threads = useThreads(); // Ref<Thread[]>

const { query, results, ready, busy, rebuild } = useThreadSearch(threads);

watch(results, (list) => console.debug('Thread matches', list.length));

// Force rebuild after an import
await rebuild();
```

---

## How to use it

### 1. Pass a reactive thread array

Provide a `Ref<Thread[]>`. The composable rebuilds the index whenever the array length changes. For title-only edits, call `rebuild()` manually.

### 2. Bind `query`

Use `v-model="query.value"` (or simply `v-model="query"`) on your search input. Typing triggers debounced searches; clearing it restores the full thread list.

### 3. Render `results`

Loop over `results.value` to render matches ordered by relevance or fallback order.

### 4. Observe status

-   `ready.value` becomes `true` after the first successful index build.
-   `busy.value` is `true` while an index rebuild is in flight.

### 5. Control manually when needed

Call `await rebuild()` before heavy operations, or `await runSearch()` to refresh results after custom filters.

---

## What you get back

| Property    | Type                  | Description                        |
| ----------- | --------------------- | ---------------------------------- |
| `query`     | `Ref<string>`         | Current search string.             |
| `results`   | `Ref<Thread[]>`       | Matching threads.                  |
| `ready`     | `Ref<boolean>`        | Indicates the index is built.      |
| `busy`      | `Ref<boolean>`        | `true` when rebuilding the index.  |
| `rebuild`   | `() => Promise<void>` | Forces index rebuild.              |
| `runSearch` | `() => Promise<void>` | Runs search for the current query. |

---

## Under the hood

1. **Index build** — Uses `createDb`/`buildIndex` from `~/core/search/orama` with schema `{ id, title, updated_at }`.
2. **ID map** — Maintains an `id → Thread` dictionary for quick hit resolution.
3. **Debounce** — Delays `runSearch()` by 120 ms after each query change via `setTimeout`.
4. **Fallback** — If Orama returns zero hits or throws, filters by `title.toLowerCase().includes(query)` and logs a warning once.
5. **Stale guard** — Uses `lastQueryToken` to ignore late async responses when queries change quickly.

---

## Edge cases & tips

-   **Untitled threads**: Empty titles default to `'Untitled Thread'` before indexing, so they still appear.
-   **Empty query**: Returns the full thread list to mirror the sidebar UX.
-   **Large datasets**: Increase the search limit in the composed call if you need more than 200 hits.
-   **SSR**: Safe to import on the server; the index only builds on the client when watchers run.

---

## Related

-   `useSidebarSearch` — multi-entity search that also covers projects and documents.
-   `useThreadHistoryActions` — companion registry for thread dropdown actions.
-   `~/core/search/orama` — shared Orama helpers used throughout the app.

---

## TypeScript

```ts
function useThreadSearch(threads: Ref<Thread[]>): {
    query: Ref<string>;
    results: Ref<Thread[]>;
    ready: Ref<boolean>;
    busy: Ref<boolean>;
    rebuild: () => Promise<void>;
    runSearch: () => Promise<void>;
};
```
````

## File: composables/useWorkspaceBackup.md
````markdown
# useWorkspaceBackup

Full-featured workspace export/import controller for OR3. It coordinates Dexie exports, streaming backups, progress reporting, hook telemetry, and error handling so the UI can offer reliable backup workflows.

---

## What does it do?

`useWorkspaceBackup` manages every stage of backing up and restoring the local database:

-   Streams workspace exports to the File System Access API or StreamSaver fallback
-   Peeks backup files to surface metadata before import (format, table counts, etc.)
-   Imports backups in “replace” or “append” modes, with optional value overwrites
-   Tracks progress, step state, and errors in reactive refs for real-time UI updates
-   Dispatches hook events for extension telemetry and clean integrations

---

## Basic Example

```ts
import { useWorkspaceBackup } from '~/composables/core/useWorkspaceBackup';

const backup = useWorkspaceBackup();

async function exportNow() {
    await backup.exportWorkspace();
}

async function importFile(file: File) {
    await backup.peekBackup(file); // show metadata & ask user
    await backup.importWorkspace(file);
}
```

---

## How to use it

### 1. Create the composable

```ts
const backup = useWorkspaceBackup();
const { state } = backup;
```

`state` contains refs for loading indicators, progress bars, metadata, and errors—bind them straight into your component.

### 2. Export workflow

1. Call `backup.exportWorkspace()` in response to “Export” action.
2. Observe `state.isExporting`, `state.progress`, and `state.currentStep` for UI feedback.
3. On success, `currentStep` becomes `'done'`; reset the form with `backup.reset()` if you want to start fresh.

### 3. Inspect a backup file

1. Prompt the user for a file.
2. Call `await backup.peekBackup(file)`.
3. Read `state.backupMeta` (tables, counts) and `state.backupFormat` (`'stream'` or `'dexie'`).
4. Let the user choose `state.importMode` (`'replace' | 'append'`) and `state.overwriteValues` if appending.

### 4. Import workflow

1. Call `await backup.importWorkspace(file)`.
2. Watch `state.isImporting`, `state.progress`, and `state.currentStep`.
3. On completion, the composable fires `workspace:reloaded` hook so downstream stores can refresh.

### 5. Error handling

If any step fails, `state.error` holds an `AppError`. Show `state.currentStep === 'error'` to display a retry prompt. `backup.reset()` clears the state.

---

## API

```ts
const backup = useWorkspaceBackup();
```

### Returned object

| Property / Method       | Type                            | Description                                             |
| ----------------------- | ------------------------------- | ------------------------------------------------------- |
| `state`                 | `WorkspaceBackupState`          | Reactive refs for UI (see table below).                 |
| `exportWorkspace()`     | `() => Promise<void>`           | Streams the database to disk. No-op if already running. |
| `peekBackup(file)`      | `(file: Blob) => Promise<void>` | Reads metadata and sets `backupMeta`/`backupFormat`.    |
| `importWorkspace(file)` | `(file: Blob) => Promise<void>` | Imports according to `importMode`/`overwriteValues`.    |
| `reset()`               | `() => void`                    | Clears status flags, metadata, and errors.              |

### `WorkspaceBackupState`

| Ref               | Type                | Purpose                                              |
| ----------------- | ------------------- | ---------------------------------------------------- | ----------------------------------------------- | ------------------------------------------- | ----------- | ------ | --------- | -------------------------- |
| `isExporting`     | `Ref<boolean>`      | `true` while an export is in progress.               |
| `isImporting`     | `Ref<boolean>`      | `true` while an import is running.                   |
| `progress`        | `Ref<number>`       | 0–100 progress percentage.                           |
| `currentStep`     | `Ref<'idle'         | 'peeking'                                            | 'confirm'                                       | 'importing'                                 | 'exporting' | 'done' | 'error'>` | High-level step indicator. |
| `importMode`      | `Ref<'replace'      | 'append'>`                                           | Import strategy the user selected.              |
| `overwriteValues` | `Ref<boolean>`      | When appending, whether to replace conflicting rows. |
| `backupMeta`      | `Ref<ImportMetadata | null>`                                               | Metadata discovered during `peekBackup`.        |
| `backupFormat`    | `Ref<'stream'       | 'dexie'                                              | null>`                                          | Format derived from peek or auto-detection. |
| `error`           | `Ref<AppError       | null>`                                               | Last failure captured for UI display/reporting. |

`ImportMetadata` contains the Dexie database name/version plus table stats so you can present them to the user.

---

## Under the hood

1. **Module-level loaders** — Lazily imports `dexie-export-import` and `streamsaver` the first time they’re needed, caching promises for reuse.
2. **Export path** — Prefers the File System Access API (`showSaveFilePicker`) when available; otherwise falls back to StreamSaver with service worker shim. Progress is tracked by table/row counts from `streamWorkspaceExport` helpers.
3. **Peek** — Detects backup format by sniffing the file header. Dexie backups use `dexie-export-import`’s `peakImportFile`; stream backups parse the header line for metadata validation.
4. **Import** — Chooses between streaming import (`importWorkspaceStream`) and Dexie import (`importInto`). Appends respect `overwriteValues`; replace mode wipes tables first.
5. **Hooks** — Emits `workspace.backup.*` actions (`before`, `after`, `error`, `cancelled`) at each stage, plus `workspace:reloaded` after a successful import so other stores can resync.
6. **Error handling** — Wraps failures in `asAppError`, logs via `reportError`, and stores them in `state.error` with domain/action tags.

---

## Edge cases & tips

-   **Browser-only**: Every major action checks for `window`. In SSR contexts the composable will set an error explaining the limitation.
-   **Abort handling**: If the user cancels a save picker, the export resets to idle without surfacing an error.
-   **Version checks**: Both Dexie and stream imports validate database name/version; importing something from a newer schema raises a clear error.
-   **Chunk sizing**: Streaming exports use `STREAM_CHUNK_SIZE = 500` rows; Dexie imports default to ~1 MB chunks (`DEFAULT_KILOBYTES_PER_CHUNK`). Adjust in utilities if you need different throughput.
-   **Overwrite semantics**: In append mode, `overwriteValues` lets you merge data without wiping tables—set it via UI toggle before calling `importWorkspace`.
-   **Cleanup**: Call `reset()` after successful operations if you want to start a new flow without refreshing the page.

---

## Related

-   `~/utils/workspace-backup-stream.ts` — Implements the streaming codec used here.
-   `usePreviewCache` — Pair with this composable to manage heavy preview blobs alongside exports.
-   Hook reference in `docs/core-hook-map.md` — Lists the backup-related hooks emitted during each stage.
````

## File: database/attachments.md
````markdown
# attachments

Attachment table helpers for creating, updating, and deleting upload metadata with full hook coverage.

---

## What does it do?

-   Validates attachment payloads against `AttachmentCreateSchema`/`AttachmentSchema`.
-   Pipes all mutations through `dbTry` so quota and Dexie errors surface with contextual toasts.
-   Fires hook filters/actions around create, upsert, soft delete, hard delete, and reads.
-   Provides `nowSec()` driven soft delete flagging so rows stay recoverable until hard-deleted.

---

## Data shape

| Field        | Type      | Notes                                                |
| ------------ | --------- | ---------------------------------------------------- |
| `id`         | `string`  | Primary key supplied by caller.                      |
| `type`       | `string`  | Attachment type tag (image/pdf/etc).                 |
| `name`       | `string`  | Display name.                                        |
| `url`        | `string`  | Blob/object URL or remote link. Must be a valid URL. |
| `created_at` | `number`  | Unix timestamp (sec). Auto-defaulted by schema.      |
| `updated_at` | `number`  | Unix timestamp (sec). Auto-defaulted by schema.      |
| `deleted`    | `boolean` | Soft delete flag toggled by `softDeleteAttachment`.  |
| `clock`      | `number`  | Monotonic revision counter.                          |

---

## API surface

| Function               | Signature                                          | Description                                              |
| ---------------------- | -------------------------------------------------- | -------------------------------------------------------- | ----------------------------------------------------- |
| `createAttachment`     | `(input: AttachmentCreate) => Promise<Attachment>` | Filter + validate + insert new attachment row.           |
| `upsertAttachment`     | `(value: Attachment) => Promise<void>`             | Filter + validate + replace existing attachment.         |
| `softDeleteAttachment` | `(id: string) => Promise<void>`                    | Marks an attachment as deleted and bumps `updated_at`.   |
| `hardDeleteAttachment` | `(id: string) => Promise<void>`                    | Removes the row outright (no blob storage handled here). |
| `getAttachment`        | `(id: string) => Promise<Attachment                | undefined>`                                              | Reads a single attachment and applies output filters. |

---

## Hook points

-   `db.attachments.create:filter:input` → mutate incoming payloads before validation.
-   `db.attachments.create:action:before/after`
-   `db.attachments.upsert:filter:input` + matching before/after actions.
-   `db.attachments.delete:action:soft:*` and `db.attachments.delete:action:hard:*` fire during deletes.
-   `db.attachments.get:filter:output` lets consumers normalize read results.

---

## Usage tips

-   Always supply a `clock` increment when calling `upsertAttachment`; schema enforces numeric clocks.
-   Soft deletes keep the blob data available; schedule `hardDeleteAttachment` when you want to reclaim disk.
-   Extend hooks to inject signed URLs or sanitize file names before persistence.
````

## File: database/branching.md
````markdown
# branching

Utilities for forking threads, retry-branching assistant replies, and building merged conversation contexts across Dexie tables.

---

## What does it do?

-   Provides `forkThread`, `retryBranch`, and `buildContext` helpers that run inside Dexie transactions.
-   Normalizes branch modes (`reference` vs `copy`) and message roles for consistent downstream handling.
-   Clones ancestor messages when in copy mode and keeps indexes dense.
-   Merges ancestor + local messages for context building while respecting hook-driven filtering.

---

## Key types

| Type                             | Description                                                                 |
| -------------------------------- | --------------------------------------------------------------------------- |
| `ForkMode`                       | Alias of `BranchMode` (either `'reference'` or `'copy'`).                   |
| `ForkThreadParams`               | Required `sourceThreadId`, `anchorMessageId`, optional mode/title override. |
| `RetryBranchParams`              | Assistant message to branch from plus optional mode/title.                  |
| `BranchForkBeforePayload`        | Hook payload describing source thread, anchor message, and options.         |
| `MessageEntity` / `ThreadEntity` | Lightweight shapes passed through the hook engine.                          |

---

## API surface

| Function       | Signature                                                                                   | Description                                                                           |
| -------------- | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| `forkThread`   | `({ sourceThreadId, anchorMessageId, mode, titleOverride }) => Promise<{ thread, anchor }>` | Forks a thread at a specific message, optionally copying ancestor messages.           |
| `retryBranch`  | `({ assistantMessageId, mode, titleOverride }) => Promise<{ thread, anchor }>`              | Finds the preceding user message and delegates to `forkThread`.                       |
| `buildContext` | `({ threadId }) => Promise<Message[]>`                                                      | Builds the playable context for a thread, stitching ancestors for reference branches. |

---

## Hook integration

-   `branch.fork:filter:options` to mutate incoming fork parameters.
-   `branch.fork:action:before/after` around thread creation.
-   `branch.retry:*` sequence around retry-based forks.
-   `branch.context:filter:messages` lets extensions rewrite the merged entity list before final merging.

---

## Implementation notes

1. **Transactions** — Forking and context building happen within Dexie transactions touching `threads` and `messages` tables to avoid race conditions.
2. **Indexing** — Copied messages normalize indexes starting at `0` to keep order stable in fresh forks.
3. **Role normalization** — Any non-assistant/system role becomes `user` so AI context stays predictable.
4. **Perf** — `buildContext` batches ancestor and local queries in parallel and dedupes via `Map` before merging.

---

## Usage tips

-   Use `mode: 'copy'` when you need historical messages physically duplicated for offline tweaks; otherwise the cheaper reference mode keeps storage down.
-   Customize `branch.fork:filter:options` to auto-name forks (e.g., prepend emoji or include anchor timestamp).
-   When building custom prompts, call `buildContext` to get the exact message list that the composer expects.
````

## File: database/client.md
````markdown
# client

Dexie database client that defines the `Or3DB` schema, typed tables, and versioning rules.

---

## What does it do?

-   Establishes the single IndexedDB database named `or3-db`.
-   Declares typed `Dexie.Table` instances for every entity (projects, threads, messages, etc.).
-   Collapses historical migrations into version `5` so existing installs stay compatible without upgrade churn.

---

## Tables & indexes

| Table         | Primary key | Secondary indexes                                                                                                                                                       |
| ------------- | ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `projects`    | `id`        | `name`, `clock`, `created_at`, `updated_at`                                                                                                                             |
| `threads`     | `id`        | `[project_id+updated_at]`, `parent_thread_id`, `[parent_thread_id+anchor_index]`, `status`, `pinned`, `deleted`, `last_message_at`, `clock`, `created_at`, `updated_at` |
| `messages`    | `id`        | `[thread_id+index]`, `thread_id`, `index`, `role`, `deleted`, `stream_id`, `clock`, `created_at`, `updated_at`                                                          |
| `kv`          | `id`        | `&name`, `clock`, `created_at`, `updated_at`                                                                                                                            |
| `attachments` | `id`        | `type`, `name`, `clock`, `created_at`, `updated_at`                                                                                                                     |
| `file_meta`   | `hash`      | `[kind+deleted]`, `mime_type`, `clock`, `created_at`, `updated_at`                                                                                                      |
| `file_blobs`  | `hash`      | (none)                                                                                                                                                                  |
| `posts`       | `id`        | `title`, `postType`, `deleted`, `created_at`, `updated_at`                                                                                                              |

> ℹ️ `file_blobs` stores raw Binary Large Objects; the rest are JSON-like metadata rows.

---

## Usage

```ts
import { db } from '~/app/db';

await db.open();
const allThreads = await db.threads.toArray();
```

-   Prefer the higher-level modules (`threads.ts`, `messages.ts`, etc.) for business logic and hook coverage.
-   Only change the schema via `this.version(<next>).stores({...})` and bump the version number; ensure you migrate existing data when necessary.

---

## Versioning tips

-   Keep version pegged at `5` until you add columns or indexes. When you bump, implement Dexie upgrade paths to migrate data.
-   Since older migrations were consolidated, new changes should avoid breaking existing user stores—plan upgrades carefully.
````

## File: database/dbTry.md
````markdown
# dbTry

Thin error-handling wrapper around Dexie calls that surfaces quota issues and standardizes error metadata.

---

## What does it do?

-   Executes a provided function and traps IndexedDB quota exceptions.
-   Emits toast-friendly `ERR_DB_QUOTA_EXCEEDED` errors with guidance text.
-   Tags all other failures as `ERR_DB_READ_FAILED`/`ERR_DB_WRITE_FAILED` and forwards them to `reportError`.
-   Optionally rethrows after logging when `opts.rethrow` is true.

---

## API

```ts
dbTry<T>(fn: () => Promise<T> | T, tags: DbTryTags, opts?: { rethrow?: boolean }): Promise<T | undefined>
```

| Parameter      | Type                | Notes                                                          |
| -------------- | ------------------- | -------------------------------------------------------------- | ------------------------------------------- |
| `fn`           | `() => Promise<T>  | T`                                                             | Database action to execute.                 |
| `tags`         | `{ op: 'read'       | 'write'; entity?: string; ... }`                               | Required tags used for logging/diagnostics. |
| `opts.rethrow` | `boolean`           | When `true`, the original exception is rethrown after logging. |

Returns the function result (possibly `undefined` when suppressed) or `undefined` if an error was swallowed.

---

## Constants

-   `DB_QUOTA_GUIDANCE` — UI-friendly message instructing users to clear space when storage quota is exceeded.

---

## When to use

-   Wrap all Dexie reads/writes that could hit quota or data corruption.
-   Pair with `{ rethrow: true }` when the caller cannot recover (e.g., creation flows) so upstream can surface precise failures.

---

## Error tagging

-   Adds `domain: 'db'` and `rw: tags.op` so hooks/devtools can filter DB-related errors.
-   Quota failures set `retryable: false`; other failures remain retryable to allow user retriggering.
````

## File: database/documents.md
````markdown
# documents

Document storage built on the shared `posts` table (`postType: 'doc'`) with TipTap JSON payloads and hook integration.

---

## What does it do?

-   Serializes rich-text documents into the `posts` table without introducing a new Dexie store.
-   Surfaces CRUD helpers that parse/merge content and titles through hook filters.
-   Provides soft- and hard-delete paths, plus a small `ensureDbOpen` helper used by feature modules.

---

## Data structures

| Row              | Field              | Meaning                                                  |
| ---------------- | ------------------ | -------------------------------------------------------- |
| `DocumentRow`    | `content: string`  | Raw JSON string persisted in Dexie.                      |
|                  | `postType`         | Always `'doc'`; used to discriminate from prompts/posts. |
|                  | `deleted: boolean` | Soft delete flag toggled via `softDeleteDocument`.       |
| `DocumentRecord` | `content: any`     | Parsed TipTap JSON returned to callers.                  |

---

## API surface

| Function                    | Description                                                                                |
| --------------------------- | ------------------------------------------------------------------------------------------ |
| `createDocument(input?)`    | Validates title/content, runs hooks, writes a new row, returns parsed record.              |
| `getDocument(id)`           | Loads a single document, applies output filters, returns parsed record.                    |
| `listDocuments(limit?)`     | Fetches non-deleted docs, sorts by `updated_at` desc, slices to limit, applies filters.    |
| `updateDocument(id, patch)` | Re-resolves titles/content, fires before/after hooks, persists and returns updated record. |
| `softDeleteDocument(id)`    | Marks `deleted: true` and bumps `updated_at`.                                              |
| `hardDeleteDocument(id)`    | Removes the row entirely.                                                                  |
| `ensureDbOpen()`            | Opens Dexie when closed (no-op if already open).                                           |

---

## Hooks

-   `db.documents.title:filter` — customize title normalization per phase.
-   `db.documents.<stage>:filter:input/output` — mutate entities before persistence or after reads.
-   `db.documents.delete:action:*` — observe both soft and hard deletes.

---

## Implementation notes

1. **Title normalization** — `normalizeTitle` trims empty strings to `'Untitled'`, then passes through hook filters.
2. **Content safety** — `parseContent` guards against malformed JSON, returning an empty doc structure on error.
3. **Update payloads** — Build `DbUpdatePayload` objects so hooks receive full `existing`, `updated`, and `patch` context.

---

## Usage tips

-   Use `listDocuments()` for sidebar listings; it already caps results and filters deleted rows.
-   Call `updateDocument` with partial patches—passing `content` as TipTap JSON automatically serializes to string.
-   Write hook extensions to auto-tag docs or enforce title casing.
````

## File: database/files-select.md
````markdown
# files-select

Read-only helpers for paging `file_meta` rows when browsing uploads or the recycle bin.

---

## What does it do?

-   Exposes lightweight list queries scoped to image-like files.
-   Applies simple paging (`offset`, `limit`) over an `updated_at` index.
-   Provides a rename helper that bumps `updated_at` for sorting freshness.

---

## API surface

| Function                     | Signature                                         | Description                                         |
| ---------------------------- | ------------------------------------------------- | --------------------------------------------------- |
| `listImageMetasPaged`        | `(offset = 0, limit = 50) => Promise<FileMeta[]>` | Returns newest-first non-deleted image meta rows.   |
| `listDeletedImageMetasPaged` | `(offset = 0, limit = 50) => Promise<FileMeta[]>` | Returns soft-deleted image meta rows for bin views. |
| `updateFileName`             | `(hash: string, name: string) => Promise<void>`   | Renames a file (if found) and updates `updated_at`. |

---

## Filtering rules

-   Images are detected via `kind === 'image'` or `mime_type` prefix `image/`.
-   Deleted and non-deleted lists are separated to simplify UI logic.

---

## Usage tips

-   Combine with `createOrRefFile` / `softDeleteFile` from `files.ts` for lifecycle actions.
-   Use `offset`/`limit` for infinite scroll; Dexie performs the filtering client-side so keep limits small (<= 100) for snappy results.
````

## File: database/files-util.md
````markdown
# files-util

Utility helpers for enforcing message file limits and serializing file hash arrays.

---

## What does it do?

-   Resolves `MAX_FILES_PER_MESSAGE` from `NUXT_PUBLIC_MAX_MESSAGE_FILES` (bounded 1–12).
-   Provides JSON parse/serialize helpers for the `file_hashes` message column.
-   Dedupes hashes and preserves insertion order when serializing.

---

## Constants

| Constant                  | Description                                            |
| ------------------------- | ------------------------------------------------------ |
| `MAX_FILES_PER_MESSAGE`   | Runtime cap on attachments per message (default 6).    |
| `MAX_MESSAGE_FILE_HASHES` | Deprecated alias retained for backwards compatibility. |

---

## API surface

| Function              | Signature                      | Description                                      |
| --------------------- | ------------------------------ | ------------------------------------------------ | ---------------------------------------------------------------------- |
| `parseFileHashes`     | `(serialized?: string          | null) => string[]`                               | Safely parses JSON array, strips invalid entries, enforces max length. |
| `serializeFileHashes` | `(hashes: string[]) => string` | Dedupes, bounds to max, and returns JSON string. |

---

## Usage tips

-   Always run message updates through these helpers before writing to Dexie to avoid oversized rows.
-   When increasing the limit via env, remember it caps at 12 to avoid UI abuse.
````

## File: database/files.md
````markdown
# files

File storage layer that deduplicates blobs by hash, keeps metadata in Dexie, and exposes hook-friendly lifecycle helpers.

---

## What does it do?

-   Generates content hashes (`computeFileHash`) to reuse existing uploads.
-   Stores binary blobs in `file_blobs` and metadata in `file_meta` with ref counting.
-   Emits numerous hooks so extensions can validate, annotate, or track file usage.
-   Supports soft delete, restore, hard delete, and reference counting operations.

---

## Data structures

| Field            | Description                                                     |
| ---------------- | --------------------------------------------------------------- |
| `hash`           | MD5 hash used as primary key for both metadata and blob tables. |
| `name`           | Display name supplied by uploader.                              |
| `mime_type`      | MIME type (defaults to `application/octet-stream`).             |
| `kind`           | `'image'` or `'pdf'` (auto-detected).                           |
| `size_bytes`     | Blob size in bytes; enforced against 20 MB cap.                 |
| `width`/`height` | Optional image dimensions extracted via object URL.             |
| `ref_count`      | Number of referencing entities (messages).                      |
| `deleted`        | Soft delete flag set by `softDeleteFile`/`softDeleteMany`.      |

---

## API surface

| Function                           | Description                                                                             |
| ---------------------------------- | --------------------------------------------------------------------------------------- |
| `createOrRefFile(file, name)`      | Dedupes by hash, increments ref count, stores blob + metadata, runs before/after hooks. |
| `getFileMeta(hash)`                | Loads metadata and applies output filters.                                              |
| `getFileBlob(hash)`                | Returns the stored `Blob` (or `undefined`).                                             |
| `softDeleteFile(hash)`             | Marks a single file as deleted.                                                         |
| `softDeleteMany(hashes)`           | Batch soft delete inside a transaction.                                                 |
| `restoreMany(hashes)`              | Clears `deleted` flag for multiple files.                                               |
| `hardDeleteMany(hashes)`           | Removes metadata and blob entries entirely.                                             |
| `derefFile(hash)`                  | Decrements ref count (never below zero).                                                |
| `changeRefCount(hash, delta)`      | Internal helper exported for testing/hooks (invokes `db.files.refchange`).              |
| `fileDeleteError(message, cause?)` | Convenience error factory with tags for delete flows.                                   |

---

## Hooks

-   `db.files.create:filter:input` and `db.files.create:action:(before|after)`
-   `db.files.get:filter:output`
-   `db.files.refchange:action:after`
-   `db.files.delete:action:(soft|hard):(before|after)`
-   `db.files.restore:action:(before|after)`

These make it easy to inject custom validation, analytics, or audit trails around file lifecycle events.

---

## Implementation notes

1. **Perf markers** — In dev mode the module records `performance.measure` spans for create/ref operations.
2. **Image metadata** — Uses an object URL to resolve dimensions without full decode; errors are swallowed gracefully.
3. **Transactions** — Critical write operations run inside Dexie transactions covering both metadata and blob tables to keep state consistent.

---

## Usage tips

-   Always call `derefFile` when removing file references from messages to keep ref counts accurate.
-   Hook into `db.files.create:filter:input` to enforce custom size caps or rename files.
-   When batch deleting, prefer `softDeleteMany` first; run `hardDeleteMany` during periodic cleanups to reclaim storage.
````

## File: database/index.md
````markdown
# index

Barrel exports for the database layer, re-exporting the Dexie client, CRUD helpers, and common type aliases.

---

## What does it do?

-   Centralizes imports so callers can `import { create, queries, del } from '~/app/db'`.
-   Groups helpers into semantic objects: `create`, `upsert`, `queries`, `del`, `tx`, and `kv`.
-   Re-exports schema types (`Thread`, `Project`, `Document`, etc.) for consumer convenience.

---

## Aggregated namespaces

| Namespace  | Contents                                                                 |
| ---------- | ------------------------------------------------------------------------ |
| `create`   | `thread`, `message`, `kv`, `attachment`, `project`, `post`, `document`.  |
| `upsert`   | Sibling upsert helpers; note `document` maps to `updateDocument`.        |
| `queries`  | Read/query helpers spanning threads, messages, KV, posts, documents.     |
| `del.soft` | Soft-delete functions per entity.                                        |
| `del.hard` | Hard-delete counterparts (including KV helpers).                         |
| `tx`       | Transactional utilities (`appendMessage`, `moveMessage`, `copyMessage`). |
| `kv`       | Shorthand `get`, `set`, `delete` wrappers around name-based KV helpers.  |

---

## Usage example

```ts
import { create, queries, del } from '~/app/db';

const thread = await create.thread({ title: 'New chat' });
const messages = await queries.messagesByThread(thread.id);
await del.soft.thread(thread.id);
```

-   Prefer this barrel when wiring feature modules to keep import paths short and consistent.
````

## File: database/kv.md
````markdown
# kv

Key-value helpers for storing small preference or credential blobs in the Dexie `kv` table.

---

## What does it do?

-   Validates KV payloads with `KvCreateSchema`/`KvSchema`.
-   Wraps reads/writes in `dbTry` with detailed error tagging.
-   Integrates with the hook system for before/after actions and output filters.
-   Provides name-based helpers for common flows like OpenRouter token storage.

---

## Data shape

| Field        | Type     | Notes                                                        |
| ------------ | -------- | ------------------------------------------------------------ | ----------------------------------------- |
| `id`         | `string` | Primary key. Name-based helpers use `kv:${name}` convention. |
| `name`       | `string` | Logical key.                                                 |
| `value`      | `string  | null`                                                        | Serialized payload (often JSON or token). |
| `clock`      | `number` | Monotonic counter incremented on `setKvByName`.              |
| `created_at` | `number` | Unix seconds.                                                |
| `updated_at` | `number` | Unix seconds.                                                |

---

## API surface

| Function                   | Description                                                                      |
| -------------------------- | -------------------------------------------------------------------------------- |
| `createKv(input)`          | Inserts a new KV row after filtering and validation.                             |
| `upsertKv(value)`          | Full-row upsert with before/after hooks.                                         |
| `hardDeleteKv(id)`         | Removes a row by primary key.                                                    |
| `getKv(id)`                | Fetches by primary key and applies output filters.                               |
| `getKvByName(name)`        | Finds first row matching `name`.                                                 |
| `setKvByName(name, value)` | Creates or updates a row using `kv:${name}` ids, increments `clock`, runs hooks. |
| `hardDeleteKvByName(name)` | Deletes by `name` with before/after hooks.                                       |

---

## Hooks

-   `db.kv.create:filter:input` / `db.kv.create:action:(before|after)`
-   `db.kv.upsert:filter:input`
-   `db.kv.get:filter:output` and `db.kv.getByName:filter:output`
-   `db.kv.upsertByName:filter:input` / `:action:after`
-   `db.kv.delete(:action:hard:* )` + `db.kv.deleteByName:action:hard:*`

---

## Usage tips

-   Store encrypted or user-provided tokens by name; `setKvByName` will generate IDs automatically.
-   Use hooks to redact values before logging or to enforce naming conventions.
-   Keep payloads tiny (<10 KB) to avoid IndexedDB quota pressure.
````

## File: database/message-files.md
````markdown
# message-files

Helpers for attaching/detaching files to chat messages while maintaining ref counts and serialized hash lists.

---

## What does it do?

-   Resolves `file_hashes` arrays from messages and returns their metadata.
-   Adds files to messages either by Blob (new upload) or by existing hash.
-   Ensures Dexie transactions update messages and file tables atomically.
-   Dereferences files when hashes are removed.

---

## Types

| Type          | Description                                                                      |
| ------------- | -------------------------------------------------------------------------------- |
| `AddableFile` | Discriminated union `{ type: 'blob'; blob; name? }` or `{ type: 'hash'; hash }`. |

---

## API surface

| Function                                 | Description                                                                        |
| ---------------------------------------- | ---------------------------------------------------------------------------------- |
| `filesForMessage(messageId)`             | Loads `FileMeta[]` for the hashes stored on a message.                             |
| `addFilesToMessage(messageId, files)`    | Uploads or references files, merges hashes, applies hooks, writes serialized list. |
| `removeFileFromMessage(messageId, hash)` | Removes a hash, saves new list, decrements ref count.                              |

---

## Implementation notes

1. **Transactions** — All mutating functions run inside Dexie transactions touching `messages`, `file_meta`, and `file_blobs` to ensure consistency.
2. **Hooks** — `db.messages.files.validate:filter:hashes` lets extensions prune or reorder hash lists before persistence.
3. **Serialization** — Uses `serializeFileHashes` so limits/deduping stay consistent with message creation flows.

---

## Usage tips

-   Pass Blobs when users drop files; the helper will call `createOrRefFile` and reuse existing hashes.
-   For quick attach of already-uploaded media, pass `{ type: 'hash', hash }` to avoid re-computation.
-   Always call `removeFileFromMessage` (not manual mutation) so ref counts stay accurate.
````

## File: database/messages.md
````markdown
# messages

Thread message CRUD utilities with hook integration, sparse indexing, and attachment support.

---

## What does it do?

-   Creates, upserts, and queries messages with schema validation.
-   Manages sparse indexes (`index` field) to support fast insertion and ordered retrieval.
-   Exposes transactional helpers for append/move/copy/insert operations that also update thread timestamps.
-   Provides normalization tools like `normalizeThreadIndexes`.

---

## Key data fields

| Field         | Description                                                     |
| ------------- | --------------------------------------------------------------- |
| `id`          | Message UUID (auto-generated for create flows).                 |
| `thread_id`   | Foreign key to the parent thread.                               |
| `role`        | `'user' \| 'assistant' \| 'system'` (validated via schema).     |
| `data`        | Arbitrary payload (serialized JSON) used by renderers.          |
| `index`       | Sparse ordering integer (default increments by 1000).           |
| `file_hashes` | Serialized JSON array of file hashes; use `files-util` helpers. |
| `clock`       | Revision counter.                                               |

---

## API surface

| Function                                          | Description                                                                                 |
| ------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| `createMessage(input)`                            | Validates payload (including array → string conversion for `file_hashes`) and writes a row. |
| `upsertMessage(value)`                            | Validates and replaces a row.                                                               |
| `messagesByThread(threadId)`                      | Fetches ordered messages, applying output filters.                                          |
| `getMessage(id)` / `messageByStream(streamId)`    | Targeted lookups with output filters.                                                       |
| `softDeleteMessage(id)` / `hardDeleteMessage(id)` | Delete flows with before/after hook actions.                                                |
| `appendMessage(input)`                            | Transactionally inserts at end of thread and updates timestamps.                            |
| `moveMessage(messageId, toThreadId)`              | Moves a message to another thread and reindexes.                                            |
| `copyMessage(messageId, toThreadId)`              | Duplicates a message into another thread with new ID.                                       |
| `insertMessageAfter(afterId, input)`              | Inserts between two messages, normalizing indexes as needed.                                |
| `normalizeThreadIndexes(threadId, start?, step?)` | Reassigns sequential indexes (default 1000 spacing).                                        |

---

## Hooks

-   `db.messages.create:filter:input` / `:action:before/after`
-   `db.messages.upsert`, `db.messages.byThread:filter:output`, `db.messages.get:filter:output`
-   Action hooks for delete, append, move, copy, insert, and normalize operations.

These hooks allow feature modules to enrich messages (e.g., auto-tagging, analytics) and react to lifecycle changes.

---

## Sparse indexing strategy

-   New messages default to increments of `1000`, leaving gaps for future inserts.
-   `insertMessageAfter` uses midpoint spacing; when no gap remains it calls `normalizeThreadIndexes` to re-sequence.
-   Dexie compound index `[thread_id+index]` keeps ordering queries fast.

---

## Usage tips

-   Always feed `file_hashes` as string arrays; the module serializes and bounds automatically.
-   Use `appendMessage` rather than manual `createMessage` when you need thread timestamps updated.
-   Call `normalizeThreadIndexes` after bulk edits to keep indexes tidy.
````

## File: database/posts.md
````markdown
# posts

Generic post storage built on the `posts` Dexie table; used for lightweight CMS data like release notes or docs.

---

## What does it do?

-   Validates posts with `PostCreateSchema`/`PostSchema` before persistence.
-   Normalizes optional `meta` payloads to JSON strings for compact storage.
-   Exposes CRUD helpers plus simple search utilities.
-   Integrates with hook filters/actions at every lifecycle step.

---

## Data shape

| Field      | Description                                                      |
| ---------- | ---------------------------------------------------------------- |
| `id`       | Primary key (auto-generated if omitted).                         |
| `title`    | Required, trimmed string.                                        |
| `content`  | Arbitrary string content (often Markdown).                       |
| `postType` | Logical discriminator (e.g., `'markdown'`, `'doc'`, `'prompt'`). |
| `meta`     | JSON string or structured object/array; normalized upstream.     |
| `deleted`  | Soft delete flag.                                                |

---

## API surface

| Function             | Description                                        |
| -------------------- | -------------------------------------------------- |
| `createPost(input)`  | Filters, normalizes meta/title, writes a new post. |
| `upsertPost(value)`  | Replaces an existing post with validation.         |
| `getPost(id)`        | Fetches a post by id with output filters.          |
| `allPosts()`         | Returns all posts (unfiltered); hook can prune.    |
| `searchPosts(term)`  | Case-insensitive title search using Dexie filter.  |
| `softDeletePost(id)` | Marks `deleted: true` and updates timestamp.       |
| `hardDeletePost(id)` | Removes the row entirely.                          |

---

## Hooks

-   `db.posts.create:filter:input` / `:action:(before|after)`
-   `db.posts.upsert:filter:input`
-   `db.posts.get/all/search:filter:output`
-   `db.posts.delete:action:(soft|hard):(before|after)`

---

## Usage tips

-   Use `postType` to segment content (e.g., `'doc'` and `'prompt'` reuse this table via other modules).
-   Normalize heavily structured `meta` objects before calling `createPost`; the helper will serialize for you but invalid JSON becomes `undefined`.
-   Hooks are the right place to inject slug generation or analytics side effects.
````

## File: database/projects.md
````markdown
# projects

CRUD helpers for project metadata stored in the `projects` Dexie table.

---

## What does it do?

-   Validates incoming project objects with `ProjectSchema`.
-   Wraps persistence in `dbTry` for consistent error handling.
-   Emits hook actions/filters for create, upsert, delete, and read flows.

---

## Data shape

| Field                       | Description                                        |
| --------------------------- | -------------------------------------------------- |
| `id`                        | Project ID (string).                               |
| `name`                      | Display name.                                      |
| `description`               | Optional string (nullable).                        |
| `data`                      | Arbitrary JSON payload scoped to project features. |
| `clock`                     | Revision counter.                                  |
| `deleted`                   | Soft delete flag updated via `softDeleteProject`.  |
| `created_at` / `updated_at` | Unix seconds timestamps.                           |

---

## API surface

| Function                | Description                                       |
| ----------------------- | ------------------------------------------------- |
| `createProject(input)`  | Filters + validates + writes a new project.       |
| `upsertProject(value)`  | Filters + validates + replaces the row.           |
| `softDeleteProject(id)` | Marks project deleted within a Dexie transaction. |
| `hardDeleteProject(id)` | Removes the project entirely.                     |
| `getProject(id)`        | Reads a project by id and applies output filters. |

---

## Hooks

-   `db.projects.create:filter:input` / `:action:(before|after)`
-   `db.projects.upsert:filter:input`
-   `db.projects.delete:action:(soft|hard):(before|after)`
-   `db.projects.get:filter:output`

---

## Usage tips

-   Store structured per-project state inside `data`; use hooks to enforce schema or migrate old versions.
-   Soft delete keeps history for undo flows—run hard deletes during cleanup tasks only.
````

## File: database/prompts.md
````markdown
# prompts

Prompt library built on the shared `posts` table (`postType: 'prompt'`) with TipTap JSON payloads.

---

## What does it do?

-   Adds CRUD helpers for saved prompt templates.
-   Normalizes titles (allowing empty strings when updating) and serializes content.
-   Reuses hook payload conventions (`DbCreatePayload`, `DbUpdatePayload`, `DbDeletePayload`).
-   Supports soft/hard delete flows plus a simple `ensureDbOpen` helper.

---

## Data structures

| Row            | Field             | Meaning                          |
| -------------- | ----------------- | -------------------------------- |
| `PromptRow`    | `content: string` | Raw JSON string stored in Dexie. |
|                | `postType`        | Always `'prompt'`.               |
|                | `deleted`         | Soft delete flag.                |
| `PromptRecord` | `content: any`    | Parsed JSON returned to callers. |

---

## API surface

| Function                  | Description                                                                               |
| ------------------------- | ----------------------------------------------------------------------------------------- |
| `createPrompt(input?)`    | Generates an id, normalizes title/content, runs hooks, writes row, returns parsed record. |
| `getPrompt(id)`           | Loads a single prompt with output filters.                                                |
| `listPrompts(limit?)`     | Lists non-deleted prompts ordered by `updated_at` desc, capped to limit.                  |
| `updatePrompt(id, patch)` | Applies patches through hooks, persists, and returns updated record.                      |
| `softDeletePrompt(id)`    | Sets `deleted: true` and bumps `updated_at`.                                              |
| `hardDeletePrompt(id)`    | Deletes row from the posts table.                                                         |
| `ensureDbOpen()`          | Opens Dexie if closed.                                                                    |

---

## Hooks

-   `db.prompts.create:filter:input` / `:action:(before|after)`
-   `db.prompts.update:filter:input` (receives full payload context)
-   `db.prompts.list:filter:output`
-   `db.prompts.delete:action:(soft|hard):(before|after)`

---

## Usage tips

-   Leverage `normalizeTitle`’s `allowEmpty` option to let users save blank-titled prompts while still providing fallbacks.
-   Store structured prompt metadata inside hook filters instead of extending Dexie schema—`PromptEntity` supports custom fields.
-   Call `ensureDbOpen` before large migrations or offline flows to avoid lazy-open delays.
````

## File: database/schema.md
````markdown
# schema

Central Zod schemas and generated TypeScript types for all Dexie tables.

---

## What does it do?

-   Defines runtime validation for every entity (`Project`, `Thread`, `Message`, etc.).
-   Supplies create-specific schemas that auto-populate IDs/timestamps via transforms.
-   Exports inferred TypeScript types to keep DB modules strongly typed.

---

## Schemas overview

| Schema                                        | Highlights                                                                 |
| --------------------------------------------- | -------------------------------------------------------------------------- |
| `ProjectSchema`                               | Basic metadata with optional description/data and `clock` counter.         |
| `ThreadSchema`                                | Supports branching fields (`parent_thread_id`, `anchor_*`, `branch_mode`). |
| `ThreadCreateSchema`                          | Optional fields with defaults for `id`, `clock`, timestamps.               |
| `MessageSchema`                               | Includes `file_hashes` string column, `stream_id`, sparse `index`.         |
| `MessageCreateSchema`                         | Auto-generates `id`, `clock`, timestamps; leaves `index` optional.         |
| `PostSchema` / `PostCreateSchema`             | Covers generic posts plus normalized title/meta logic.                     |
| `KvSchema` / `KvCreateSchema`                 | Simple key-value store with optional `value`.                              |
| `AttachmentSchema` / `AttachmentCreateSchema` | Enforces URL+type/name, optional `deleted`.                                |
| `FileMetaSchema` / `FileMetaCreateSchema`     | Metadata for blobs, defaulting `ref_count` and `clock`.                    |

---

## Helpers

-   `newId()` — Returns `crypto.randomUUID()` when available, fallback to timestamp string.
-   `nowSec()` — Unix timestamp (seconds) used as default for timestamps.

---

## Usage tips

-   Always run incoming data through `parseOrThrow(schema, value)` to catch invalid shapes before writing to Dexie.
-   When extending schema fields, update both the base schema and any related create schema so defaults stay aligned.
-   Compose new derived types via `z.infer<typeof Schema>` to keep type safety consistent across modules.
````

## File: database/threads.md
````markdown
# threads

Thread CRUD and query helpers with hook integration, branching support, and system prompt utilities.

---

## What does it do?

-   Creates and upserts thread rows with full schema validation.
-   Provides soft/hard delete flows that coordinate with message cleanup.
-   Offers search helpers and child-thread queries for branching UIs.
-   Implements a simple fork helper for cloning threads (optionally copying messages).
-   Stores per-thread system prompt references.

---

## Key fields

| Field                                | Description                                             |
| ------------------------------------ | ------------------------------------------------------- |
| `parent_thread_id`                   | Links branches back to their source thread.             |
| `anchor_message_id` / `anchor_index` | Track branching anchor points.                          |
| `branch_mode`                        | `'reference'` or `'copy'`; controls fork behavior.      |
| `forked`                             | Boolean flag marking branched threads.                  |
| `system_prompt_id`                   | Optional prompt reference stored with helper functions. |

---

## API surface

| Function                                       | Description                                                  |
| ---------------------------------------------- | ------------------------------------------------------------ |
| `createThread(input)`                          | Filters input, applies defaults, validates, persists thread. |
| `upsertThread(value)`                          | Validates and writes thread updates.                         |
| `threadsByProject(projectId)`                  | Returns threads scoped to a project (hook-filtered).         |
| `searchThreadsByTitle(term)`                   | Case-insensitive title filter using Dexie.                   |
| `getThread(id)`                                | Fetches a thread by id with output filters.                  |
| `childThreads(parentThreadId)`                 | Lists direct branch children.                                |
| `softDeleteThread(id)`                         | Marks deleted flag and updates timestamp inside transaction. |
| `hardDeleteThread(id)`                         | Deletes thread and cascades delete to messages.              |
| `forkThread(sourceId, overrides?, options?)`   | Clones thread metadata, optionally copies messages.          |
| `updateThreadSystemPrompt(threadId, promptId)` | Stores/clears prompt reference.                              |
| `getThreadSystemPrompt(threadId)`              | Reads stored prompt id (hook-filtered).                      |

---

## Hooks

-   `db.threads.create|upsert:filter:input` + before/after actions.
-   `db.threads.delete:action:(soft|hard)`
-   `db.threads.fork:action:(before|after)`
-   `db.threads.updateSystemPrompt:action:(before|after)`
-   Output filters for query helpers (`byProject`, `searchByTitle`, `get`, `children`, `getSystemPrompt`).

---

## Implementation notes

1. **Transactions** — Delete/fork flows run inside Dexie transactions touching both `threads` and `messages` to stay consistent.
2. **Forking** — New thread IDs generated via `newId()`. When copying messages the helper duplicates rows and optionally updates thread metadata timestamps.
3. **Search** — Title search uses Dexie filter; pair with Orama-based composables for better ranking when needed.

---

## Usage tips

-   Use `forkThread` (from this module) for quick clones, or the richer branching utilities in `app/db/branching.ts` when you need anchor-aware forks.
-   Always go through `updateThreadSystemPrompt` to change prompts so hooks and timestamps stay aligned.
-   When cleaning up, call `softDeleteThread` first so UI consumers can offer undo before executing destructive `hardDeleteThread`.
````

## File: database/util.md
````markdown
# util

Shared helpers for parsing with Zod, generating IDs, and producing Unix timestamps.

---

## What does it do?

-   Wraps `schema.safeParse` to throw readable errors when validation fails (`parseOrThrow`).
-   Exposes `nowSec()` for consistent second-based timestamps across modules.
-   Provides `newId()` that prefers `crypto.randomUUID()` with a safe fallback.

---

## API surface

| Function       | Signature                       | Description                                                           |
| -------------- | ------------------------------- | --------------------------------------------------------------------- |
| `parseOrThrow` | `(schema, data) => ZodInfer<T>` | Validates data against a Zod schema; throws on failure.               |
| `nowSec`       | `() => number`                  | Returns `Math.floor(Date.now() / 1000)`.                              |
| `newId`        | `() => string`                  | Generates a UUID v4 or timestamp-based ID when crypto is unavailable. |

---

## Usage tips

-   Always use `parseOrThrow` before writing to Dexie to catch client-side shape regressions early.
-   `nowSec()` keeps timestamps compact (seconds vs milliseconds); align any server sync logic accordingly.
-   The timestamp fallback in `newId()` keeps IDs unique even in legacy browsers—no extra seeding required.
````

## File: hooks/hook-catalog.md
````markdown
# hook-catalog

Authoritative catalog of available hooks with their argument shapes and return values. This is derived from the codebase (hook keys, payload types, and call sites) so developers don’t have to console.log.

---

## How to read this

-   Kind: action vs filter. Actions return void; filters must return the next value in the chain.
-   Args: tuple passed to your handler. Use `typedOn(hooks).on(key, fn)` for editor inference.
-   Returns: concrete return type for filters. Veto-capable filters allow `false` (or `''`) to cancel/clear.

See also: `hooks.md` for engine API, `hook-keys.md` and `hook-types.md` for detailed payload types.

---

## Chat and AI

| Key                               | Kind   | Args (tuple)                                     | Returns                            |
| --------------------------------- | ------ | ------------------------------------------------ | ---------------------------------- |
| `ui.chat.message:filter:outgoing` | filter | `[text: string]`                                 | `string \| false` (veto to cancel) |
| `ui.chat.message:filter:incoming` | filter | `[text: string, threadId?: string]`              | `string`                           |
| `ai.chat.model:filter:select`     | filter | `[modelId: string]`                              | `string` (new model id)            |
| `ai.chat.messages:filter:input`   | filter | `[messages: any[]]`                              | `any[]`                            |
| `ai.chat.send:action:before`      | action | `[payload: AiSendBeforePayload]`                 | —                                  |
| `ai.chat.send:action:after`       | action | `[payload: AiSendAfterPayload]`                  | —                                  |
| `ai.chat.stream:action:delta`     | action | `[chunk: string, ctx: AiStreamDeltaPayload]`     | —                                  |
| `ai.chat.stream:action:reasoning` | action | `[chunk: string, ctx: AiStreamReasoningPayload]` | —                                  |
| `ai.chat.stream:action:complete`  | action | `[ctx: AiStreamCompletePayload]`                 | —                                  |
| `ai.chat.stream:action:error`     | action | `[ctx: AiStreamErrorPayload]`                    | —                                  |
| `ai.chat.retry:action:before`     | action | `[payload: AiRetryBeforePayload]`                | —                                  |
| `ai.chat.retry:action:after`      | action | `[payload: AiRetryAfterPayload]`                 | —                                  |

---

## Pane lifecycle

| Key                             | Kind   | Args (tuple)                                                 | Returns                 |
| ------------------------------- | ------ | ------------------------------------------------------------ | ----------------------- |
| `ui.pane.active:action`         | action | `[payload: UiPaneActivePayload]`                             | —                       |
| `ui.pane.blur:action`           | action | `[payload: UiPaneBlurPayload]`                               | —                       |
| `ui.pane.switch:action`         | action | `[payload: UiPaneSwitchPayload]`                             | —                       |
| `ui.pane.thread:filter:select`  | filter | `[requestedId: string, pane: PaneState, previousId: string]` | `string \| '' \| false` |
| `ui.pane.thread:action:changed` | action | `[payload: UiPaneThreadChangedPayload]`                      | —                       |
| `ui.pane.doc:filter:select`     | filter | `[requestedId: string, pane: PaneState, previousId: string]` | `string \| '' \| false` |
| `ui.pane.doc:action:changed`    | action | `[payload: UiPaneDocChangedPayload]`                         | —                       |
| `ui.pane.doc:action:saved`      | action | `[payload: UiPaneDocChangedPayload]`                         | —                       |
| `ui.pane.msg:action:sent`       | action | `[payload: UiPaneMsgSentPayload]`                            | —                       |
| `ui.pane.msg:action:received`   | action | `[payload: UiPaneMsgReceivedPayload]`                        | —                       |

Notes

-   The `select` filters support veto (`false`) and clear (`''`). See `useMultiPane.ts` and `usePaneDocuments.ts`.

---

## Files and uploads

| Key                         | Kind   | Args (tuple)                                  | Returns                            |
| --------------------------- | ------ | --------------------------------------------- | ---------------------------------- |
| `files.attach:filter:input` | filter | `[payload: FilesAttachInputPayload \| false]` | `FilesAttachInputPayload \| false` |

Notes

-   Returning `false` cancels the attachment. See `components/chat/file-upload-utils.ts`.

---

## Branching

| Key                              | Kind   | Args (tuple)                                                                                                       | Returns             |
| -------------------------------- | ------ | ------------------------------------------------------------------------------------------------------------------ | ------------------- |
| `branch.fork:action:before`      | action | `[payload: BranchForkBeforePayload]`                                                                               | —                   |
| `branch.fork:action:after`       | action | `[payload: ThreadEntity]`                                                                                          | —                   |
| `branch.retry:filter:options`    | filter | `[opts: { assistantMessageId: string; mode?: BranchMode; titleOverride?: string }]`                                | same shape as input |
| `branch.retry:action:before`     | action | `[payload: { assistantMessageId: string; precedingUserId: string; mode: BranchMode }]`                             | —                   |
| `branch.retry:action:after`      | action | `[payload: { assistantMessageId: string; precedingUserId: string; newThreadId: string; mode: BranchMode }]`        | —                   |
| `branch.context:filter:messages` | filter | `[messages: MessageEntity[], threadId: string, mode: BranchMode]`                                                  | `MessageEntity[]`   |
| `branch.context:action:after`    | action | `[payload: { threadId: string; mode: BranchMode; ancestorCount: number; localCount: number; finalCount: number }]` | —                   |

Notes

-   See `app/db/branching.ts` and `hook-types.ts` for the `Branch*` payloads.

---

## Database families (patterns)

Families: `messages | documents | files | threads | projects | posts | prompts | attachments | kv`

Actions

-   Before/after hooks per operation: `db.<family>.<op>:action:before|after`
-   Delete also emits `soft|hard` phases: `db.<family>.delete:action:soft|hard:before|after`

Filters

-   Input validators/transformers: `db.<family>.<op>:filter:input` — returns the (possibly transformed) input payload
-   Output mappers: `db.<family>.<op>:filter:output` — returns the (possibly transformed) result value

Common ops per family (varies by module; see each `app/db/*.ts`):

-   `create`, `upsert`, `update`, `delete`, `get`, `byThread`/`byProject`/`children`, `search`, specialized ops like `append`, `insertAfter`, `normalize`, `fork`, `updateSystemPrompt`.

Special cases

-   `db.files.refchange:action:after`
-   `db.kv.upsertByName:action:after`
-   `db.kv.deleteByName:action:hard:before|after`

Returns quick-reference

-   Action hooks: `void \| Promise<void>`
-   Filter input hooks: return the validated/transformed input shape
-   Filter output hooks: return the transformed entity/array being output

---

## App and errors (observed in code)

| Key                                       | Kind   | Args (tuple)                              | Returns               |
| ----------------------------------------- | ------ | ----------------------------------------- | --------------------- | --- |
| `app.init:action:after`                   | action | `[nuxtApp: any]`                          | —                     |
| `error:raised`                            | action | `[error: unknown]`                        | —                     |
| `error:<domain>`                          | action | `[error: unknown]`                        | —                     |
| `ai.chat.error:action`                    | action | `[payload: { error: unknown }]`           | —                     |
| `chat.systemPrompt.select:action:after`   | action | `[payload: { id: string; content: any }]` | —                     |
| `chat.systemPrompt.default:action:update` | action | `[id: string]`                            | —                     |
| `ui.sidebar.select:action:before`         | action | `[payload: { kind: 'chat'                 | 'doc'; id: string }]` | —   |
| `ui.sidebar.select:action:after`          | action | `[payload: { kind: 'chat'                 | 'doc'; id: string }]` | —   |
| `ui.chat.new:action:after`                | action | `[payload: {}]`                           | —                     |
| `editor.created:action:after`             | action | `[payload: { editor: any }]`              | —                     |
| `editor.updated:action:after`             | action | `[payload: { editor: any }]`              | —                     |

Notes

-   These are gathered from call sites across `app/**` and may evolve; prefer wildcard listeners for families like `error:*`.

---

## DX tips

-   Use `typedOn(hooks)` from `hook-keys` to get argument inference for known keys.
-   Filters: always return the next value. For veto-capable filters, return `false` to cancel and `''` to clear where supported.
-   For DB hooks, check the specific module under `app/db/` to see exactly which ops emit hooks and with which shapes.
````

## File: hooks/hook-keys.md
````markdown
# hook-keys

Catalog of high-signal hook keys and typed helpers for ergonomically registering listeners.

---

## What does it do?

-   Defines string literal unions for well-known UI/AI/DB hook names.
-   Provides the `typedOn` helper, returning a type-safe `on()` wrapper around the hook engine.
-   Exposes utility return types to clarify filter semantics.

---

## Key unions

| Type           | Description                                                                  |
| -------------- | ---------------------------------------------------------------------------- |
| `KnownHookKey` | Enumerated list of frequently-used hooks (chat, pane, files).                |
| `DbFamily`     | Union of DB entity families (`'messages'`, `'documents'`, …).                |
| `DbHookKey`    | Template literal `db.${DbFamily}.${string}` covering table-specific hooks.   |
| `HookKey`      | Final public union combining known keys, DB hooks, and open string fallback. |

These unions power editor autocomplete while remaining permissive for plugin authors.

---

## Hook payload mapping

`HookPayloads` maps each `KnownHookKey` to a tuple of arguments expected by handlers. Examples:

-   `'ai.chat.stream:action:delta'` → `[requestId: string, payload: AiStreamDeltaPayload]`
-   `'ui.pane.thread:filter:select'` → `[threadId, pane, previousId]`
-   `'files.attach:filter:input'` → `[FilesAttachInputPayload | false]`

This mapping feeds the `typedOn` helper.

---

## `typedOn(hooks)`

```ts
import { typedOn } from '~/core/hooks/hook-keys';

const on = typedOn(useHooks()._engine);
on('ui.pane.msg:action:sent', (payload) => {
    console.log(payload.message.length);
});
```

-   Narrows `key` to `KnownHookKey` entries.
-   Infers callback parameters from `HookPayloads`.
-   Delegates to the underlying `hooks.on` and returns its disposer.

---

## Utility return types

-   `ChatOutgoingFilterReturn` — `string | false` (veto sending by returning `false`).
-   `ChatIncomingFilterReturn` — Always `string`.
-   `FilesAttachFilterReturn` — `FilesAttachInputPayload | false`.

Use these aliases in docs and tests to clarify expectations.

---

## Usage tips

-   Add new hooks by extending `KnownHookKey`/`HookPayloads` incrementally to keep compile times low.
-   Prefer `typedOn` in modules that need maximum inference but still interact with the untyped engine instance.
-   For custom plugin hooks, rely on `HookKey`’s permissiveness and extend via `hook-types` global augmentation.
````

## File: hooks/hook-types.md
````markdown
# hook-types

TypeScript toolkit describing hook names, payload interfaces, and inference helpers for the OR3 hook engine.

---

## What does it do?

-   Defines structured payload interfaces for AI, UI panes, sidebar, branching, DB entities, and more.
-   Exposes string literal unions for action/filter hook names, including DB template literals.
-   Derives argument tuples and return types for every hook via `HookPayloadMap`.
-   Provides utility types for plugins to validate hook names and callback signatures.

---

## Payload interfaces

Notable groups:

-   **AI** — `AiSendBeforePayload`, `AiStreamDeltaPayload`, `AiRetryAfterPayload`.
-   **Pane/UI** — `UiPaneActivePayload`, `UiPaneMsgSentPayload`, `UiSidebarSelectPayload`.
-   **Branching** — `BranchForkOptions`, `BranchContextAfterPayload`.
-   **DB entities** — Lightweight mirror types (`MessageEntity`, `FileEntity`, `PromptEntity`, …).
-   **Utility** — `DbCreatePayload<T>`, `DbUpdatePayload<T>`, `DbDeletePayload<T>`.

These interfaces power typed composables, doc tables, and hook filters.

---

## Hook name unions

| Type               | Description                                                                                                               |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------- |
| `ActionHookName`   | Literal union matching `*:action:*` hooks (core + DB + extensions).                                                       |
| `FilterHookName`   | Literal union matching `*:filter:*` hooks (core + DB + extensions).                                                       |
| `HookName`         | Combined action + filter union used across the app.                                                                       |
| `DbActionHookName` | Template literal union for DB action hooks, including delete phases and custom cases (`db.files.refchange:action:after`). |
| `DbFilterHookName` | Template literal union for DB filters, including specialized titles/hash validators.                                      |

Plugin authors can augment `Or3ActionHooks` / `Or3FilterHooks` globally to extend these unions.

---

## Inference utilities

| Type                          | Purpose                                                                      |
| ----------------------------- | ---------------------------------------------------------------------------- |
| `InferHookParams<K>`          | Tuple of callback parameters for hook `K`.                                   |
| `InferHookReturn<K>`          | Return type a callback must produce (`void` for actions, value for filters). |
| `InferHookCallback<K>`        | Full function signature expected for hook `K`.                               |
| `IsAction<K>` / `IsFilter<K>` | Type-level booleans.                                                         |
| `ExtractHookPayload<K>`       | First parameter payload, handy for documentation.                            |
| `MatchingHooks<'pattern'>`    | Narrow hooks by template literal pattern (`'db.files.*'`).                   |
| `InferDbEntity<'db.files.*'>` | Maps hook strings back to entity interfaces.                                 |

These utilities are heavily used by `typed-hooks.ts` and composables like `useHookEffect`.

---

## Error helpers

-   `ValidateHookName<'bad.name'>` produces string literal diagnostics suggesting similar hooks.
-   `CallbackMismatch<Expected, Got>` formats readable error messages for mismatched callbacks.
-   Temporary guard `__hook_name_checks__` keeps frequently-used names anchored in the type system.

---

## Usage tips

-   When adding new hooks, update `CoreHookPayloadMap` (or appropriate DB unions) first; inference and docs will follow automatically.
-   For plugin ecosystems, augment `Or3ActionHooks`/`Or3FilterHooks` in a `.d.ts` file to make your hooks discoverable.
-   Use `InferHookCallback<'ui.pane.msg:action:sent'>` in unit tests to ensure mocks stay in sync with payload evolution.

---

## Related

-   `hook-keys.ts` — Convenience `typedOn` helper that leans on these types.
-   `typed-hooks.ts` — Runtime wrapper applying `InferHookCallback` signatures to the hook engine.
-   `useHookEffect` — Composable that uses `InferHookCallback` for DX.
````

## File: hooks/hooks.md
````markdown
# hooks

Lightweight hook engine that powers OR3’s action/filter system with priority scheduling, async support, and diagnostics.

---

## What does it do?

-   Registers callbacks as **actions** (fire-and-forget) or **filters** (value transformers).
-   Supports wildcard subscriptions with glob patterns (`ai.chat.*`).
-   Executes listeners in priority order, tracking the current priority stack.
-   Provides both async (`doAction`, `applyFilters`) and sync variants.
-   Captures timing and error metrics for introspection.

---

## Core concepts

| Concept   | Details                                                                           |
| --------- | --------------------------------------------------------------------------------- |
| Action    | Side-effect listeners, return `void`/`Promise<void>`. Run via `doAction`.         |
| Filter    | Transform a value and return the next value in the chain. Run via `applyFilters`. |
| Priority  | Lower numbers execute first (default `10`). Ties fall back to insertion order.    |
| Wildcards | Use `*` to match multiple hook names (`db.*.delete:action:after`).                |

---

## API surface

| Function                | Signature                              | Notes                                                  |
| ----------------------- | -------------------------------------- | ------------------------------------------------------ |
| `addAction`             | `(name, fn, priority?, acceptedArgs?)` | Registers an action listener.                          |
| `removeAction`          | `(name, fn, priority?)`                | Removes a specific action listener.                    |
| `doAction`              | `(name, ...args) => Promise<void>`     | Runs all action listeners async.                       |
| `doActionSync`          | `(name, ...args) => void`              | Synchronous variant.                                   |
| `addFilter`             | `(name, fn, priority?, acceptedArgs?)` | Registers filter listener.                             |
| `removeFilter`          | `(name, fn, priority?)`                | Removes filter listener.                               |
| `applyFilters`          | `(name, value, ...args) => Promise<T>` | Runs filters async, returning the final value.         |
| `applyFiltersSync`      | `(name, value, ...args) => T`          | Synchronous variant.                                   |
| `on`                    | `(name, fn, opts?) => disposer`        | Ergonomic wrapper picking `action` vs `filter`.        |
| `off`                   | `(disposer) => void`                   | Safely invokes disposers (with error reporting).       |
| `onceAction`            | `(name, fn, priority?) => disposer`    | Auto-removes listener after first fire.                |
| `hasAction / hasFilter` | `(name?, fn?)`                         | Returns `false`/priority/boolean for existence checks. |
| `removeAllCallbacks`    | `(priority?)`                          | Drops all callbacks, optionally by priority.           |
| `currentPriority`       | `() => number \| false`                | Reports the priority currently executing.              |

Diagnostics live under `_diagnostics` with per-hook timing arrays and error counts.

---

## Execution flow

1. **Lookup** — Gathers exact matches plus wildcard entries, then sorts by priority/id.
2. **Timing** — Measures each callback using `performance.now` when available.
3. **Errors** — Logs console errors and increments `_diagnostics.errors[name]` without interrupting other listeners.
4. **Filters** — Thread the transformed value through the chain, returning the final result.

---

## Wildcards

-   Register with `hooks.addAction('ui.pane.*', handler)` to observe entire families.
-   Stored with a compiled `RegExp` for quick matching, still respecting priority.
-   Removal requires the original glob string + callback reference.

---

## Usage tips

-   Favor the typed wrapper (`createTypedHookEngine`) or composable (`useHooks`) for better DX.
-   Always return the transformed value from filters; returning `undefined` will propagate.
-   Use `onceAction` for analytics pings or onboarding to avoid manual cleanup.
-   Inspect `hooks._diagnostics.timings` in devtools to spot slow listeners.

---

## Related

-   `hook-types.ts` — Type system describing hook names and payloads.
-   `typed-hooks.ts` — Zero-cost typed wrapper around this engine.
-   `useHookEffect` — Vue composable for lifecycle-aware subscriptions.
````

## File: hooks/typed-hooks.md
````markdown
# typed-hooks

Typed wrapper around the hook engine that preserves runtime behavior while delivering full TypeScript inference.

---

## What does it do?

-   Wraps a `HookEngine` with strongly typed methods for registering/executing hooks.
-   Infers callback signatures from `hook-types.ts` using `InferHookCallback` utilities.
-   Normalizes `hooks.on` to pick `action` vs `filter` automatically when the name contains `:filter:`.
-   Exposes diagnostics and the underlying engine for advanced use.

---

## API

`createTypedHookEngine(engine: HookEngine): TypedHookEngine`

Returns an object implementing:

-   `addAction`, `removeAction`, `doAction`, `doActionSync`
-   `addFilter`, `removeFilter`, `applyFilters`, `applyFiltersSync`
-   `on`, `off`, `onceAction`
-   `hasAction`, `hasFilter`, `removeAllCallbacks`, `currentPriority`
-   `_engine`, `_diagnostics`

### Example

```ts
import { createHookEngine } from '~/core/hooks/hooks';
import { createTypedHookEngine } from '~/core/hooks/typed-hooks';

const engine = createHookEngine();
const hooks = createTypedHookEngine(engine);

hooks.addFilter('ui.chat.message:filter:outgoing', (text) => text.trim());
const sanitized = await hooks.applyFilters(
    'ui.chat.message:filter:outgoing',
    message
);
```

TypeScript enforces that callbacks return the correct value (`string` above) and that the hook name exists.

---

## Kind inference

-   `on(name, callback, opts?)` automatically sets `opts.kind` to `'filter'` when the name includes `':filter:'`.
-   You can still override `opts.kind` to handle custom naming schemes.

---

## Passthrough utilities

-   `hasAction` / `hasFilter` — Useful for tests or debugging.
-   `removeAllCallbacks` — Clear listeners by priority (e.g., during teardown).
-   `currentPriority` — Inspect priority during nested hook execution.
-   `_diagnostics` — Direct access to timing/error aggregates from the base engine.

---

## Usage tips

-   Use `useHooks()` (which already wraps the injected engine) instead of building a new typed engine in most components.
-   Export the typed instance when building plugins so consumers benefit from strong typing.
-   When extending hook payloads via declaration merging, the typed engine automatically reflects the new signatures.
````

## File: hooks/useHooks.md
````markdown
# useHooks

Nuxt composable that returns the app-wide typed hook engine, creating a fallback instance when none is provided.

---

## What does it do?

-   Reads the injected `$hooks` instance from `useNuxtApp()`.
-   Wraps it with `createTypedHookEngine` to provide full TypeScript inference.
-   Caches the typed engine per provider to avoid rebuilding wrappers.
-   Creates a dev-only fallback hook engine when `$hooks` is missing (e.g., during unit tests).

---

## API

```ts
function useHooks(): TypedHookEngine;
```

Example usage:

```ts
const hooks = useHooks();

hooks.doAction('ui.pane.active:action', {
    pane,
    index: 0,
});

const sanitized = await hooks.applyFilters(
    'ui.chat.message:filter:outgoing',
    draft
);
```

-   The returned object includes every typed method described in `typed-hooks.md`.
-   Consumers do not need to import `hook-types` directly; inference is automatic.

---

## Fallback behavior

-   When `$hooks` is absent (tests, SSR stubs), the composable instantiates a local engine and logs a warning in dev mode.
-   The fallback stays cached across calls so listeners persist for the session.

---

## Caching strategy

-   Stores `{ engine, typed }` in a module-level `cached` object keyed by the current `$hooks` reference.
-   When the provider changes (e.g., HMR re-injection), the typed wrapper is rebuilt to keep methods in sync.

---

## Usage tips

-   Call `useHooks()` inside Vue `setup()` or other composables; it relies on Nuxt’s app context.
-   Pair with `useHookEffect` when you want automatic lifecycle cleanup around `hooks.on`.
-   In tests, stub `$hooks` on the Nuxt app to assert listener registration without touching the fallback.
````

## File: types/composables.md
````markdown
# Composables types

Canonical reference for every exported TypeScript type and interface defined under `app/composables`. These contracts power registry utilities, workspace state, streaming, UI chrome, and plugin extension points. Each table links the shape you consume when building features or plugins on top of the composable layer.

---

## Shared registry helpers (`app/composables/_registry.ts`)

| Type             | Kind      | Description                                                                                                                            |
| ---------------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| `RegistryItem`   | interface | Minimal contract for registry entries (`id`, optional `order`). Shared by sidebar, header, project tree, and other registries.         |
| `RegistryApi<T>` | interface | Generic API returned by `createRegistry` exposing `register`, `unregister`, `listIds`, `snapshot`, and a reactive `useItems()` helper. |

```ts
// app/composables/_registry.ts
import { computed, shallowRef } from 'vue';
import type { ComputedRef, ShallowRef } from 'vue';

export interface RegistryItem {
    id: string;
    order?: number;
}

export interface RegistryApi<T extends RegistryItem> {
    register(item: T): void;
    unregister(id: string): void;
    listIds(): string[];
    snapshot(): T[];
    useItems(): ComputedRef<readonly T[]>;
}

export function createRegistry<T extends RegistryItem>(
    globalKey: string,
    sortFn: (a: T, b: T) => number = (a, b) =>
        (a.order ?? 200) - (b.order ?? 200)
): RegistryApi<T> {
    const g: any = globalThis as any;
    const registry: Map<string, T> =
        g[globalKey] || (g[globalKey] = new Map<string, T>());
    const store: ShallowRef<T[]> = shallowRef([]);

    function sync() {
        store.value = Array.from(registry.values());
    }

    function register(item: T) {
        if (import.meta.dev && registry.has(item.id)) {
            console.warn(`[registry:${globalKey}] Replacing id: ${item.id}`);
        }
        const frozen = Object.freeze({ ...item });
        registry.set(item.id, frozen);
        sync();
    }

    function unregister(id: string) {
        if (registry.delete(id)) sync();
    }

    function listIds() {
        return Array.from(registry.keys());
    }

    function snapshot(): T[] {
        return store.value.slice();
    }

    function useItems(): ComputedRef<readonly T[]> {
        return computed(() => [...store.value].sort(sortFn));
    }

    if (!store.value.length && registry.size) sync();

    return { register, unregister, listIds, snapshot, useItems };
}
```

---

## Workspace backup & preview caching

| Type                   | Kind      | Description                                                                                                                                  |
| ---------------------- | --------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| `WorkspaceImportMode`  | union     | `'replace'` or `'append'`; controls how imports merge with the existing Dexie database.                                                      |
| `WorkspaceBackupState` | interface | Reactive state bag returned by `useWorkspaceBackup()` (`isExporting`, `progress`, `currentStep`, `importMode`, `backupMeta`, `error`, etc.). |
| `ImportMetadata`       | interface | Parsed metadata pulled from `.or3` exports: database name/version plus per-table row counts.                                                 |
| `WorkspaceBackupApi`   | interface | Public API of `useWorkspaceBackup()` exposing `exportWorkspace`, `peekBackup`, `importWorkspace`, and `reset`.                               |
| `PreviewCacheOptions`  | alias     | Re-exported from `~/config/preview-cache`; defines limits such as `maxUrls`, `maxBytes`, and eviction strategy knobs.                        |
| `PreviewCacheMetrics`  | interface | Snapshot of cache stats (`urls`, `bytes`, `hits`, `misses`, `evictions`) produced by `usePreviewCache().metrics()`.                          |

```ts
// app/composables/core/useWorkspaceBackup.ts
import { ref, type Ref } from 'vue';
import type { AppError } from '~/utils/errors';

export type WorkspaceImportMode = 'replace' | 'append';

export interface WorkspaceBackupState {
    isExporting: Ref<boolean>;
    isImporting: Ref<boolean>;
    progress: Ref<number>;
    currentStep: Ref<
        | 'idle'
        | 'peeking'
        | 'confirm'
        | 'importing'
        | 'exporting'
        | 'done'
        | 'error'
    >;
    importMode: Ref<WorkspaceImportMode>;
    overwriteValues: Ref<boolean>;
    backupMeta: Ref<ImportMetadata | null>;
    backupFormat: Ref<'stream' | 'dexie' | null>;
    error: Ref<AppError | null>;
}

export interface ImportMetadata {
    databaseName: string;
    databaseVersion: number;
    tables: Array<{ name: string; rowCount: number }>;
}

export interface WorkspaceBackupApi {
    state: WorkspaceBackupState;
    exportWorkspace(): Promise<void>;
    peekBackup(file: Blob): Promise<void>;
    importWorkspace(file: Blob): Promise<void>;
    reset(): void;
}
```

```ts
// app/config/preview-cache.ts
export type PreviewCacheOptions = {
    maxUrls: number;
    maxBytes: number;
};

const BASE_LIMITS: PreviewCacheOptions = {
    maxUrls: 120,
    maxBytes: 80 * 1024 * 1024,
};

const LOW_MEMORY_LIMITS: PreviewCacheOptions = {
    maxUrls: 80,
    maxBytes: 48 * 1024 * 1024,
};

function detectDeviceMemory(): number | undefined {
    if (typeof navigator === 'undefined') return undefined;
    const value = (navigator as any).deviceMemory;
    return typeof value === 'number' && Number.isFinite(value)
        ? value
        : undefined;
}

export function resolvePreviewCacheOptions(
    overrides: Partial<PreviewCacheOptions> = {}
): PreviewCacheOptions {
    const memory = detectDeviceMemory();
    const defaults = memory && memory <= 4 ? LOW_MEMORY_LIMITS : BASE_LIMITS;
    return {
        maxUrls: overrides.maxUrls ?? defaults.maxUrls,
        maxBytes: overrides.maxBytes ?? defaults.maxBytes,
    };
}
```

```ts
// app/composables/core/usePreviewCache.ts
import type { PreviewCacheOptions } from '~/config/preview-cache';

export interface PreviewCacheMetrics {
    urls: number;
    bytes: number;
    hits: number;
    misses: number;
    evictions: number;
}
```

---

## Multi-pane orchestration (`app/composables/core/useMultiPane.ts`, `documents/usePaneDocuments.ts`)

| Type                      | Kind      | Description                                                                                                              |
| ------------------------- | --------- | ------------------------------------------------------------------------------------------------------------------------ |
| `MultiPaneMessage`        | interface | Normalised pane message payload (`role`, `content`, optional `file_hashes`, `id`, `stream_id`).                          |
| `PaneState`               | interface | Persistent pane descriptor (`id`, `mode`, `threadId`, optional `documentId`, `messages`, `validating`).                  |
| `UseMultiPaneOptions`     | interface | Optional configuration for `useMultiPane()` (`initialThreadId`, `maxPanes`, `onFlushDocument`, `loadMessagesFor`).       |
| `UseMultiPaneApi`         | interface | Methods returned by `useMultiPane()` (`panes`, `activePaneIndex`, `addPane`, `setPaneThread`, navigation helpers, etc.). |
| `MultiPaneState`          | alias     | Re-export of `PaneState` for consumers that prefer `MultiPaneState[]` semantics.                                         |
| `UsePaneDocumentsOptions` | interface | `usePaneDocuments()` inputs (pane refs, `activePaneIndex`, `createNewDoc`, `flushDocument`).                             |
| `UsePaneDocumentsApi`     | interface | Document helpers returned by `usePaneDocuments()` (`newDocumentInActive`, `selectDocumentInActive`).                     |

```ts
// app/composables/core/useMultiPane.ts
import type { Ref, ComputedRef } from 'vue';

export type MultiPaneMessage = {
    role: 'user' | 'assistant';
    content: string;
    file_hashes?: string | null;
    id?: string;
    stream_id?: string;
};

export interface PaneState {
    id: string;
    mode: 'chat' | 'doc';
    threadId: string;
    documentId?: string;
    messages: MultiPaneMessage[];
    validating: boolean;
}

export interface UseMultiPaneOptions {
    initialThreadId?: string;
    maxPanes?: number;
    onFlushDocument?: (id: string) => void | Promise<void>;
    loadMessagesFor?: (id: string) => Promise<MultiPaneMessage[]>;
}

export interface UseMultiPaneApi {
    panes: Ref<PaneState[]>;
    activePaneIndex: Ref<number>;
    canAddPane: ComputedRef<boolean>;
    newWindowTooltip: ComputedRef<string>;
    addPane(): void;
    closePane(index: number): Promise<void> | void;
    setActive(index: number): void;
    focusPrev(current: number): void;
    focusNext(current: number): void;
    setPaneThread(index: number, threadId: string): Promise<void>;
    loadMessagesFor(id: string): Promise<MultiPaneMessage[]>;
    ensureAtLeastOne(): void;
}

export type MultiPaneState = PaneState;

// app/composables/documents/usePaneDocuments.ts
```

```ts
// app/composables/documents/usePaneDocuments.ts
import type { Ref } from 'vue';
import type { MultiPaneState } from '~/composables/core/useMultiPane';

export interface UsePaneDocumentsOptions {
    panes: Ref<MultiPaneState[]>;
    activePaneIndex: Ref<number>;
    createNewDoc: (initial?: { title?: string }) => Promise<{ id: string }>;
    flushDocument: (id: string) => Promise<void> | void;
}

export interface UsePaneDocumentsApi {
    newDocumentInActive(initial?: {
        title?: string;
    }): Promise<{ id: string } | undefined>;
    selectDocumentInActive(id: string): Promise<void>;
}
```

---

## Document & thread history registries

| Type                    | Kind      | Description                                                                                                  |
| ----------------------- | --------- | ------------------------------------------------------------------------------------------------------------ |
| `DocumentHistoryAction` | interface | Defines sidebar document history actions (id, icon, label, optional `order`, async `handler({ document })`). |
| `ThreadHistoryAction`   | interface | Same pattern for thread history dropdown entries (`handler({ document: Thread })`).                          |

```ts
// app/composables/documents/useDocumentHistoryActions.ts
import type { Post } from '~/db';

export interface DocumentHistoryAction {
    id: string;
    icon: string;
    label: string;
    order?: number;
    handler: (ctx: { document: Post }) => void | Promise<void>;
}

// app/composables/threads/useThreadHistoryActions.ts
import type { Thread } from '~/db';

export interface ThreadHistoryAction {
    id: string;
    icon: string;
    label: string;
    order?: number;
    handler: (ctx: { document: Thread }) => void | Promise<void>;
}
```

---

## Prompt, messaging & AI state

| Type                | Kind      | Description                                                                                                       |
| ------------------- | --------- | ----------------------------------------------------------------------------------------------------------------- |
| `ActivePromptState` | interface | Module-singleton state describing the currently selected system prompt (`activePromptId`, `activePromptContent`). |
| `ChatMessageAction` | interface | Extendable chat message action button contract (id, icon, tooltip, `showOn`, optional `order`, async handler).    |
| `AiSettingsV1`      | interface | Persisted AI preferences (`masterSystemPrompt`, `defaultModelMode`, optional `fixedModelId`, schema version).     |

```ts
// app/composables/chat/useActivePrompt.ts
import { ref, readonly } from 'vue';

export interface ActivePromptState {
    activePromptId: string | null;
    activePromptContent: any | null;
}

// app/composables/chat/useMessageActions.ts
export interface ChatMessageAction {
    id: string;
    icon: string;
    tooltip: string;
    showOn: 'user' | 'assistant' | 'both';
    order?: number;
    handler: (ctx: { message: any; threadId?: string }) => void | Promise<void>;
}

// app/composables/chat/useAiSettings.ts
export interface AiSettingsV1 {
    version: 1;
    masterSystemPrompt: string;
    defaultModelMode: 'lastSelected' | 'fixed';
    fixedModelId: string | null;
}
```

---

## Streaming accumulator (`app/composables/chat/useStreamAccumulator.ts`)

| Type                    | Kind      | Description                                                                                         |
| ----------------------- | --------- | --------------------------------------------------------------------------------------------------- |
| `StreamingState`        | interface | Reactive token buffer state (`text`, `reasoningText`, `isActive`, `finalized`, `error`, `version`). |
| `AppendKind`            | union     | `'text'` or `'reasoning'`; distinguishes which buffer `append()` targets.                           |
| `StreamAccumulatorApi`  | interface | Contract returned by `createStreamAccumulator()` (`state`, `append`, `finalize`, `reset`).          |
| `UnifiedStreamingState` | alias     | Re-export of `StreamingState` for callers expecting the previous naming.                            |

```ts
// app/composables/chat/useStreamAccumulator.ts
export interface StreamingState {
    text: string;
    reasoningText: string;
    isActive: boolean;
    finalized: boolean;
    error: Error | null;
    version: number;
}

export type AppendKind = 'text' | 'reasoning';

export interface StreamAccumulatorApi {
    state: Readonly<StreamingState>;
    append(delta: string, options: { kind: AppendKind }): void;
    finalize(opts?: { error?: Error; aborted?: boolean }): void;
    reset(): void;
}

export type UnifiedStreamingState = StreamingState;
```

---

## Project tree & workspace CRUD

| Type                    | Kind      | Description                                                                                               |
| ----------------------- | --------- | --------------------------------------------------------------------------------------------------------- |
| `ProjectTreeKind`       | union     | `'chat'` or `'doc'`; identifies tree row flavor.                                                          |
| `ShowOnKind`            | union     | `'root'`, `'all'`, `'chat'`, `'doc'`; used to limit project tree actions.                                 |
| `ProjectTreeChild`      | interface | Child row descriptor (value, label, optional icon/parentId/select handler).                               |
| `ProjectTreeRoot`       | interface | Root row descriptor (project id/name, optional expansion flag, children, handler).                        |
| `ProjectTreeRow`        | alias     | Union of `ProjectTreeRoot` and `ProjectTreeChild`.                                                        |
| `ProjectTreeHandlerCtx` | interface | Context passed to project tree action handlers (`treeRow`, plus legacy `child`/`root`).                   |
| `ProjectTreeAction`     | interface | Registry entry for project tree context menu items (id, icon, label, optional `order`/`showOn`, handler). |
| `CreateProjectInput`    | interface | Input accepted by `useProjectsCrud().createProject` (name, optional description/id override).             |
| `DeleteProjectOptions`  | interface | Options for `deleteProject` (`soft` defaults to true, `false` triggers hard delete).                      |

```ts
// app/composables/projects/useProjectTreeActions.ts
import type { RegistryItem } from '#imports';

export type ProjectTreeKind = 'chat' | 'doc';
export type ShowOnKind = 'root' | 'all' | 'chat' | 'doc';

export interface ProjectTreeChild {
    value: string;
    label: string;
    icon?: string;
    kind?: ProjectTreeKind;
    parentId?: string;
    onSelect?: (e: Event) => void;
}

export interface ProjectTreeRoot {
    value: string;
    label: string;
    defaultExpanded?: boolean;
    children?: ProjectTreeChild[];
    onSelect?: (e: Event) => void;
}

export type ProjectTreeRow = ProjectTreeRoot | ProjectTreeChild;

export interface ProjectTreeHandlerCtx {
    treeRow: ProjectTreeRow;
    child?: ProjectTreeChild;
    root?: ProjectTreeRoot;
}

export interface ProjectTreeAction extends RegistryItem {
    id: string;
    icon: string;
    label: string;
    order?: number;
    showOn?: ShowOnKind[];
    handler: (ctx: ProjectTreeHandlerCtx) => void | Promise<void>;
}

// app/composables/projects/useProjectsCrud.ts
export interface CreateProjectInput {
    name: string;
    description?: string | null;
    id?: string;
}

export interface DeleteProjectOptions {
    soft?: boolean;
}
```

---

## Dashboard plugins & navigation

| Type                            | Kind      | Description                                                                                                             |
| ------------------------------- | --------- | ----------------------------------------------------------------------------------------------------------------------- |
| `DashboardPlugin`               | interface | Primary plugin registration shape (id, icon, label, optional description/order/handler/pages/capabilities).             |
| `DashboardPluginPage`           | interface | Per-plugin page descriptor (id, title, optional icon/order/description, component or async factory).                    |
| `DashboardNavigationErrorCode`  | union     | Error codes emitted by navigation helpers (`'missing-plugin'`, `'missing-page'`, `'handler-error'`, `'resolve-error'`). |
| `DashboardNavigationError`      | interface | Structured error object carrying a `message`, optional plugin/page context, and original `cause`.                       |
| `DashboardNavigationState`      | interface | Reactive navigation state (`view`, `activePluginId`, `activePageId`, `loadingPage`, `error`).                           |
| `DashboardNavigationResult`     | union     | Result wrapper for navigation attempts (`{ ok: true }` or `{ ok: false; error }`).                                      |
| `UseDashboardNavigationOptions` | interface | Optional base plugin list for `useDashboardNavigation()` bootstrap.                                                     |

```ts
// app/composables/dashboard/useDashboardPlugins.ts
import type { Component } from 'vue';

export interface DashboardPlugin {
    id: string;
    icon: string;
    label: string;
    description?: string;
    order?: number;
    handler?: (ctx: { id: string }) => void | Promise<void>;
    pages?: DashboardPluginPage[];
    capabilities?: string[];
}

export interface DashboardPluginPage {
    id: string;
    title: string;
    icon?: string;
    order?: number;
    description?: string;
    component: Component | (() => Promise<any>);
}

export type DashboardNavigationErrorCode =
    | 'missing-plugin'
    | 'missing-page'
    | 'handler-error'
    | 'resolve-error';

export interface DashboardNavigationError {
    code: DashboardNavigationErrorCode;
    message: string;
    pluginId?: string;
    pageId?: string;
    cause?: unknown;
}

export interface DashboardNavigationState {
    view: 'dashboard' | 'page';
    activePluginId: string | null;
    activePageId: string | null;
    loadingPage: boolean;
    error: DashboardNavigationError | null;
}

export type DashboardNavigationResult =
    | { ok: true }
    | { ok: false; error: DashboardNavigationError };

export interface UseDashboardNavigationOptions {
    baseItems?: DashboardPlugin[];
}
```

---

## Sidebar, header & composer chrome

| Type                         | Kind      | Description                                                                                                            |
| ---------------------------- | --------- | ---------------------------------------------------------------------------------------------------------------------- |
| `SidebarSectionPlacement`    | union     | `'top'`, `'main'`, or `'bottom'`; controls where custom sections render.                                               |
| `SidebarSection`             | interface | Registry entry for sidebar stack sections (id, component/async loader, optional `order`/`placement`).                  |
| `SidebarFooterActionContext` | interface | Runtime context passed to footer action handlers (`activeThreadId`, `activeDocumentId`, `isCollapsed`).                |
| `ChromeActionColor`          | union     | Palette of supported footer/header button colors (Iconify-compatible strings plus strong/neutral variants).            |
| `SidebarFooterAction`        | interface | Footer action registry entry (id, icon, optional label/tooltip/order/color, handler + visibility/disabled predicates). |
| `SidebarFooterActionEntry`   | interface | Derived tuple returned by `useSidebarFooterActions()` (`action`, `disabled`).                                          |
| `HeaderActionContext`        | interface | Context for header actions (current route, `isMobile`, arbitrary params).                                              |
| `HeaderAction`               | interface | Header action registry entry (id, icon, optional tooltip/label/order/color, handler + visibility/disabled guards).     |
| `HeaderActionEntry`          | interface | Result rows returned by `useHeaderActions()` with resolved `disabled` state.                                           |
| `ComposerActionContext`      | interface | Composer button context (`editor`, `threadId`, `paneId`, `isStreaming`, custom metadata).                              |
| `ComposerAction`             | interface | Composer toolbar action contract (id, icon, optional tooltip/label/order/color, handler + visibility/disabled guards). |
| `ComposerActionEntry`        | interface | Wrapper returned by `useComposerActions()` that pairs an action with its `disabled` flag.                              |

```ts
// app/composables/sidebar/useSidebarSections.ts
import type { Component, ComputedRef } from 'vue';
import type { RouteLocationNormalizedLoaded } from 'vue-router';
import type { Editor } from '@tiptap/vue-3';
import type { RegistryItem } from '../_registry';

export type SidebarSectionPlacement = 'top' | 'main' | 'bottom';

export interface SidebarSection extends RegistryItem {
    id: string;
    component: Component | (() => Promise<any>);
    order?: number;
    placement?: SidebarSectionPlacement;
}

export interface SidebarFooterActionContext {
    activeThreadId?: string | null;
    activeDocumentId?: string | null;
    isCollapsed?: boolean;
}

export type ChromeActionColor =
    | 'neutral'
    | 'primary'
    | 'secondary'
    | 'success'
    | 'warning'
    | 'error'
    | 'info'
    | 'inverse-primary'
    | (string & {});

export interface SidebarFooterAction extends RegistryItem {
    id: string;
    icon: string;
    label?: string;
    tooltip?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: SidebarFooterActionContext) => void | Promise<void>;
    visible?: (ctx: SidebarFooterActionContext) => boolean;
    disabled?: (ctx: SidebarFooterActionContext) => boolean;
}

export interface SidebarFooterActionEntry {
    action: SidebarFooterAction;
    disabled: boolean;
}

// app/composables/sidebar/useHeaderActions.ts
export interface HeaderActionContext {
    route?: RouteLocationNormalizedLoaded | null;
    isMobile?: boolean;
    [key: string]: unknown;
}

export interface HeaderAction extends RegistryItem {
    id: string;
    icon: string;
    tooltip?: string;
    label?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: HeaderActionContext) => void | Promise<void>;
    visible?: (ctx: HeaderActionContext) => boolean;
    disabled?: (ctx: HeaderActionContext) => boolean;
}

export interface HeaderActionEntry {
    action: HeaderAction;
    disabled: boolean;
}

// app/composables/sidebar/useComposerActions.ts
export interface ComposerActionContext {
    editor?: Editor | null;
    threadId?: string | null;
    paneId?: string | null;
    isStreaming?: boolean;
    [key: string]: unknown;
}

export interface ComposerAction {
    id: string;
    icon: string;
    tooltip?: string;
    label?: string;
    order?: number;
    color?: ChromeActionColor;
    handler: (ctx: ComposerActionContext) => void | Promise<void>;
    visible?: (ctx: ComposerActionContext) => boolean;
    disabled?: (ctx: ComposerActionContext) => boolean;
}

export interface ComposerActionEntry {
    action: ComposerAction;
    disabled: boolean;
}
```

---

## Editor extension points (`app/composables/editor`)

| Type                  | Kind      | Description                                                                                                     |
| --------------------- | --------- | --------------------------------------------------------------------------------------------------------------- |
| `EditorNode`          | interface | TipTap node extension registration (id, `Node` instance, optional `order`).                                     |
| `EditorMark`          | interface | TipTap mark extension registration (id, `Mark` instance, optional `order`).                                     |
| `EditorExtension`     | interface | Generic TipTap extension registration (id, `Extension` instance, optional `order`).                             |
| `EditorToolbarButton` | interface | Editor toolbar button contract (id, icon, tooltip, optional `order`, `isActive`, `visible`, and click handler). |

```ts
// app/composables/editor/useEditorNodes.ts
import type { Node, Mark, Extension } from '@tiptap/core';

export interface EditorNode {
    id: string;
    extension: Node;
    order?: number;
}

export interface EditorMark {
    id: string;
    extension: Mark;
    order?: number;
}

export interface EditorExtension {
    id: string;
    extension: Extension;
    order?: number;
}

// app/composables/editor/useEditorToolbar.ts
import type { Editor } from '@tiptap/vue-3';

export interface EditorToolbarButton {
    id: string;
    icon: string;
    tooltip?: string;
    order?: number;
    isActive?: (editor: Editor) => boolean;
    onClick: (editor: Editor) => void | Promise<void>;
    visible?: (editor: Editor) => boolean;
}
```

---

Maintaining this catalogue alongside the code ensures plugin authors and internal feature teams share a single source of truth. Update the relevant section whenever you add, rename, or extend a composable type so the documentation stays authoritative.
````

## File: types/database.md
````markdown
# Database types

Reference for every exported type and interface defined under `app/db`. These aliases describe the Dexie schema, higher-level records, and helper payloads that wrap database operations.

---

## Schema-derived entities (`app/db/schema.ts`)

| Type               | Kind  | Source schema                  | Description                                                                                          |
| ------------------ | ----- | ------------------------------ | ---------------------------------------------------------------------------------------------------- |
| `Project`          | alias | `ProjectSchema`                | Fully validated project row (id, name, description, clocks, timestamps).                             |
| `Thread`           | alias | `ThreadSchema`                 | Thread row with branching metadata, status flags, and clock fields.                                  |
| `ThreadCreate`     | alias | `ThreadCreateSchema` input     | Looser input shape accepted when creating a thread prior to validation.                              |
| `Message`          | alias | `MessageSchema`                | Stored message row with role, data payload, ordering index, and timestamps.                          |
| `MessageCreate`    | alias | `MessageCreateSchema` input    | Input contract for new messages before normalization (allows sparse indexes, file hashes as arrays). |
| `Post`             | alias | `PostSchema`                   | Post/blog row persisted in Dexie.                                                                    |
| `PostCreate`       | alias | `PostCreateSchema` input       | Input structure for creating posts.                                                                  |
| `Kv`               | alias | `KvSchema`                     | Key-value record (name/value pairs plus clock/timestamps).                                           |
| `KvCreate`         | alias | `KvCreateSchema`               | Input payload for inserting KV entries.                                                              |
| `Attachment`       | alias | `AttachmentSchema`             | Attachment row linking messages to files.                                                            |
| `AttachmentCreate` | alias | `AttachmentCreateSchema` input | Input contract for creating attachments.                                                             |
| `FileMeta`         | alias | `FileMetaSchema`               | Stored metadata for blobs (hash, mime, size, soft delete flags).                                     |
| `FileMetaCreate`   | alias | `FileMetaCreateSchema` input   | Input structure when minting new file metadata.                                                      |

The `app/db/index.ts` barrel re-exports these aliases (including `Document`) for consumers using `import { Thread } from '~/db'` style imports.

```ts
// app/db/schema.ts
import { z } from 'zod';
import { newId, nowSec } from './util';

export const ProjectSchema = z.object({
    id: z.string(),
    name: z.string(),
    description: z.string().nullable().optional(),
    data: z.any(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    deleted: z.boolean().default(false),
    clock: z.number().int(),
});
export type Project = z.infer<typeof ProjectSchema>;

export const ThreadSchema = z.object({
    id: z.string(),
    title: z.string().nullable().optional(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    last_message_at: z.number().int().nullable().optional(),
    parent_thread_id: z.string().nullable().optional(),
    anchor_message_id: z.string().nullable().optional(),
    anchor_index: z.number().int().nullable().optional(),
    branch_mode: z.enum(['reference', 'copy']).nullable().optional(),
    status: z.string().default('ready'),
    deleted: z.boolean().default(false),
    pinned: z.boolean().default(false),
    clock: z.number().int(),
    forked: z.boolean().default(false),
    project_id: z.string().nullable().optional(),
    system_prompt_id: z.string().nullable().optional(),
});
export type Thread = z.infer<typeof ThreadSchema>;

export const ThreadCreateSchema = ThreadSchema.partial({
    id: true,
    title: true,
    last_message_at: true,
    parent_thread_id: true,
    status: true,
    deleted: true,
    pinned: true,
    forked: true,
    project_id: true,
    system_prompt_id: true,
})
    .omit({ created_at: true, updated_at: true, id: true, clock: true })
    .extend({
        id: z
            .string()
            .optional()
            .transform((v) => v ?? newId()),
        clock: z
            .number()
            .int()
            .optional()
            .transform((v) => v ?? 0),
        created_at: z.number().int().default(nowSec()),
        updated_at: z.number().int().default(nowSec()),
    });
export type ThreadCreate = z.input<typeof ThreadCreateSchema>;

export const MessageSchema = z.object({
    id: z.string(),
    data: z.unknown().nullable().optional(),
    role: z.string(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    error: z.string().nullable().optional(),
    deleted: z.boolean().default(false),
    thread_id: z.string(),
    index: z.number().int(),
    clock: z.number().int(),
    stream_id: z.string().nullable().optional(),
    file_hashes: z.string().nullable().optional(),
});
export type Message = z.infer<typeof MessageSchema>;

export const MessageCreateSchema = MessageSchema.partial({ index: true })
    .omit({ created_at: true, updated_at: true, id: true, clock: true })
    .extend({
        id: z
            .string()
            .optional()
            .transform((v) => v ?? newId()),
        clock: z
            .number()
            .int()
            .optional()
            .transform((v) => v ?? 0),
        created_at: z.number().int().default(nowSec()),
        updated_at: z.number().int().default(nowSec()),
    });
export type MessageCreate = z.input<typeof MessageCreateSchema>;

export const PostSchema = z.object({
    id: z.string(),
    title: z
        .string()
        .transform((s) => s.trim())
        .refine((s) => s.length > 0, 'Title is required'),
    content: z.string().default(''),
    postType: z.string().default('markdown'),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    deleted: z.boolean().default(false),
    meta: z.union([
        z.string(),
        z.object({
            key: z.string(),
            value: z.string().nullable().optional(),
        }),
        z
            .array(
                z.object({
                    key: z.string(),
                    value: z.string().nullable().optional(),
                })
            )
            .nullable()
            .optional(),
    ]),
    file_hashes: z.string().nullable().optional(),
});
export type Post = z.infer<typeof PostSchema>;

export const PostCreateSchema = PostSchema.partial({
    id: true,
    created_at: true,
    updated_at: true,
}).extend({
    id: z
        .string()
        .optional()
        .transform((v) => v ?? newId()),
    created_at: z.number().int().default(nowSec()),
    updated_at: z.number().int().default(nowSec()),
});
export type PostCreate = z.input<typeof PostCreateSchema>;

export const KvSchema = z.object({
    id: z.string(),
    name: z.string(),
    value: z.string().nullable().optional(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    clock: z.number().int(),
});
export type Kv = z.infer<typeof KvSchema>;

export const KvCreateSchema = KvSchema.omit({
    created_at: true,
    updated_at: true,
}).extend({
    created_at: z.number().int().default(nowSec()),
    updated_at: z.number().int().default(nowSec()),
});
export type KvCreate = z.infer<typeof KvCreateSchema>;

export const AttachmentSchema = z.object({
    id: z.string(),
    type: z.string(),
    name: z.string(),
    url: z.url(),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    deleted: z.boolean().default(false),
    clock: z.number().int(),
});
export type Attachment = z.infer<typeof AttachmentSchema>;

export const AttachmentCreateSchema = AttachmentSchema.omit({
    created_at: true,
    updated_at: true,
}).extend({
    created_at: z.number().int().default(nowSec()),
    updated_at: z.number().int().default(nowSec()),
});
export type AttachmentCreate = z.infer<typeof AttachmentCreateSchema>;

export const FileMetaSchema = z.object({
    hash: z.string(),
    name: z.string(),
    mime_type: z.string(),
    kind: z.enum(['image', 'pdf']).default('image'),
    size_bytes: z.number().int(),
    width: z.number().int().optional(),
    height: z.number().int().optional(),
    page_count: z.number().int().optional(),
    ref_count: z.number().int().default(0),
    created_at: z.number().int(),
    updated_at: z.number().int(),
    deleted: z.boolean().default(false),
    clock: z.number().int(),
});
export type FileMeta = z.infer<typeof FileMetaSchema>;

export const FileMetaCreateSchema = FileMetaSchema.omit({
    created_at: true,
    updated_at: true,
    ref_count: true,
}).extend({
    created_at: z.number().int().default(nowSec()),
    updated_at: z.number().int().default(nowSec()),
    ref_count: z.number().int().default(1),
    clock: z.number().int().default(0),
});
export type FileMetaCreate = z.infer<typeof FileMetaCreateSchema>;
```

---

## Document store helpers (`app/db/documents.ts`)

| Type                  | Kind      | Description                                                                             |
| --------------------- | --------- | --------------------------------------------------------------------------------------- |
| `DocumentRow`         | interface | Minimal Dexie row projection (id, title, content, timestamps).                          |
| `DocumentRecord`      | interface | Extended record used in composables (includes denormalised helpers like `paneIndex`).   |
| `CreateDocumentInput` | interface | Shape accepted by `createDocument` before schema validation (title, content, metadata). |
| `UpdateDocumentPatch` | interface | Partial update payload (existing record, merged document data, metadata).               |
| `Document`            | alias     | Re-export of `DocumentRecord` for ergonomic imports.                                    |

```ts
// app/db/documents.ts
export interface DocumentRow {
    id: string;
    title: string;
    content: string;
    postType: string;
    created_at: number;
    updated_at: number;
    deleted: boolean;
}

export interface DocumentRecord {
    id: string;
    title: string;
    content: any;
    created_at: number;
    updated_at: number;
    deleted: boolean;
}

export interface CreateDocumentInput {
    title?: string | null;
    content?: any;
}

export interface UpdateDocumentPatch {
    title?: string;
    content?: any;
}

export type Document = DocumentRecord;
```

---

## Prompt store helpers (`app/db/prompts.ts`)

| Type                | Kind      | Description                                                               |
| ------------------- | --------- | ------------------------------------------------------------------------- |
| `PromptRow`         | interface | Dexie row projection (id, name, text, timestamps).                        |
| `PromptRecord`      | interface | Rich record returned by prompt helpers (includes folder/project context). |
| `CreatePromptInput` | interface | Input payload for creating prompts (name, text, optional metadata).       |
| `UpdatePromptPatch` | interface | Patch contract for updating prompts (existing record, updates, metadata). |
| `Prompt`            | alias     | Re-export of `PromptRecord` for ergonomic imports.                        |

```ts
// app/db/prompts.ts
export interface PromptRow {
    id: string;
    title: string;
    content: string;
    postType: string;
    created_at: number;
    updated_at: number;
    deleted: boolean;
}

export interface PromptRecord {
    id: string;
    title: string;
    content: any;
    created_at: number;
    updated_at: number;
    deleted: boolean;
}

export interface CreatePromptInput {
    title?: string | null;
    content?: any;
}

export interface UpdatePromptPatch {
    title?: string;
    content?: any;
}

export type Prompt = PromptRecord;
```

---

## File linking helpers

| Type          | Kind        | Description                                                                                                        |
| ------------- | ----------- | ------------------------------------------------------------------------------------------------------------------ |
| `AddableFile` | union alias | Discriminated union accepted by `addFilesToMessage` (`{ type: 'blob'; blob; name? }` or `{ type: 'hash'; hash }`). |
| `FileBlobRow` | interface   | Underlying Dexie row for the `file_blobs` table (`hash`, `blob`).                                                  |

```ts
// app/db/message-files.ts
export type AddableFile =
    | { type: 'blob'; blob: Blob; name?: string }
    | { type: 'hash'; hash: string };

// app/db/client.ts
export interface FileBlobRow {
    hash: string;
    blob: Blob;
}
```

---

## Operational utilities

| Type        | Kind      | Description                                                                                        |
| ----------- | --------- | -------------------------------------------------------------------------------------------------- | --------------------------------------------------------- |
| `DbTryTags` | interface | Metadata passed to `dbTry` (`op: 'read'                                                            | 'write'`, optional `entity`, arbitrary diagnostics tags). |
| `ForkMode`  | alias     | Re-export of `BranchMode` describing `'reference'` vs `'copy'` branch semantics in `branching.ts`. |

```ts
// app/db/dbTry.ts
export interface DbTryTags {
    readonly op: 'read' | 'write';
    readonly entity?: string;
    readonly [k: string]: any;
}

// app/db/branching.ts
import type { BranchMode } from '../core/hooks/hook-types';
export type ForkMode = BranchMode;
```

These helper types surface the inputs and outputs that higher-level database APIs expose to composables, hooks, and plugins. Keep them in sync with schema or payload changes so consumer code stays type-safe.
````

## File: types/hooks.md
````markdown
# Hooks types

Canonical reference for every exported TypeScript type and interface that powers the hook engine. All definitions come from `app/core/hooks/**/*.ts` and are grouped by concern so you can locate payload shapes, key unions, and helper generics quickly.

---

## Engine primitives

| Name              | Kind       | Description                                                                                                                             |
| ----------------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| `HookKind`        | union      | `'action'` or `'filter'`; used to declare hook registration intent.                                                                     |
| `RegisterOptions` | interface  | Common options (`priority`, `acceptedArgs`) shared by action/filter registration helpers.                                               |
| `OnOptions`       | interface  | Extends `RegisterOptions` with optional `kind` to drive the ergonomic `on()` helper.                                                    |
| `HookEngine`      | interface  | Runtime contract implemented by `createHookEngine()`; exposes registration, execution, diagnostics, and lifecycle helpers.              |
| `HookFn`          | type alias | Re-exports the internal `AnyFn` as a convenience import for external `.d.ts` usage.                                                     |
| `TypedHookEngine` | interface  | Purely type-level wrapper returned by `createTypedHookEngine()` exposing fully typed action/filter helpers while delegating at runtime. |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hooks.ts
export type HookKind = 'action' | 'filter';

export interface RegisterOptions {
    priority?: number;
    acceptedArgs?: number;
}

export interface OnOptions extends RegisterOptions {
    kind?: HookKind;
}

export type HookFn = (...args: any[]) => any;

export interface HookEngine {
    addFilter<F extends (...args: any[]) => any>(
        name: string,
        fn: F,
        priority?: number,
        acceptedArgs?: number
    ): void;
    removeFilter<F extends (...args: any[]) => any>(
        name: string,
        fn: F,
        priority?: number
    ): void;
    applyFilters<T>(name: string, value: T, ...args: any[]): Promise<T>;
    applyFiltersSync<T>(name: string, value: T, ...args: any[]): T;

    addAction<F extends (...args: any[]) => any>(
        name: string,
        fn: F,
        priority?: number,
        acceptedArgs?: number
    ): void;
    removeAction<F extends (...args: any[]) => any>(
        name: string,
        fn: F,
        priority?: number
    ): void;
    doAction(name: string, ...args: any[]): Promise<void>;
    doActionSync(name: string, ...args: any[]): void;

    hasFilter(name?: string, fn?: (...args: any[]) => any): boolean | number;
    hasAction(name?: string, fn?: (...args: any[]) => any): boolean | number;
    removeAllCallbacks(priority?: number): void;
    currentPriority(): number | false;

    onceAction(
        name: string,
        fn: (...args: any[]) => any,
        priority?: number
    ): () => void;
    on(name: string, fn: (...args: any[]) => any, opts?: OnOptions): () => void;
    off(disposer: () => void): void;

    _diagnostics: {
        timings: Record<string, number[]>;
        errors: Record<string, number>;
        callbacks(actionOrFilter?: HookKind): number;
    };
}

// Source: app/core/hooks/typed-hooks.ts
type Tail<T extends any[]> = T extends [any, ...infer Rest] ? Rest : [];

export interface TypedHookEngine {
    addAction<K extends ActionHookName>(
        name: K,
        callback: InferHookCallback<K>,
        priority?: number
    ): void;
    removeAction<K extends ActionHookName>(
        name: K,
        callback: InferHookCallback<K>,
        priority?: number
    ): void;
    doAction<K extends ActionHookName>(
        name: K,
        ...args: InferHookParams<K>
    ): Promise<void>;
    doActionSync<K extends ActionHookName>(
        name: K,
        ...args: InferHookParams<K>
    ): void;
    addFilter<K extends FilterHookName>(
        name: K,
        callback: InferHookCallback<K>,
        priority?: number
    ): void;
    removeFilter<K extends FilterHookName>(
        name: K,
        callback: InferHookCallback<K>,
        priority?: number
    ): void;
    applyFilters<K extends FilterHookName>(
        name: K,
        value: InferHookParams<K>[0],
        ...args: Tail<InferHookParams<K>>
    ): Promise<InferHookReturn<K>>;
    applyFiltersSync<K extends FilterHookName>(
        name: K,
        value: InferHookParams<K>[0],
        ...args: Tail<InferHookParams<K>>
    ): InferHookReturn<K>;
    on<K extends HookName>(
        name: K,
        callback: InferHookCallback<K>,
        opts?: OnOptions & {
            kind?: K extends ActionHookName
                ? 'action'
                : K extends FilterHookName
                ? 'filter'
                : 'action' | 'filter';
        }
    ): () => void;
    off(disposer: () => void): void;
    onceAction<K extends ActionHookName>(
        name: K,
        callback: InferHookCallback<K>,
        priority?: number
    ): () => void;
    hasAction<K extends ActionHookName>(
        name?: K,
        fn?: InferHookCallback<K>
    ): boolean | number;
    hasFilter<K extends FilterHookName>(
        name?: K,
        fn?: InferHookCallback<K>
    ): boolean | number;
    removeAllCallbacks(priority?: number): void;
    currentPriority(): number | false;
    readonly _engine: HookEngine;
    readonly _diagnostics: HookEngine['_diagnostics'];
}
```

---

## Key unions and handlers

| Name                       | Kind             | Description                                                                                                                                   |
| -------------------------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| `KnownHookKey`             | union            | Enumerates high-signal hook names (`ui.chat.message:filter:outgoing`, `ai.chat.send:action:before`, …) for first-class editor autocomplete.   |
| `DbFamily`                 | union            | Database table families (`'messages'`, `'documents'`, `'files'`, `'threads'`, `'projects'`, `'posts'`, `'prompts'`, `'attachments'`, `'kv'`). |
| `DbHookKey`                | template literal | Forms `db.${DbFamily}.${string}` for flexible DB hook addressing.                                                                             |
| `HookKey`                  | union            | Final public key type combining `KnownHookKey`, `DbHookKey`, and an open string fallback for plugins.                                         |
| `HookPayloads`             | interface        | Maps each `KnownHookKey` to its listener argument tuple (e.g. `'ui.pane.thread:filter:select'` → `[requestedId, pane, previousId]`).          |
| `ChatOutgoingFilterReturn` | alias            | `string \| false`; standardized return contract for outgoing chat filters.                                                                    |
| `ChatIncomingFilterReturn` | alias            | Always `string`; incoming assistant transforms must emit text.                                                                                |
| `FilesAttachFilterReturn`  | alias            | `FilesAttachInputPayload \| false`; allows file-attach veto from filters.                                                                     |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-keys.ts
export type KnownHookKey =
    | 'ui.chat.message:filter:outgoing'
    | 'ui.chat.message:filter:incoming'
    | 'ai.chat.model:filter:select'
    | 'ai.chat.messages:filter:input'
    | 'ai.chat.send:action:before'
    | 'ai.chat.send:action:after'
    | 'ai.chat.stream:action:delta'
    | 'ai.chat.stream:action:reasoning'
    | 'ai.chat.stream:action:complete'
    | 'ai.chat.stream:action:error'
    | 'ai.chat.retry:action:before'
    | 'ai.chat.retry:action:after'
    | 'ui.pane.active:action'
    | 'ui.pane.blur:action'
    | 'ui.pane.switch:action'
    | 'ui.pane.thread:filter:select'
    | 'ui.pane.thread:action:changed'
    | 'ui.pane.doc:filter:select'
    | 'ui.pane.doc:action:changed'
    | 'ui.pane.doc:action:saved'
    | 'ui.pane.msg:action:sent'
    | 'ui.pane.msg:action:received'
    | 'files.attach:filter:input';

export type DbFamily =
    | 'messages'
    | 'documents'
    | 'files'
    | 'threads'
    | 'projects'
    | 'posts'
    | 'prompts'
    | 'attachments'
    | 'kv';

export type DbHookKey = `db.${DbFamily}.${string}`;

export type HookKey = KnownHookKey | DbHookKey | (string & {});

export interface HookPayloads {
    'ai.chat.send:action:before': [AiSendBeforePayload];
    'ai.chat.send:action:after': [AiSendAfterPayload];
    'ai.chat.stream:action:delta': [string, AiStreamDeltaPayload];
    'ai.chat.stream:action:reasoning': [string, AiStreamReasoningPayload];
    'ai.chat.stream:action:complete': [AiStreamCompletePayload];
    'ai.chat.stream:action:error': [AiStreamErrorPayload];
    'ui.pane.msg:action:sent': [UiPaneMsgSentPayload];
    'ui.pane.msg:action:received': [UiPaneMsgReceivedPayload];
    'ui.pane.active:action': [UiPaneActivePayload];
    'ui.pane.blur:action': [UiPaneBlurPayload];
    'ui.pane.switch:action': [UiPaneSwitchPayload];
    'ui.pane.thread:filter:select': [
        string,
        UiPaneThreadChangedPayload['pane'],
        string
    ];
    'ui.pane.thread:action:changed': [UiPaneThreadChangedPayload];
    'ui.pane.doc:filter:select': [
        string,
        UiPaneDocChangedPayload['pane'],
        string
    ];
    'ui.pane.doc:action:changed': [UiPaneDocChangedPayload];
    'ui.pane.doc:action:saved': [UiPaneDocChangedPayload];
    'ui.chat.message:filter:outgoing': [string];
    'ui.chat.message:filter:incoming': [string, string | undefined];
    'ai.chat.model:filter:select': [string];
    'ai.chat.messages:filter:input': [any[]];
    'files.attach:filter:input': [FilesAttachInputPayload | false];
    'ai.chat.retry:action:before': [AiRetryBeforePayload];
    'ai.chat.retry:action:after': [AiRetryAfterPayload];
}

export type ChatOutgoingFilterReturn = string | false;
export type ChatIncomingFilterReturn = string;
export type FilesAttachFilterReturn = FilesAttachInputPayload | false;
```

---

## AI and chat payloads

| Name                        | Kind      | Description                                                                           |
| --------------------------- | --------- | ------------------------------------------------------------------------------------- |
| `AiSendBeforePayload`       | interface | Context before streaming begins (thread, model, user/assistant metadata).             |
| `AiSendAfterPayloadTimings` | interface | Timing breakdown (`startedAt`, `endedAt`, `durationMs`) attached to send completions. |
| `AiSendAfterPayload`        | interface | Post-send context including request/response summaries, timings, and abort flag.      |
| `AiStreamDeltaContext`      | interface | Token delta context (`threadId`, `assistantId`, lengths, `chunkIndex`).               |
| `AiStreamReasoningContext`  | interface | Reasoning stream metadata (reasoning span length).                                    |
| `AiStreamCompleteContext`   | interface | Final stream state (total length, reasoning length, file hashes).                     |
| `AiStreamErrorContext`      | interface | Error detail for streaming failures or aborts.                                        |
| `AiStreamDeltaPayload`      | alias     | Equal to `AiStreamDeltaContext` for ergonomics.                                       |
| `AiStreamReasoningPayload`  | alias     | Equal to `AiStreamReasoningContext`.                                                  |
| `AiStreamCompletePayload`   | alias     | Equal to `AiStreamCompleteContext`.                                                   |
| `AiStreamErrorPayload`      | alias     | Equal to `AiStreamErrorContext`.                                                      |
| `AiRetryBeforePayload`      | interface | Retry initiation context (original user/assistant IDs, trigger source).               |
| `AiRetryAfterPayload`       | interface | Retry completion context (replacement message IDs, thread).                           |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-types.ts
export interface AiSendBeforePayload {
    threadId?: string;
    modelId: string;
    user: { id: string; length: number };
    assistant: { id: string; streamId: string };
    messagesCount?: number;
}

export interface AiSendAfterPayloadTimings {
    startedAt: number;
    endedAt: number;
    durationMs: number;
}

export interface AiSendAfterPayload {
    threadId?: string;
    request?: { modelId?: string; userId?: string };
    response?: { assistantId?: string; length?: number };
    timings?: AiSendAfterPayloadTimings;
    aborted?: boolean;
}

export interface AiStreamDeltaContext {
    threadId?: string;
    assistantId: string;
    streamId: string;
    deltaLength: number;
    totalLength: number;
    chunkIndex: number;
}

export interface AiStreamReasoningContext {
    threadId?: string;
    assistantId: string;
    streamId: string;
    reasoningLength: number;
}

export interface AiStreamCompleteContext {
    threadId?: string;
    assistantId: string;
    streamId: string;
    totalLength: number;
    reasoningLength?: number;
    fileHashes?: string | null;
}

export interface AiStreamErrorContext {
    threadId?: string;
    streamId?: string;
    error?: unknown;
    aborted?: boolean;
}

export type AiStreamDeltaPayload = AiStreamDeltaContext;
export type AiStreamReasoningPayload = AiStreamReasoningContext;
export type AiStreamCompletePayload = AiStreamCompleteContext;
export type AiStreamErrorPayload = AiStreamErrorContext;

export interface AiRetryBeforePayload {
    threadId?: string;
    originalUserId: string;
    originalAssistantId?: string;
    triggeredBy: 'user' | 'assistant';
}

export interface AiRetryAfterPayload {
    threadId?: string;
    originalUserId: string;
    originalAssistantId?: string;
    newUserId?: string;
    newAssistantId?: string;
}
```

---

## Pane and UI payloads

| Name                         | Kind      | Description                                                            |
| ---------------------------- | --------- | ---------------------------------------------------------------------- | -------------- |
| `UiPaneMsgBase`              | interface | Core shape for pane messages (`id`, `threadId`, lengths, file hashes). |
| `UiPaneMsgReceived`          | interface | Extends `UiPaneMsgBase` with optional `reasoningLength`.               |
| `UiPaneActivePayload`        | interface | Fired when a pane becomes active (`pane`, `index`, `previousIndex`).   |
| `UiPaneBlurPayload`          | interface | Blur event payload capturing previous focus index.                     |
| `UiPaneSwitchPayload`        | interface | Pane switch payload with current and previous indices.                 |
| `UiPaneThreadChangedPayload` | interface | Thread change detail (old/new IDs, pane index, message count).         |
| `UiPaneDocChangedPayload`    | interface | Document change detail (old/new doc IDs, pane index, metadata).        |
| `UiPaneMsgSentPayload`       | interface | Outgoing pane message context including optional `meta`.               |
| `UiPaneMsgReceivedPayload`   | interface | Incoming pane message context including reasoning metadata.            |
| `UiSidebarSelectPayload`     | interface | Sidebar selection event (`kind: 'chat'                                 | 'doc'`, `id`). |
| `UiChatNewPayload`           | interface | Chat creation context (thread ID, creation timestamp).                 |
| `AppInitPayload`             | interface | Nuxt application bootstrap payload (`nuxtApp`).                        |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-types.ts
type PaneState = MultiPaneState;

export interface UiPaneMsgBase {
    id: string;
    threadId?: string;
    length?: number;
    fileHashes?: string | null;
}

export interface UiPaneMsgReceived extends UiPaneMsgBase {
    reasoningLength?: number;
}

export interface UiPaneActivePayload {
    pane: PaneState;
    index: number;
    previousIndex?: number;
}

export interface UiPaneBlurPayload {
    pane: PaneState;
    previousIndex: number;
}

export interface UiPaneSwitchPayload {
    pane: PaneState;
    index: number;
    previousIndex?: number;
}

export interface UiPaneThreadChangedPayload {
    pane: PaneState;
    oldThreadId: string | '';
    newThreadId: string;
    paneIndex: number;
    messageCount?: number;
}

export interface UiPaneDocChangedPayload {
    pane: PaneState;
    oldDocumentId: string | '';
    newDocumentId: string;
    paneIndex: number;
    meta?: Record<string, unknown>;
}

export interface UiPaneMsgSentPayload {
    pane: PaneState;
    paneIndex: number;
    message: UiPaneMsgBase;
    meta?: Record<string, unknown>;
}

export interface UiPaneMsgReceivedPayload {
    pane: PaneState;
    paneIndex: number;
    message: UiPaneMsgReceived;
    meta?: Record<string, unknown>;
}

export interface UiSidebarSelectPayload {
    kind: 'chat' | 'doc';
    id: string;
}

export interface UiChatNewPayload {
    threadId?: string;
    createdAt?: number;
}

export interface AppInitPayload {
    nuxtApp: any;
}
```

---

## Files, uploads, and attachments

| Name                      | Kind      | Description                                                                                       |
| ------------------------- | --------- | ------------------------------------------------------------------------------------------------- |
| `FilesAttachInputPayload` | interface | Filter payload describing a candidate file (`file`, `name`, `mime`, `size`, `kind`).              |
| `FilesAttachPayload`      | interface | Extends `FilesAttachInputPayload` with persistence metadata (`accepted`, optional `url`, `hash`). |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-types.ts
export interface FilesAttachInputPayload {
    file: File;
    name: string;
    mime: string;
    size: number;
    kind: 'image' | 'pdf';
}

export interface FilesAttachPayload extends FilesAttachInputPayload {
    accepted: boolean;
    url?: string;
    hash?: string;
}
```

---

## Branching and context utilities

| Name                        | Kind      | Description                                                                        |
| --------------------------- | --------- | ---------------------------------------------------------------------------------- |
| `BranchMode`                | alias     | `'reference'` or `'copy'` branch semantics.                                        |
| `BranchForkOptions`         | interface | Input parameters when forking threads (source IDs, mode, optional title override). |
| `BranchForkBeforePayload`   | interface | Pre-fork payload used by hooks (`source`, `anchor`, `mode`, optional `options`).   |
| `BranchContextAfterPayload` | interface | Post-branch context summary (thread counts, mode).                                 |
| `KvUpsertByNameInput`       | interface | Convenience payload for KV upserts by `name`.                                      |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-types.ts
export type BranchMode = 'reference' | 'copy';

export interface BranchForkOptions {
    sourceThreadId: string;
    anchorMessageId: string;
    mode?: BranchMode;
    titleOverride?: string;
}

export interface BranchForkBeforePayload {
    source: ThreadEntity;
    anchor: MessageEntity;
    mode: BranchMode;
    options?: { titleOverride?: string };
}

export interface BranchContextAfterPayload {
    threadId: string;
    mode: BranchMode;
    ancestorCount: number;
    localCount: number;
    finalCount: number;
}

export interface KvUpsertByNameInput {
    name: string;
    value: any;
}
```

---

## Entity mirrors and DB payload wrappers

| Name                 | Kind      | Description                                                                                |
| -------------------- | --------- | ------------------------------------------------------------------------------------------ |
| `MessageEntity`      | interface | Hook-friendly projection of a message row (`id`, `thread_id`, `role`, `data`, timestamps). |
| `ThreadEntity`       | interface | Thread metadata consumed by hooks (status, branching info, clock).                         |
| `DocumentEntity`     | interface | Document metadata for hooks (title, content, timestamps).                                  |
| `FileEntity`         | interface | File metadata (`hash`, `name`, `mime`, `size`, reference count).                           |
| `ProjectEntity`      | interface | Project record summary (name, description, clock flags).                                   |
| `PostEntity`         | interface | Lightweight post/blog record.                                                              |
| `PromptEntity`       | interface | Prompt data (`id`, `name`, `text`).                                                        |
| `AttachmentEntity`   | interface | Attachment record linking messages to files.                                               |
| `KvEntry`            | interface | Key-value store record (name/value, clocks, timestamps).                                   |
| `DbCreatePayload<T>` | interface | Generic wrapper emitted before/after `create` operations (`entity`, `tableName`).          |
| `DbUpdatePayload<T>` | interface | Wrapper for update lifecycle (existing, updated, patch, table).                            |
| `DbDeletePayload<T>` | interface | Wrapper for delete lifecycle (entity, id, table).                                          |

---

### TypeScript reference

```ts
// Source: app/core/hooks/hook-types.ts
export interface MessageEntity {
    id: string;
    thread_id: string;
    role: 'user' | 'assistant' | 'system';
    data: any;
    index: number;
    created_at: number;
    updated_at?: number;
}

export interface ThreadEntity {
    id: string;
    title?: string | null;
    created_at: number;
    updated_at: number;
    last_message_at?: number | null;
    parent_thread_id?: string | null;
    anchor_message_id?: string | null;
    anchor_index?: number | null;
    branch_mode?: 'reference' | 'copy' | null;
    status: string;
    deleted: boolean;
    pinned: boolean;
    clock: number;
    forked: boolean;
    project_id?: string | null;
    system_prompt_id?: string | null;
}

export interface DocumentEntity {
    id: string;
    title?: string;
    content?: string;
    created_at?: number;
    updated_at?: number;
}

export interface FileEntity {
    hash: string;
    name: string;
    mime: string;
    size: number;
    ref_count?: number;
}

export interface ProjectEntity {
    id: string;
    name: string;
    description?: string | null;
    data: any;
    created_at: number;
    updated_at: number;
    deleted: boolean;
    clock: number;
}

export interface PostEntity {
    id: string;
    title?: string;
    body?: string;
    created_at?: number;
    updated_at?: number;
}

export interface PromptEntity {
    id: string;
    name: string;
    text: string;
}

export interface AttachmentEntity {
    id: string;
    message_id?: string;
    file_hash?: string;
}

export interface KvEntry {
    id: string;
    name: string;
    value?: string | null;
    created_at: number;
    updated_at: number;
    clock: number;
}

export interface DbCreatePayload<T = any> {
    entity: T;
    tableName: string;
}

export interface DbUpdatePayload<T = any> {
    existing: T;
    updated: T;
    patch: Partial<T>;
    tableName: string;
}

export interface DbDeletePayload<T = any> {
    entity: T;
    id: string;
    tableName: string;
}
```

---

## Hook name families and DB literals

| Name                      | Kind             | Description                                                                                               |
| ------------------------- | ---------------- | --------------------------------------------------------------------------------------------------------- |
| `DbEntityName`            | union            | Valid entity literals for DB hooks (`'messages'`, `'threads'`, …).                                        |
| `DbOperation`             | union            | Supported DB operations (`'create'`, `'update'`, `'delete'`, `'get'`, `'search'`, `'normalize'`, etc.).   |
| `DbPhase`                 | union            | `'before'` or `'after'` lifecycle for action hooks.                                                       |
| `DbDeleteType`            | union            | Distinguishes `'soft'` vs `'hard'` delete hooks.                                                          |
| `DbActionHookName`        | template literal | Enumerates action hook naming convention across DB families (`db.posts.delete:action:soft:before`, etc.). |
| `DbFilterHookName`        | template literal | Enumerates filter hook naming convention (`db.messages.create:filter:input`, etc.).                       |
| `CoreActionHookName`      | conditional      | Extracts built-in action hook keys from `CoreHookPayloadMap`.                                             |
| `ExtensionActionHookName` | alias            | `keyof Or3ActionHooks`; supports module augmentation.                                                     |
| `ActionHookName`          | union            | Combines core and extension action hook names.                                                            |
| `CoreFilterHookName`      | conditional      | Extracts built-in filter hook keys from `CoreHookPayloadMap`.                                             |
| `ExtensionFilterHookName` | alias            | `keyof Or3FilterHooks`; extension hook keys.                                                              |
| `FilterHookName`          | union            | Combines core and extension filter names.                                                                 |
| `HookName`                | union            | Full set of action + filter names.                                                                        |

---

## Payload maps and inference helpers

| Name                              | Kind          | Description                                                                                       |
| --------------------------------- | ------------- | ------------------------------------------------------------------------------------------------- |
| `CoreHookPayloadMap`              | mapped type   | Master mapping from built-in hook names to argument tuples; foundation for inference.             |
| `HookPayloadMap`                  | intersection  | `CoreHookPayloadMap` combined with developer augmentations via `Or3ActionHooks`/`Or3FilterHooks`. |
| `InferHookParams<K>`              | conditional   | Resolves the argument tuple for hook name `K`.                                                    |
| `InferHookReturn<K>`              | conditional   | Infers the expected return type for hook `K` (void for actions, chained value for filters).       |
| `InferHookCallback<K>`            | function type | Convenience signature for callbacks keyed by `K`.                                                 |
| `IsAction<K>`                     | conditional   | Type predicate that narrows `true` when `K` is an action hook.                                    |
| `IsFilter<K>`                     | conditional   | Type predicate for filter hook names.                                                             |
| `ExtractHookPayload<K>`           | conditional   | Pulls the payload tuple for hook `K`.                                                             |
| `MatchingHooks<Pattern>`          | conditional   | Extracts hook names that match a template literal pattern.                                        |
| `InferDbEntity<K>`                | conditional   | Infers the DB entity type represented by a hook key (e.g. `db.messages.*`).                       |
| `Tail<T>`                         | alias         | Removes the first element from a tuple (`T extends [any, ...infer Rest] ? Rest : []`).            |
| `SuggestSimilar<K>`               | conditional   | Produces human-readable suggestions for invalid hook keys during type checking.                   |
| `ValidateHookName<K>`             | conditional   | Emits helpful diagnostics when a hook name is invalid.                                            |
| `TypeName<T>`                     | conditional   | Friendly string literal describing the TypeScript type `T`.                                       |
| `CallbackMismatch<Expected, Got>` | conditional   | Diagnostic helper that compares expected vs actual callback signatures.                           |

---

## Usage notes

-   The hook engine exposes runtime APIs via `HookEngine` while `TypedHookEngine` wraps them for inference. Use `useHooks()` to obtain the typed variant.
-   When adding new hook keys, update `HookPayloads` and the relevant payload interfaces so documentation and inference stay aligned.
-   Generics like `InferHookParams` and `MatchingHooks` power helper utilities and schema validation—reference them when building tooling around the hook system.
````
</file>

</files>
</file>

</files>
