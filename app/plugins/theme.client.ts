import { ref } from 'vue';
import { RuntimeResolver } from '~/theme/_shared/runtime-resolver';
import type {
    CompiledTheme,
    CompiledOverride,
    ParsedSelector,
    AttributeMatcher,
    AttributeOperator,
    OverrideProps,
} from '~/theme/_shared/types';

export default defineNuxtPlugin((nuxtApp) => {
    const THEME_CLASSES = [
        'light',
        'dark',
        'light-high-contrast',
        'dark-high-contrast',
        'light-medium-contrast',
        'dark-medium-contrast',
    ];

    const storageKey = 'theme';
    const activeThemeStorageKey = 'activeTheme';
    const root = document.documentElement;

    const getSystemPref = () =>
        window.matchMedia('(prefers-color-scheme: dark)').matches
            ? 'dark'
            : 'light';

    const apply = (name: string) => {
        for (const cls of THEME_CLASSES) root.classList.remove(cls);
        root.classList.add(name);
    };

    const read = () => localStorage.getItem(storageKey) as string | null;
    const readActiveTheme = () =>
        localStorage.getItem(activeThemeStorageKey) as string | null;

    const current = ref(read() || getSystemPref());
    apply(current.value);

    const set = (name: string) => {
        current.value = name;
        localStorage.setItem(storageKey, name);
        apply(name);
    };

    const toggle = () =>
        set(current.value.startsWith('dark') ? 'light' : 'dark');

    const media = window.matchMedia('(prefers-color-scheme: dark)');
    const onChange = (e: MediaQueryListEvent) => {
        if (!read()) {
            current.value = e.matches ? 'dark' : 'light';
            apply(current.value);
        }
    };
    media.addEventListener('change', onChange);

    nuxtApp.hook('app:beforeMount', () => {
        current.value = read() || getSystemPref();
        apply(current.value);
    });

    // Cleanup for HMR in dev so we don't stack listeners
    if (import.meta.hot) {
        import.meta.hot.dispose(() =>
            media.removeEventListener('change', onChange)
        );
    }

    // ===== REFINED THEME SYSTEM INTEGRATION =====
    // Load compiled theme configs and initialize resolvers

    // Registry of compiled themes and their resolvers
    const themeRegistry = new Map<string, CompiledTheme>();
    const resolverRegistry = new Map<string, RuntimeResolver>();

    // Active theme name (for refined theme system)
    const activeTheme = ref(readActiveTheme() || 'default');

    /**
     * Load a theme configuration
     *
     * This loads the theme definition and compiles it at runtime.
     * The theme compiler has already validated the theme at build time.
     *
     * Security: themeName is validated against available themes to prevent path traversal
     */
    const loadTheme = async (
        themeName: string
    ): Promise<CompiledTheme | null> => {
        try {
            // Validate theme name to prevent path traversal attacks
            // Only allow alphanumeric characters and hyphens
            if (!/^[a-z0-9-]+$/i.test(themeName)) {
                if (import.meta.dev) {
                    console.warn(`[theme] Invalid theme name: "${themeName}"`);
                }
                return null;
            }

            // Dynamic import of theme definition
            const themeModule = await import(
                `~/theme/${themeName}/theme.ts`
            ).catch(() => null);

            if (themeModule?.default) {
                const definition = themeModule.default;

                // Create a simple compiled theme from the definition
                // The full compilation happened at build time for validation
                const compiledTheme: CompiledTheme = {
                    name: definition.name,
                    displayName: definition.displayName,
                    description: definition.description,
                    // CSS variables are generated by the theme compiler at build time
                    // and included in the theme's styles.css file, so we don't need to
                    // generate them again at runtime
                    cssVariables: '',
                    overrides: compileOverridesRuntime(
                        definition.overrides || {}
                    ),
                    ui: definition.ui,
                    propMaps: definition.propMaps,
                };

                themeRegistry.set(themeName, compiledTheme);

                // Initialize resolver for this theme
                const resolver = new RuntimeResolver(compiledTheme);
                resolverRegistry.set(themeName, resolver);

                return compiledTheme;
            }
        } catch (error) {
            if (import.meta.dev) {
                console.warn(
                    `[theme] Failed to load theme "${themeName}":`,
                    error
                );
            }
        }

        return null;
    };

    /**
     * Simple runtime compilation of overrides
     * This mirrors the build-time compilation but runs in the browser
     */
    function compileOverridesRuntime(
        overrides: Record<string, OverrideProps>
    ): CompiledOverride[] {
        const compiled: CompiledOverride[] = [];

        for (const [selector, props] of Object.entries(overrides)) {
            const parsed = parseSelector(selector);
            const specificity = calculateSpecificity(parsed);

            compiled.push({
                component: parsed.component,
                context: parsed.context,
                identifier: parsed.identifier,
                state: parsed.state,
                attributes: parsed.attributes,
                props,
                selector,
                specificity,
            });
        }

        // Sort by specificity (descending)
        return compiled.sort((a, b) => b.specificity - a.specificity);
    }

    /**
     * Parse a CSS selector into components
     */
    function parseSelector(selector: string): ParsedSelector {
        const normalized = normalizeSelector(selector);

        const component = normalized.match(/^(\w+)/)?.[1] || 'button';
        const context = normalized.match(/data-context="([^"]+)"/)?.[1];
        const identifier = normalized.match(/data-id="([^"]+)"/)?.[1];
        const state = normalized.match(/:(\w+)/)?.[1];

        // Extract HTML attribute selectors
        const attributes: AttributeMatcher[] = [];
        // Fixed regex: match attribute name (word chars, hyphens), then optional operator and value
        const attrRegex = /\[([\w-]+)(([~|^$*]=|=)"([^"]+)")?\]/g;
        let match: RegExpExecArray | null;

        while ((match = attrRegex.exec(normalized)) !== null) {
            const attrName = match[1];
            if (
                !attrName ||
                attrName === 'data-context' ||
                attrName === 'data-id'
            )
                continue;

            const fullMatch = match[2]; // e.g., ^="btn" or ="submit"
            let operator: AttributeOperator = 'exists';
            let attrValue: string | undefined;

            if (fullMatch) {
                const op = match[3]; // e.g., "^=" or "="
                operator = op as AttributeOperator;
                attrValue = match[4]; // e.g., "btn" or "submit"
            }

            attributes.push({
                attribute: attrName,
                operator,
                value: attrValue,
            });
        }

        return {
            component,
            context,
            identifier,
            state,
            attributes: attributes.length > 0 ? attributes : undefined,
        };
    }

    /**
     * Normalize simple selector syntax to attribute selectors
     */
    function normalizeSelector(selector: string): string {
        let result = selector;

        // Convert .context to [data-context="context"]
        const knownContexts = [
            'chat',
            'sidebar',
            'dashboard',
            'header',
            'global',
        ];
        result = result.replace(
            /(\w+)\.(\w+)(?=[:\[]|$)/g,
            (match, component, context) => {
                if (knownContexts.includes(context)) {
                    return `${component}[data-context="${context}"]`;
                }
                return match;
            }
        );

        // Convert #identifier to [data-id="identifier"]
        result = result.replace(
            /(\w+)#([\w.]+)(?=[:\[]|$)/g,
            '$1[data-id="$2"]'
        );

        return result;
    }

    /**
     * Calculate CSS specificity
     */
    function calculateSpecificity(parsed: ParsedSelector): number {
        let specificity = 1; // element

        if (parsed.context) specificity += 10;
        if (parsed.identifier) specificity += 20;
        if (parsed.state) specificity += 10;
        if (parsed.attributes) specificity += parsed.attributes.length * 10;

        return specificity;
    }

    /**
     * Get resolver for a specific theme
     *
     * This is used by the v-theme directive to resolve overrides.
     */
    const getResolver = (themeName: string): RuntimeResolver | null => {
        // Return cached resolver if available
        if (resolverRegistry.has(themeName)) {
            return resolverRegistry.get(themeName)!;
        }

        // If theme is not loaded, try to load it synchronously
        // (This should rarely happen as themes are loaded on init)
        const theme = themeRegistry.get(themeName);
        if (theme) {
            const resolver = new RuntimeResolver(theme);
            resolverRegistry.set(themeName, resolver);
            return resolver;
        }

        if (import.meta.dev) {
            console.warn(
                `[theme] No resolver found for theme "${themeName}". Theme may not be compiled.`
            );
        }

        return null;
    };

    /**
     * Set active theme (for refined theme system)
     *
     * This switches the active theme and persists the selection.
     */
    const setActiveTheme = async (themeName: string) => {
        // Load theme if not already loaded
        if (!themeRegistry.has(themeName)) {
            await loadTheme(themeName);
        }

        // Update active theme
        activeTheme.value = themeName;
        localStorage.setItem(activeThemeStorageKey, themeName);

        // Apply CSS variables if theme provides them
        const theme = themeRegistry.get(themeName);
        if (theme?.cssVariables) {
            // TODO: Inject CSS variables into document
            // This will be implemented when we add CSS generation support
        }
    };

    // Initialize: Load retro theme by default
    loadTheme('retro').catch(() => {
        if (import.meta.dev) {
            console.warn('[theme] Failed to load retro theme');
        }
    });

    nuxtApp.provide('theme', {
        // Original theme API (for light/dark mode)
        set,
        toggle,
        get: () => current.value,
        system: getSystemPref,
        current, // expose ref for reactivity if needed

        // Refined theme system API (for theme variants)
        activeTheme, // Reactive ref to active theme name
        setActiveTheme, // Function to switch themes
        getResolver, // Function to get resolver for a theme
        loadTheme, // Function to dynamically load a theme
    });
});
